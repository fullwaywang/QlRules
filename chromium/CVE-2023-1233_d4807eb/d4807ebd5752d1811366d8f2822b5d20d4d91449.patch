commit d4807ebd5752d1811366d8f2822b5d20d4d91449	d4807ebd5752d1811366d8f2822b5d20d4d91449
Author: Hao Liu <haoliuk@chromium.org>
Date:   Tue Jan 3 16:28:33 2023 +0000

    Fix extension fingerprinting via resource timing entry
    
    This CL is to prevent resource timing entry being emitted for resources
    that are initiated in the Non main world.
    
    Test cases are added for resources initiated from both the main world
    and non main world.
    
    Bug: 1045681
    Change-Id: I309b54dae63f56e8d1d71e5c33507623b0c80389
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4116604
    Reviewed-by: Yoav Weiss <yoavweiss@chromium.org>
    Reviewed-by: Lei Zhang <thestig@chromium.org>
    Commit-Queue: Hao Liu <haoliuk@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1088254}

diff --git a/chrome/browser/performance_timeline_browsertest.cc b/chrome/browser/performance_timeline_browsertest.cc
new file mode 100644
index 0000000000000..d1038c6c72f2e
--- /dev/null
+++ b/chrome/browser/performance_timeline_browsertest.cc
@@ -0,0 +1,93 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/extension_browsertest.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+
+namespace {
+
+class PerformanceTimelineBrowserTest : public extensions::ExtensionBrowserTest {
+ protected:
+  content::WebContents* web_contents() const {
+    return browser()->tab_strip_model()->GetActiveWebContents();
+  }
+
+  void LoadScript(const extensions::Extension* extension) {
+    std::string script_code = content::JsReplace(
+        R"(
+          (async () => {
+            await new Promise( resolve => {
+              const script = document.createElement('script');
+              script.addEventListener('load', resolve);
+              document.body.appendChild(script);
+              script.src = $1;
+            });
+          })();
+        )",
+        extension->GetResourceURL(extension->url(), "content_script.js")
+            .spec());
+    EXPECT_EQ(content::EvalJs(web_contents(), script_code).error, "");
+  }
+};
+
+}  // namespace
+
+// Fetched resources that are initiated from the IsolatedWorld should have NO
+// resource timing entry emitted.
+IN_PROC_BROWSER_TEST_F(PerformanceTimelineBrowserTest,
+                       ResouceTiming_IsolatedWorld) {
+  ASSERT_TRUE(embedded_test_server()->Start());
+  const extensions::Extension* extension = LoadExtension(
+      test_data_dir_.AppendASCII("resource_timing/fetch_resource"));
+  ASSERT_TRUE(extension);
+  GURL test_url = embedded_test_server()->GetURL(
+      "/extensions/resource_timing/test-page.html");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+
+  // fetch resource from extension.
+  bool result = false;
+  EXPECT_TRUE(content::ExecuteScriptAndExtractBool(
+      web_contents(), "document.querySelector('#fetchResourceButton').click();",
+      &result));
+  EXPECT_TRUE(result);
+
+  // There should be 0 resource entry emitted.
+  EXPECT_EQ(content::EvalJs(web_contents(), "getResourceTimingEntryCount();")
+                .ExtractInt(),
+            0);
+}
+
+// Fetched resources that are initiated from the MainWorld should have one
+// resource timing entry emitted.
+IN_PROC_BROWSER_TEST_F(PerformanceTimelineBrowserTest,
+                       ResouceTiming_MainWorld) {
+  ASSERT_TRUE(embedded_test_server()->Start());
+  const extensions::Extension* extension = LoadExtension(
+      test_data_dir_.AppendASCII("resource_timing/fetch_resource"));
+  ASSERT_TRUE(extension);
+
+  GURL test_url = embedded_test_server()->GetURL(
+      "/extensions/resource_timing/test-page.html");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+
+  // Add script to DOM as a script tag element.
+  LoadScript(extension);
+
+  // Execute added script which is to fetch resource;
+  EXPECT_EQ(
+      content::EvalJs(web_contents(), "(async ()=>{await fetchResource();})()")
+          .error,
+      "");
+
+  // There should be 1 resource entry emitted.
+  EXPECT_EQ(
+      content::EvalJs(
+          web_contents(),
+          "(async ()=>{return await getResourceTimingEntryCountAsync();})()")
+          .ExtractInt(),
+      1);
+}
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 4a1e6fd94ef55..a2fd936f1a146 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -1984,6 +1984,7 @@ if (!is_android) {
       "../browser/performance_manager/page_load_tracker_decorator_browsertest.cc",
       "../browser/performance_manager/page_node_browsertest.cc",
       "../browser/performance_manager/policies/bfcache_policy_browsertest.cc",
+      "../browser/performance_timeline_browsertest.cc",
       "../browser/permissions/permission_delegation_browsertest.cc",
       "../browser/permissions/permission_manager_browsertest.cc",
       "../browser/permissions/permission_request_manager_browsertest.cc",
diff --git a/chrome/test/data/extensions/resource_timing/24.png b/chrome/test/data/extensions/resource_timing/24.png
new file mode 100644
index 0000000000000..acb1f09691342
Binary files /dev/null and b/chrome/test/data/extensions/resource_timing/24.png differ
diff --git a/chrome/test/data/extensions/resource_timing/fetch_resource/content_script.js b/chrome/test/data/extensions/resource_timing/fetch_resource/content_script.js
new file mode 100644
index 0000000000000..eb7974a65abfa
--- /dev/null
+++ b/chrome/test/data/extensions/resource_timing/fetch_resource/content_script.js
@@ -0,0 +1,22 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Add a button to the page that can fetch resource.
+const button = document.createElement('button');
+button.id = 'fetchResourceButton';
+button.innerText = 'fetch resource';
+document.body.appendChild(button);
+
+// This fetch runs in the isolated world.
+button.onclick = async () => {
+  await fetch('/extensions/resource_timing/24.png').then(
+    () => { window.domAutomationController.send(true); }).catch(
+      () => { window.domAutomationController.send(false); });
+};
+
+// This is loaded as a script tag element into the DOM and the fetch runs in the
+// main world.
+async function fetchResource() {
+  await fetch('/extensions/resource_timing/24.png');
+}
diff --git a/chrome/test/data/extensions/resource_timing/fetch_resource/manifest.json b/chrome/test/data/extensions/resource_timing/fetch_resource/manifest.json
new file mode 100644
index 0000000000000..c3185a4594d00
--- /dev/null
+++ b/chrome/test/data/extensions/resource_timing/fetch_resource/manifest.json
@@ -0,0 +1,28 @@
+{
+  "name": "Fetch resource",
+  "version": "1",
+  "manifest_version": 3,
+  "web_accessible_resources": [
+    {
+      "resources": [
+        "content_script.js"
+      ],
+      "matches": [
+        "*://*/*"
+      ]
+    }
+  ],
+  "content_scripts": [
+    {
+      "js": [
+        "content_script.js"
+      ],
+      "matches": [
+        "*://*/*"
+      ]
+    }
+  ],
+  "permissions": [
+    "tabs"
+  ]
+}
diff --git a/chrome/test/data/extensions/resource_timing/test-page.html b/chrome/test/data/extensions/resource_timing/test-page.html
new file mode 100644
index 0000000000000..2deb9e9b76621
--- /dev/null
+++ b/chrome/test/data/extensions/resource_timing/test-page.html
@@ -0,0 +1,29 @@
+<!doctype html>
+<html>
+
+<head>
+  <title>Resource Fetched That Are Initiated from Content Script</title>
+</head>
+
+<body>
+  Such resource should not trigger performance timeline resource timing entry.
+  <script>
+    const getResourceTimingEntryCount = () => {
+      console.log('getResourceTimingEntryCount');
+      return performance.getEntriesByType('resource').filter(e => e.name.includes('24.png')).length;
+    }
+
+    const getResourceTimingEntryCountAsync = async () => {
+      return await new Promise(resolve => {
+        new PerformanceObserver(entryList => {
+          const length = entryList.getEntries().filter(e => e.name.includes('24.png')).length;
+          if (length) {
+            resolve(length);
+          }
+        }).observe({ type: 'resource', buffered: true });
+      });
+    }
+  </script>
+</body>
+
+</html>
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
index 7fd36c5cba9fc..131c3dbcaa42e 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
@@ -2510,6 +2510,13 @@ void ResourceFetcher::PopulateAndAddResourceTimingInfo(
   if (resource->GetResourceRequest().IsFromOriginDirtyStyleSheet())
     return;
 
+  // Resource timing entries that correspond to resources fetched by extensions
+  // are precluded.
+  if (resource->Options().world_for_csp.get() &&
+      resource->Options().world_for_csp->IsIsolatedWorld()) {
+    return;
+  }
+
   const KURL& initial_url =
       resource->GetResourceRequest().GetRedirectInfo().has_value()
           ? resource->GetResourceRequest().GetRedirectInfo()->original_url
