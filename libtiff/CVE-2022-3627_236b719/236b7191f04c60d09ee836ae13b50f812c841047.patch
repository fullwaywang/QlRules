commit 236b7191f04c60d09ee836ae13b50f812c841047 (from a5c596561a26f45ec09765322f0080bdb9f012b4)	236b7191f04c60d09ee836ae13b50f812c841047
Merge: a5c59656 4746f162
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Wed Oct 12 20:54:01 2022 +0000

    Merge branch 'tiffcrop_fix_#411_#413' into 'master'
    
    tiffcrop: disable incompatibility of -Z, -X, -Y, -z options with any PAGE_MODE_x option (fixes #411, #413 and #426)
    
    Closes #426, #413 et #411
    
    See merge request libtiff/libtiff!383

diff --git a/doc/tools/tiffcrop.rst b/doc/tools/tiffcrop.rst
index ee0d2d81..b5e8e744 100644
--- a/doc/tools/tiffcrop.rst
+++ b/doc/tools/tiffcrop.rst
@@ -415,6 +415,14 @@ Options
   Note: :program:`tiffcrop` may be compiled with :command:`-DDEVELMODE` to enable
   additional very low level debug reporting.
 
+However, not all option combinations are permitted.
+
+  Note 1: The (-X|-Y), -Z, -z and -S options are mutually exclusive.
+  In no case should the options be applied to a given selection successively.
+
+  Note 2: Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options
+  such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.
+  
 Examples
 --------
 
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 8fd856dc..41a2ea36 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -107,13 +107,15 @@
  *                selects which functions dump data, with higher numbers selecting
  *                lower level, scanline level routines. Debug reports a limited set
  *                of messages to monitor progress without enabling dump logs.
- * 
- * Note:    The (-X|-Y), -Z, -z and -S options are mutually exclusive.
+ *
+ * Note 1:  The (-X|-Y), -Z, -z and -S options are mutually exclusive.
  *          In no case should the options be applied to a given selection successively.
- */
+ * Note 2:  Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options
+ *          such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.
+  */
 
-static   char tiffcrop_version_id[] = "2.5.1";
-static   char tiffcrop_rev_date[] = "15-08-2022";
+static   char tiffcrop_version_id[] = "2.5.3";
+static   char tiffcrop_rev_date[] = "26-08-2022";
 
 #include "tif_config.h"
 #include "libport.h"
@@ -781,9 +783,12 @@ static const char usage_info[] =
 "             The four debug/dump options are independent, though it makes little sense to\n"
 "             specify a dump file without specifying a detail level.\n"
 "\n"
-"Note:        The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n"
+"Note 1:      The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n"
 "             In no case should the options be applied to a given selection successively.\n"
 "\n"
+"Note 2:      Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options\n"
+"             such as - H, -V, -P, -J or -K are not supported and may cause buffer overflows.\n"
+"\n"
 ;
 
 /* This function could be modified to pass starting sample offset 
@@ -2138,9 +2143,20 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32
     R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;
     S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;
     if (XY + Z + R + S > 1) {
-        TIFFError("tiffcrop input error", "The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit");
+        TIFFError("tiffcrop input error", "The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->exit");
         exit(EXIT_FAILURE);
     }
+
+    /* Check for not allowed combination:
+     * Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options
+     * such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.
+.    */
+    if ((XY + Z + R > 0) && page->mode != PAGE_MODE_NONE) {
+        TIFFError("tiffcrop input error",
+            "Any of the crop options -X, -Y, -Z and -z together with other PAGE_MODE_x options such as - H, -V, -P, -J or -K is not supported and may cause buffer overflows..->exit");
+        exit(EXIT_FAILURE);
+    }
+
   }  /* end process_command_opts */
 
 /* Start a new output file if one has not been previously opened or
@@ -2411,6 +2427,7 @@ main(int argc, char* argv[])
         exit (EXIT_FAILURE);
 	}
 
+      /* Crop input image and copy zones and regions from input image into seg_buffs or crop_buff. */
       if (crop.selections > 0)
         {
         if (processCropSelections(&image, &crop, &read_buff, seg_buffs))
@@ -2427,6 +2444,7 @@ main(int argc, char* argv[])
           exit (EXIT_FAILURE);
 	  }
 	}
+      /* Format and write selected image parts to output file(s). */
       if (page.mode == PAGE_MODE_NONE)
         {  /* Whole image or sections not based on output page size */
         if (crop.selections > 0)

commit 236b7191f04c60d09ee836ae13b50f812c841047 (from 4746f16253b784287bc8a5003990c1c3b9a03a62)	236b7191f04c60d09ee836ae13b50f812c841047
Merge: a5c59656 4746f162
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Wed Oct 12 20:54:01 2022 +0000

    Merge branch 'tiffcrop_fix_#411_#413' into 'master'
    
    tiffcrop: disable incompatibility of -Z, -X, -Y, -z options with any PAGE_MODE_x option (fixes #411, #413 and #426)
    
    Closes #426, #413 et #411
    
    See merge request libtiff/libtiff!383

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 26acca80..0f346627 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -39,26 +39,33 @@ message(STATUS "libtiff library version ${SO_VERSION}")
 string(TIMESTAMP BUILD_DATE "%Y%m%d")
 message(STATUS "libtiff build date: ${BUILD_DATE}")
 
+# Project definition
+set(CMAKE_C_STANDARD 99)
+project(tiff
+        VERSION "${LIBTIFF_VERSION}"
+        LANGUAGES C CXX)
 
-set(BUILD_SHARED_LIBS ON CACHE BOOL "Build shared libraries")
+if(NOT CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR)
+  # libtiff is being included as a subproject of some other project.
+  set(TIFF_INSTALL_DEFAULT OFF)
+  option(BUILD_SHARED_LIBS "Build shared libraries" ON)
+else()
+  set(TIFF_INSTALL_DEFAULT ON)
+  set(tiff-install ON)
+endif()
 
 option(tiff-tools "build TIFF tools" ON)
 option(tiff-tests "build TIFF tests" ON)
 option(tiff-contrib "build TIFF contrib" ON)
 option(tiff-docs "build TIFF documentation" ON)
 option(tiff-deprecated "build TIFF deprecated features" OFF)
+option(tiff-install "install TIFF targets" ${TIFF_INSTALL_DEFAULT})
 
 # Disable deprecated features to ensure clean build
 if (tiff-deprecated)
   add_definitions(-DTIFF_DISABLE_DEPRECATED)
 endif()
 
-# Project definition
-set(CMAKE_C_STANDARD 99)
-project(tiff
-        VERSION "${LIBTIFF_VERSION}"
-        LANGUAGES C CXX)
-
 # Autotools compatibility
 include(AutotoolsCompat)
 
diff --git a/cmake/Release.cmake b/cmake/Release.cmake
index fbf34cc6..5deba03d 100644
--- a/cmake/Release.cmake
+++ b/cmake/Release.cmake
@@ -23,7 +23,7 @@
 # OF THIS SOFTWARE.
 
 
-add_custom_target(release
+add_custom_target(tiff_release
         COMMAND ${CMAKE_COMMAND}
         "-DSOURCE_DIR:PATH=${PROJECT_SOURCE_DIR}"
         "-DLIBTIFF_VERSION=${PROJECT_VERSION}"
diff --git a/cmake/ZSTDCodec.cmake b/cmake/ZSTDCodec.cmake
index d3d2de80..490d75c4 100644
--- a/cmake/ZSTDCodec.cmake
+++ b/cmake/ZSTDCodec.cmake
@@ -31,13 +31,16 @@ set(ZSTD_USABLE FALSE)
 find_package(ZSTD)
 
 if(ZSTD_FOUND)
-    set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})
-    set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${ZSTD_INCLUDE_DIRS})
-    set(CMAKE_REQUIRED_LIBRARIES_SAVE ${CMAKE_REQUIRED_LIBRARIES})
-    set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${ZSTD_LIBRARIES})
-    check_symbol_exists(ZSTD_decompressStream "zstd.h" ZSTD_RECENT_ENOUGH)
-    set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})
-    set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_SAVE})
+    if(NOT DEFINED ZSTD_HAVE_DECOMPRESS_STREAM)
+      set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})
+      set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${ZSTD_INCLUDE_DIRS})
+      set(CMAKE_REQUIRED_LIBRARIES_SAVE ${CMAKE_REQUIRED_LIBRARIES})
+      set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${ZSTD_LIBRARIES})
+      check_symbol_exists(ZSTD_decompressStream "zstd.h" ZSTD_HAVE_DECOMPRESS_STREAM)
+      set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})
+      set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_SAVE})
+    endif()
+    set(ZSTD_RECENT_ENOUGH ${ZSTD_HAVE_DECOMPRESS_STREAM})
 
     if (ZSTD_RECENT_ENOUGH)
         set(ZSTD_USABLE TRUE)
diff --git a/contrib/addtiffo/CMakeLists.txt b/contrib/addtiffo/CMakeLists.txt
index 2f3959bc..7c86e950 100644
--- a/contrib/addtiffo/CMakeLists.txt
+++ b/contrib/addtiffo/CMakeLists.txt
@@ -23,7 +23,7 @@
 # OF THIS SOFTWARE.
 
 add_executable(addtiffo addtiffo.c tif_overview.c tif_ovrcache.c tif_ovrcache.h)
-target_link_libraries(addtiffo tiff port)
+target_link_libraries(addtiffo tiff tiff_port)
 
 if(WEBP_SUPPORT AND EMSCRIPTEN)
   # Emscripten is pretty finnicky about linker flags.
diff --git a/contrib/dbs/CMakeLists.txt b/contrib/dbs/CMakeLists.txt
index b5681777..74b2a02a 100644
--- a/contrib/dbs/CMakeLists.txt
+++ b/contrib/dbs/CMakeLists.txt
@@ -23,16 +23,16 @@
 # OF THIS SOFTWARE.
 
 add_executable(tiff-bi tiff-bi.c)
-target_link_libraries(tiff-bi tiff port)
+target_link_libraries(tiff-bi tiff tiff_port)
 
 add_executable(tiff-grayscale tiff-grayscale.c)
-target_link_libraries(tiff-grayscale tiff port CMath::CMath)
+target_link_libraries(tiff-grayscale tiff tiff_port CMath::CMath)
 
 add_executable(tiff-palette tiff-palette.c)
-target_link_libraries(tiff-palette tiff port)
+target_link_libraries(tiff-palette tiff tiff_port)
 
 add_executable(tiff-rgb tiff-rgb.c)
-target_link_libraries(tiff-rgb tiff port CMath::CMath)
+target_link_libraries(tiff-rgb tiff tiff_port CMath::CMath)
 
 if(WEBP_SUPPORT AND EMSCRIPTEN)
   # Emscripten is pretty finnicky about linker flags.
diff --git a/contrib/iptcutil/CMakeLists.txt b/contrib/iptcutil/CMakeLists.txt
index 39d908c6..d13319c6 100644
--- a/contrib/iptcutil/CMakeLists.txt
+++ b/contrib/iptcutil/CMakeLists.txt
@@ -23,4 +23,4 @@
 # OF THIS SOFTWARE.
 
 add_executable(iptcutil iptcutil.c)
-target_link_libraries(iptcutil tiff port)
+target_link_libraries(iptcutil tiff tiff_port)
diff --git a/contrib/iptcutil/iptcutil.c b/contrib/iptcutil/iptcutil.c
index 404b209e..22dce1aa 100644
--- a/contrib/iptcutil/iptcutil.c
+++ b/contrib/iptcutil/iptcutil.c
@@ -343,12 +343,12 @@ char *super_fgets(char *b, int *blen, FILE *file)
       c=fgetc(file);
       if (c == EOF || c == '\n')
         break;
-      if (((long)q - (long)b + 1 ) >= (long) len)
+      if ( (int)(q - b + 1) >= len) 
         {
           long
             tlen;
 
-          tlen=(long)q-(long)b;
+          tlen=(int)(q - b);
           len<<=1;
           b=(char *) realloc((char *) b,(len+2));
           if ((char *) b == (char *) NULL)
@@ -363,7 +363,7 @@ char *super_fgets(char *b, int *blen, FILE *file)
       int
         tlen;
 
-      tlen=(long)q - (long)b;
+      tlen=(int)(q - b);
       if (tlen == 0)
         return (char *) NULL;
       b[tlen] = '\0';
@@ -532,7 +532,7 @@ int main(int argc, char *argv[])
                       quoted;
 
                     next=0;
-                    len = strlen(token);
+                    len = (unsigned long)strlen(token);
                     while(tokenizer(0, newstr, inputlen, token, "", "&", "", 0,
                                     &brkused, &next, &quoted)==0)
                       {
@@ -541,7 +541,7 @@ int main(int argc, char *argv[])
                             char
                               *s = &token[next-1];
 
-                            len -= convertHTMLcodes(s, strlen(s));
+                            len -= convertHTMLcodes(s, (int)strlen(s));
                           }
                       }
 
diff --git a/libtiff/CMakeLists.txt b/libtiff/CMakeLists.txt
index 3fab9b67..b4a15027 100755
--- a/libtiff/CMakeLists.txt
+++ b/libtiff/CMakeLists.txt
@@ -46,6 +46,7 @@ set(tiff_private_HEADERS
 
 
 add_library(tiff libtiff.def)
+add_library(TIFF::TIFF ALIAS tiff)
 
 target_sources(tiff PRIVATE
         ${tiff_public_HEADERS}
@@ -148,8 +149,8 @@ if(WEBP_SUPPORT)
   target_link_libraries(tiff PRIVATE WebP::WebP)
   string(APPEND tiff_requires_private " libwebp")
 endif()
-target_link_libraries(tiff PRIVATE CMath::CMath)
 if(CMath_LIBRARY)
+  target_link_libraries(tiff PRIVATE CMath::CMath)
   list(APPEND tiff_libs_private_list "${CMath_LIBRARY}")
 endif()
 
@@ -169,21 +170,23 @@ if(HAVE_LD_VERSION_SCRIPT)
                         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/libtiff.map")
 endif()
 
-export(TARGETS tiff NAMESPACE TIFF:: FILE "${CMAKE_CURRENT_BINARY_DIR}/libtiffTargets.cmake")
-install(TARGETS tiff EXPORT TiffTargets
-        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
+if(tiff-install)
+  export(TARGETS tiff NAMESPACE TIFF:: FILE "${CMAKE_CURRENT_BINARY_DIR}/libtiffTargets.cmake")
+  install(TARGETS tiff EXPORT TiffTargets
+          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
-install(FILES ${tiff_public_HEADERS}
-        DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
+  install(FILES ${tiff_public_HEADERS}
+          DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
-set(TIFF_CONFIGDIR ${CMAKE_INSTALL_LIBDIR}/cmake/tiff)
-install(EXPORT TiffTargets
-        FILE TiffTargets.cmake
-        NAMESPACE TIFF::
-        DESTINATION ${TIFF_CONFIGDIR}
-)
+  set(TIFF_CONFIGDIR ${CMAKE_INSTALL_LIBDIR}/cmake/tiff)
+  install(EXPORT TiffTargets
+          FILE TiffTargets.cmake
+          NAMESPACE TIFF::
+          DESTINATION ${TIFF_CONFIGDIR}
+  )
+endif()
 
 if(CXX_SUPPORT)
   set(tiffxx_HEADERS
@@ -196,6 +199,8 @@ if(CXX_SUPPORT)
       add_library(tiffxx ../placeholder.h)
   endif()
 
+  add_library(TIFF::CXX ALIAS tiffxx)
+
   target_sources(tiffxx PRIVATE
           ${tiffxx_HEADERS}
           tif_stream.cxx)
@@ -213,24 +218,26 @@ if(CXX_SUPPORT)
                           "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/libtiffxx.map")
   endif()
 
-  install(TARGETS tiffxx
-          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-  install(FILES ${tiffxx_HEADERS}
-          DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
+  if(tiff-install)
+    install(TARGETS tiffxx
+            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
+    install(FILES ${tiffxx_HEADERS}
+            DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
+  endif()
+      
 endif()
 
 if(NOT CMAKE_CROSSCOMPILING)
-  add_executable(mkg3states ../placeholder.h)
-  target_sources(mkg3states PRIVATE mkg3states.c tif_fax3.h)
-  target_link_libraries(mkg3states tiff port)
+  add_executable(tiff_mkg3states ../placeholder.h)
+  target_sources(tiff_mkg3states PRIVATE mkg3states.c tif_fax3.h)
+  target_link_libraries(tiff_mkg3states tiff tiff_port)
 
-  add_custom_target(faxtable
-          DEPENDS mkg3states
+  add_custom_target(tiff_faxtable
+          DEPENDS tiff_mkg3states
           COMMAND ${CMAKE_COMMAND} -E rm "tif_fax3sm.c"
-          COMMAND mkg3states -b -c const "tif_fax3sm.c"
+          COMMAND tiff_mkg3states -b -c const "tif_fax3sm.c"
           WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
 endif()
diff --git a/libtiff/tif_close.c b/libtiff/tif_close.c
index 04977bc7..441b909b 100644
--- a/libtiff/tif_close.c
+++ b/libtiff/tif_close.c
@@ -52,8 +52,10 @@ TIFFCleanup(TIFF* tif)
 	(*tif->tif_cleanup)(tif);
 	TIFFFreeDirectory(tif);
 
-	if (tif->tif_dirlist)
-		_TIFFfree(tif->tif_dirlist);
+	if (tif->tif_dirlistoff)
+		_TIFFfree(tif->tif_dirlistoff);
+	if (tif->tif_dirlistdirn)
+		_TIFFfree(tif->tif_dirlistdirn);
 
 	/*
          * Clean up client info links.
diff --git a/libtiff/tif_dir.c b/libtiff/tif_dir.c
index 793e8a79..9b153b63 100644
--- a/libtiff/tif_dir.c
+++ b/libtiff/tif_dir.c
@@ -1582,12 +1582,22 @@ TIFFDefaultDirectory(TIFF* tif)
 }
 
 static int
-TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
+TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdiroff, uint64_t* off, uint16_t* nextdirnum)
 {
 	static const char module[] = "TIFFAdvanceDirectory";
+
+	/* Add this directory to the directory list, if not already in. */
+	if (!_TIFFCheckDirNumberAndOffset(tif, *nextdirnum, *nextdiroff)) {
+		TIFFErrorExt(tif->tif_clientdata, module, "Starting directory %"PRIu16" at offset 0x%"PRIx64" (%"PRIu64") might cause an IFD loop",
+			*nextdirnum, *nextdiroff, *nextdiroff);
+		*nextdiroff = 0;
+		*nextdirnum = 0;
+		return(0);
+	}
+
 	if (isMapped(tif))
 	{
-		uint64_t poff=*nextdir;
+		uint64_t poff=*nextdiroff;
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
 			tmsize_t poffa,poffb,poffc,poffd;
@@ -1598,7 +1608,7 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 			if (((uint64_t)poffa != poff) || (poffb < poffa) || (poffb < (tmsize_t)sizeof(uint16_t)) || (poffb > tif->tif_size))
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
-                                  *nextdir=0;
+                                  *nextdiroff=0;
 				return(0);
 			}
 			_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16_t));
@@ -1616,16 +1626,21 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 			_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32_t));
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong(&nextdir32);
-			*nextdir=nextdir32;
+			*nextdiroff=nextdir32;
 		}
 		else
 		{
 			tmsize_t poffa,poffb,poffc,poffd;
 			uint64_t dircount64;
 			uint16_t dircount16;
+			if( poff > (uint64_t)TIFF_TMSIZE_T_MAX - sizeof(uint64_t) )
+			{
+				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
+				return(0);
+			}
 			poffa=(tmsize_t)poff;
 			poffb=poffa+sizeof(uint64_t);
-			if (((uint64_t)poffa != poff) || (poffb < poffa) || (poffb < (tmsize_t)sizeof(uint64_t)) || (poffb > tif->tif_size))
+			if (poffb > tif->tif_size)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
 				return(0);
@@ -1639,20 +1654,24 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 				return(0);
 			}
 			dircount16=(uint16_t)dircount64;
+			if( poffb > TIFF_TMSIZE_T_MAX - (tmsize_t)(dircount16*20) - (tmsize_t)sizeof(uint64_t) )
+			{
+				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
+				return(0);
+			}
 			poffc=poffb+dircount16*20;
 			poffd=poffc+sizeof(uint64_t);
-			if ((poffc<poffb) || (poffc<dircount16*20) || (poffd<poffc) || (poffd<(tmsize_t)sizeof(uint64_t)) || (poffd > tif->tif_size))
+			if (poffd > tif->tif_size)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
 				return(0);
 			}
 			if (off!=NULL)
 				*off=(uint64_t)poffc;
-			_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64_t));
+			_TIFFmemcpy(nextdiroff,tif->tif_base+poffc,sizeof(uint64_t));
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabLong8(nextdir);
+				TIFFSwabLong8(nextdiroff);
 		}
-		return(1);
 	}
 	else
 	{
@@ -1660,7 +1679,7 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 		{
 			uint16_t dircount;
 			uint32_t nextdir32;
-			if (!SeekOK(tif, *nextdir) ||
+			if (!SeekOK(tif, *nextdiroff) ||
 			    !ReadOK(tif, &dircount, sizeof (uint16_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
 				    tif->tif_name);
@@ -1681,13 +1700,13 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 			}
 			if (tif->tif_flags & TIFF_SWAB)
 				TIFFSwabLong(&nextdir32);
-			*nextdir=nextdir32;
+			*nextdiroff=nextdir32;
 		}
 		else
 		{
 			uint64_t dircount64;
 			uint16_t dircount16;
-			if (!SeekOK(tif, *nextdir) ||
+			if (!SeekOK(tif, *nextdiroff) ||
 			    !ReadOK(tif, &dircount64, sizeof (uint64_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
 				    tif->tif_name);
@@ -1707,17 +1726,27 @@ TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 			else
 				(void) TIFFSeekFile(tif,
 				    dircount16*20, SEEK_CUR);
-			if (!ReadOK(tif, nextdir, sizeof (uint64_t))) {
+			if (!ReadOK(tif, nextdiroff, sizeof (uint64_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module,
                                              "%s: Error fetching directory link",
 				    tif->tif_name);
 				return (0);
 			}
 			if (tif->tif_flags & TIFF_SWAB)
-				TIFFSwabLong8(nextdir);
+				TIFFSwabLong8(nextdiroff);
+		}
+	}
+	if (*nextdiroff != 0) {
+		(*nextdirnum)++;
+		/* Check next directory for IFD looping and if so, set it as last directory. */
+		if (!_TIFFCheckDirNumberAndOffset(tif, *nextdirnum, *nextdiroff)) {
+			TIFFWarningExt(tif->tif_clientdata, module, "the next directory %"PRIu16" at offset 0x%"PRIx64" (%"PRIu64") might be an IFD loop. Treating directory %"PRIu16" as last directory",
+				*nextdirnum, *nextdiroff, *nextdiroff, *nextdirnum-1);
+			*nextdiroff = 0;
+			(*nextdirnum)--;
 		}
-		return (1);
 	}
+	return (1);
 }
 
 /*
@@ -1727,14 +1756,16 @@ uint16_t
 TIFFNumberOfDirectories(TIFF* tif)
 {
 	static const char module[] = "TIFFNumberOfDirectories";
-	uint64_t nextdir;
+	uint64_t nextdiroff;
+	uint16_t nextdirnum;
 	uint16_t n;
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
-		nextdir = tif->tif_header.classic.tiff_diroff;
+		nextdiroff = tif->tif_header.classic.tiff_diroff;
 	else
-		nextdir = tif->tif_header.big.tiff_diroff;
+		nextdiroff = tif->tif_header.big.tiff_diroff;
+	nextdirnum = 0;
 	n = 0;
-	while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))
+	while (nextdiroff != 0 && TIFFAdvanceDirectory(tif, &nextdiroff, NULL, &nextdirnum))
         {
                 if (n != 65535) {
                         ++n;
@@ -1757,28 +1788,30 @@ TIFFNumberOfDirectories(TIFF* tif)
 int
 TIFFSetDirectory(TIFF* tif, uint16_t dirn)
 {
-	uint64_t nextdir;
+	uint64_t nextdiroff;
+	uint16_t nextdirnum;
 	uint16_t n;
 
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
-		nextdir = tif->tif_header.classic.tiff_diroff;
+		nextdiroff = tif->tif_header.classic.tiff_diroff;
 	else
-		nextdir = tif->tif_header.big.tiff_diroff;
-	for (n = dirn; n > 0 && nextdir != 0; n--)
-		if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
+		nextdiroff = tif->tif_header.big.tiff_diroff;
+	nextdirnum = 0;
+	for (n = dirn; n > 0 && nextdiroff != 0; n--)
+		if (!TIFFAdvanceDirectory(tif, &nextdiroff, NULL, &nextdirnum))
 			return (0);
-	tif->tif_nextdiroff = nextdir;
+	/* If the n-th directory could not be reached (does not exist), 
+	 * return here without touching anything further. */
+	if (nextdiroff == 0 || n > 0)
+		return (0);
+
+	tif->tif_nextdiroff = nextdiroff;
 	/*
 	 * Set curdir to the actual directory index.  The
 	 * -1 is because TIFFReadDirectory will increment
 	 * tif_curdir after successfully reading the directory.
 	 */
 	tif->tif_curdir = (dirn - n) - 1;
-	/*
-	 * Reset tif_dirnumber counter and start new list of seen directories.
-	 * We need this to prevent IFD loops.
-	 */
-	tif->tif_dirnumber = 0;
 	return (TIFFReadDirectory(tif));
 }
 
@@ -1791,13 +1824,42 @@ TIFFSetDirectory(TIFF* tif, uint16_t dirn)
 int
 TIFFSetSubDirectory(TIFF* tif, uint64_t diroff)
 {
-	tif->tif_nextdiroff = diroff;
-	/*
-	 * Reset tif_dirnumber counter and start new list of seen directories.
-	 * We need this to prevent IFD loops.
+	/* Match nextdiroff and curdir for consistent IFD-loop checking. 
+	 * Only with TIFFSetSubDirectory() the IFD list can be corrupted with invalid offsets
+	 * within the main IFD tree.
+	 * In the case of several subIFDs of a main image, 
+	 * there are two possibilities that are not even mutually exclusive.
+	 * a.) The subIFD tag contains an array with all offsets of the subIFDs.
+	 * b.) The SubIFDs are concatenated with their NextIFD parameters.
+	 * (refer to https://www.awaresystems.be/imaging/tiff/specification/TIFFPM6.pdf.)
 	 */
-	tif->tif_dirnumber = 0;
-	return (TIFFReadDirectory(tif));
+	int retval;
+	uint16_t curdir = 0;
+	int8_t probablySubIFD = 0;
+	if (diroff == 0) {
+		/* Special case to invalidate the tif_lastdiroff member. */
+		tif->tif_curdir = 65535;
+	} else {
+		if (!_TIFFGetDirNumberFromOffset(tif, diroff, &curdir)) {
+			/* Non-existing offsets might point to a SubIFD or invalid IFD.*/
+			probablySubIFD = 1;
+		}
+		/* -1 because TIFFReadDirectory() will increment tif_curdir. */
+		tif->tif_curdir = curdir - 1;
+	}
+
+	tif->tif_nextdiroff = diroff;
+	retval = TIFFReadDirectory(tif);
+	/* If failed, curdir was not incremented in TIFFReadDirectory(), so set it back. */
+	if (!retval )tif->tif_curdir++; 
+	if (retval && probablySubIFD) {
+		/* Reset IFD list to start new one for SubIFD chain and also start SubIFD chain with tif_curdir=0. */
+		tif->tif_dirnumber = 0; 
+		tif->tif_curdir = 0; /* first directory of new chain */
+		/* add this offset to new IFD list */
+		_TIFFCheckDirNumberAndOffset(tif, tif->tif_curdir, diroff);
+	}
+	return (retval);
 }
 
 /*
@@ -1821,12 +1883,15 @@ TIFFLastDirectory(TIFF* tif)
 
 /*
  * Unlink the specified directory from the directory chain.
+ * Note: First directory starts with number dirn=1. 
+ * This is different to TIFFSetDirectory() where the first directory starts with zero.
  */
 int
 TIFFUnlinkDirectory(TIFF* tif, uint16_t dirn)
 {
 	static const char module[] = "TIFFUnlinkDirectory";
 	uint64_t nextdir;
+	uint16_t nextdirnum;
 	uint64_t off;
 	uint16_t n;
 
@@ -1850,19 +1915,21 @@ TIFFUnlinkDirectory(TIFF* tif, uint16_t dirn)
 		nextdir = tif->tif_header.big.tiff_diroff;
 		off = 8;
 	}
+	nextdirnum = 0;		/* First directory is dirn=0 */
+
 	for (n = dirn-1; n > 0; n--) {
 		if (nextdir == 0) {
 			TIFFErrorExt(tif->tif_clientdata, module, "Directory %"PRIu16" does not exist", dirn);
 			return (0);
 		}
-		if (!TIFFAdvanceDirectory(tif, &nextdir, &off))
+		if (!TIFFAdvanceDirectory(tif, &nextdir, &off, &nextdirnum))
 			return (0);
 	}
 	/*
 	 * Advance to the directory to be unlinked and fetch
 	 * the offset of the directory that follows.
 	 */
-	if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
+	if (!TIFFAdvanceDirectory(tif, &nextdir, NULL, &nextdirnum))
 		return (0);
 	/*
 	 * Go back and patch the link field of the preceding
diff --git a/libtiff/tif_dir.h b/libtiff/tif_dir.h
index 09065648..2279d815 100644
--- a/libtiff/tif_dir.h
+++ b/libtiff/tif_dir.h
@@ -300,6 +300,8 @@ extern int _TIFFMergeFields(TIFF*, const TIFFField[], uint32_t);
 extern const TIFFField* _TIFFFindOrRegisterField(TIFF *, uint32_t, TIFFDataType);
 extern  TIFFField* _TIFFCreateAnonField(TIFF *, uint32_t, TIFFDataType);
 extern int _TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag);
+extern int _TIFFCheckDirNumberAndOffset(TIFF *tif, uint16_t dirn, uint64_t diroff);
+extern int _TIFFGetDirNumberFromOffset(TIFF *tif, uint64_t diroff, uint16_t *dirn);
 
 #if defined(__cplusplus)
 }
diff --git a/libtiff/tif_dirread.c b/libtiff/tif_dirread.c
index 7a12d9c5..457508b9 100644
--- a/libtiff/tif_dirread.c
+++ b/libtiff/tif_dirread.c
@@ -156,7 +156,6 @@ static void TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16_t tagid, uint32_t*
 
 static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount);
 static void MissingRequired(TIFF*, const char*);
-static int TIFFCheckDirOffset(TIFF* tif, uint64_t diroff);
 static int CheckDirCount(TIFF*, TIFFDirEntry*, uint32_t);
 static uint16_t TIFFFetchDirectory(TIFF* tif, uint64_t diroff, TIFFDirEntry** pdir, uint64_t* nextdiroff);
 static int TIFFFetchNormalTag(TIFF*, TIFFDirEntry*, int recover);
@@ -3889,12 +3888,19 @@ TIFFReadDirectory(TIFF* tif)
     int bitspersample_read = FALSE;
         int color_channels;
 
-	tif->tif_diroff=tif->tif_nextdiroff;
-	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
-		return 0;           /* last offset or bad offset (IFD looping) */
-	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
-	tif->tif_curdir++;
-        nextdiroff = tif->tif_nextdiroff;
+	if (tif->tif_nextdiroff == 0) {
+		/* In this special case, tif_diroff needs also to be set to 0. */
+		tif->tif_diroff = tif->tif_nextdiroff;
+		return 0;           /* last offset, thus no checking necessary */
+	}
+
+	nextdiroff = tif->tif_nextdiroff;
+	/* tif_curdir++ and tif_nextdiroff should only be updated after SUCCESSFUL reading of the directory. Otherwise, invalid IFD offsets could corrupt the IFD list. */
+	if (!_TIFFCheckDirNumberAndOffset(tif, tif->tif_curdir + 1, nextdiroff)) {
+		TIFFWarningExt(tif->tif_clientdata, module,
+			"Didn't read next directory due to IFD looping at offset 0x%"PRIx64" (%"PRIu64") to offset 0x%"PRIx64" (%"PRIu64")", tif->tif_diroff, tif->tif_diroff, nextdiroff, nextdiroff);
+		return 0;           /* bad offset (IFD looping) */
+	}
 	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
 	if (!dircount)
 	{
@@ -3902,6 +3908,11 @@ TIFFReadDirectory(TIFF* tif)
 		    "Failed to read directory at offset %" PRIu64, nextdiroff);
 		return 0;
 	}
+	/* Set global values after a valid directory has been fetched.
+	 * tif_diroff is already set to nextdiroff in TIFFFetchDirectory() in the beginning. */
+	tif->tif_curdir++;
+	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
+
 	TIFFReadDirectoryCheckOrder(tif,dir,dircount);
 
         /*
@@ -4995,53 +5006,127 @@ MissingRequired(TIFF* tif, const char* tagname)
 }
 
 /*
- * Check the directory offset against the list of already seen directory
- * offsets. This is a trick to prevent IFD looping. The one can create TIFF
- * file with looped directory pointers. We will maintain a list of already
- * seen directories and check every IFD offset against that list.
+ * Check the directory number and offset against the list of already seen
+ * directory numbers and offsets. This is a trick to prevent IFD looping.
+ * The one can create TIFF file with looped directory pointers. We will
+ * maintain a list of already seen directories and check every IFD offset
+ * and its IFD number against that list. However, the offset of an IFD number
+ * can change - e.g. when writing updates to file.
+ * Returns 1 if all is ok; 0 if last directory or IFD loop is encountered,
+ * or an error has occured.
  */
-static int
-TIFFCheckDirOffset(TIFF* tif, uint64_t diroff)
+int
+_TIFFCheckDirNumberAndOffset(TIFF *tif, uint16_t dirn, uint64_t diroff)
 {
 	uint16_t n;
 
 	if (diroff == 0)			/* no more directories */
 		return 0;
 	if (tif->tif_dirnumber == 65535) {
-	    TIFFErrorExt(tif->tif_clientdata, "TIFFCheckDirOffset",
-			 "Cannot handle more than 65535 TIFF directories");
-	    return 0;
+		TIFFErrorExt(tif->tif_clientdata, "_TIFFCheckDirNumberAndOffset",
+			"Cannot handle more than 65535 TIFF directories");
+		return 0;
 	}
 
-	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {
-		if (tif->tif_dirlist[n] == diroff)
-			return 0;
+	/* Check if offset is already in the list:
+	 * - yes: check, if offset is at the same IFD number - if not, it is an IFD loop
+	 * -  no: add to list or update offset at that IFD number
+	 */
+	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlistdirn && tif->tif_dirlistoff; n++) {
+		if (tif->tif_dirlistoff[n] == diroff) {
+			if (tif->tif_dirlistdirn[n] == dirn) {
+				return 1;
+			} else {
+				TIFFWarningExt(tif->tif_clientdata, "_TIFFCheckDirNumberAndOffset",
+					"TIFF directory %"PRIu16" has IFD looping to directory %"PRIu16" at offset 0x%"PRIx64" (%"PRIu64")",
+					dirn-1, tif->tif_dirlistdirn[n], diroff, diroff);
+				return 0;
+			}
+		}
+	}
+	/* Check if offset of an IFD has been changed and update offset of that IFD number. */
+	if (dirn < tif->tif_dirnumber && tif->tif_dirlistdirn && tif->tif_dirlistoff) {
+		/* tif_dirlistdirn can have IFD numbers dirn in random order */
+		for (n = 0; n < tif->tif_dirnumber; n++) {
+			if (tif->tif_dirlistdirn[n] == dirn) {
+				tif->tif_dirlistoff[n] = diroff;
+				return 1;
+			}
+		}
 	}
 
+	/* Add IFD offset and dirn to IFD directory list */
 	tif->tif_dirnumber++;
 
-	if (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {
-		uint64_t* new_dirlist;
-
+	if (tif->tif_dirlistoff == NULL || tif->tif_dirlistdirn == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {
+		uint64_t *new_dirlist;
 		/*
 		 * XXX: Reduce memory allocation granularity of the dirlist
 		 * array.
 		 */
-		new_dirlist = (uint64_t*)_TIFFCheckRealloc(tif, tif->tif_dirlist,
-                                                   tif->tif_dirnumber, 2 * sizeof(uint64_t), "for IFD list");
+		if (tif->tif_dirnumber >= 32768)
+			tif->tif_dirlistsize = 65535;
+		else
+			tif->tif_dirlistsize = 2 * tif->tif_dirnumber;
+
+		new_dirlist = (uint64_t *)_TIFFCheckRealloc(tif, tif->tif_dirlistoff,
+			tif->tif_dirlistsize, sizeof(uint64_t), "for IFD offset list");
 		if (!new_dirlist)
 			return 0;
-		if( tif->tif_dirnumber >= 32768 )
-		    tif->tif_dirlistsize = 65535;
-		else
-		    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;
-		tif->tif_dirlist = new_dirlist;
+		tif->tif_dirlistoff = new_dirlist;
+		new_dirlist = (uint64_t *)_TIFFCheckRealloc(tif, tif->tif_dirlistdirn,
+			tif->tif_dirlistsize, sizeof(uint16_t), "for IFD dirnumber list");
+		if (!new_dirlist)
+			return 0;
+		tif->tif_dirlistdirn = (uint16_t *)new_dirlist;
 	}
 
-	tif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;
+	tif->tif_dirlistoff[tif->tif_dirnumber - 1] = diroff;
+	tif->tif_dirlistdirn[tif->tif_dirnumber - 1] = dirn;
 
 	return 1;
-}
+}	/* --- _TIFFCheckDirNumberAndOffset() ---*/
+
+/*
+ * Retrieve the matching IFD directory number of a given IFD offset
+ * from the list of directories already seen.
+ * Returns 1 if the offset was in the list and the directory number
+ * can be returned.
+ * Otherwise returns 0 or if an error occured.
+ */
+int
+_TIFFGetDirNumberFromOffset(TIFF *tif, uint64_t diroff, uint16_t* dirn)
+{
+	uint16_t n;
+
+	if (diroff == 0)			/* no more directories */
+		return 0;
+	if (tif->tif_dirnumber == 65535) {
+		TIFFErrorExt(tif->tif_clientdata, "_TIFFGetDirNumberFromOffset",
+			"Cannot handle more than 65535 TIFF directories");
+		return 0;
+	}
+
+	/* Check if offset is already in the list and return matching directory number.
+	 * Otherwise update IFD list using TIFFNumberOfDirectories() 
+	 * and search again in IFD list.
+	 */
+	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlistoff && tif->tif_dirlistdirn; n++) {
+		if (tif->tif_dirlistoff[n] == diroff) {
+			*dirn = tif->tif_dirlistdirn[n];
+			return 1;
+		}
+	}
+	TIFFNumberOfDirectories(tif);
+	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlistoff && tif->tif_dirlistdirn; n++) {
+		if (tif->tif_dirlistoff[n] == diroff) {
+			*dirn = tif->tif_dirlistdirn[n];
+			return 1;
+		}
+	}
+	return 0;
+} /*--- _TIFFGetDirNumberFromOffset() ---*/
+
 
 /*
  * Check the count field of a directory entry against a known value.  The
diff --git a/libtiff/tif_getimage.c b/libtiff/tif_getimage.c
index 4a80280e..a4d0c1d6 100644
--- a/libtiff/tif_getimage.c
+++ b/libtiff/tif_getimage.c
@@ -697,7 +697,8 @@ gtTileContig(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 		this_tw = tw - fromskew;
 		this_toskew = toskew + fromskew;
 	    }
-	    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);
+	    tmsize_t roffset = (tmsize_t) y * w + tocol;
+	    (*put)(img, raster + roffset, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);
 	    tocol += this_tw;
 	    col += this_tw;
 	    /*
@@ -885,7 +886,8 @@ gtTileSeparate(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 				this_tw = tw - fromskew;
 				this_toskew = toskew + fromskew;
 			}
-			(*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, \
+			tmsize_t roffset = (tmsize_t) y * w + tocol;
+			(*put)(img, raster + roffset, tocol, y, this_tw, nrow, fromskew, this_toskew, \
 				p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));
 			tocol += this_tw;
 			col += this_tw;
@@ -995,7 +997,8 @@ gtStripContig(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 
 		pos = ((row + img->row_offset) % rowsperstrip) * scanline + \
 			((tmsize_t) img->col_offset * img->samplesperpixel);
-		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);
+		tmsize_t roffset = (tmsize_t) y * w;
+		(*put)(img, raster + roffset, 0, y, w, nrow, fromskew, toskew, buf + pos);
 		y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
 	}
 
@@ -1153,7 +1156,8 @@ gtStripSeparate(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 
 		pos = ((row + img->row_offset) % rowsperstrip) * scanline + \
 			((tmsize_t) img->col_offset * img->samplesperpixel);
-		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,
+		tmsize_t roffset = (tmsize_t) y * w;
+		(*put)(img, raster + roffset, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,
 		    p2 + pos, (alpha?(pa+pos):NULL));
 		y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
 	}
diff --git a/libtiff/tif_lzw.c b/libtiff/tif_lzw.c
index 8c3205f8..aab7ed50 100644
--- a/libtiff/tif_lzw.c
+++ b/libtiff/tif_lzw.c
@@ -141,7 +141,7 @@ typedef struct {
 	code_t* dec_free_entp;		/* next free entry */
 	code_t* dec_maxcodep;		/* max available entry */
 	code_t* dec_codetab;		/* kept separate for small machines */
-	int     read_error;         /* whether a read error has occured, and which should cause further reads in the same strip/tile to be aborted */
+	int     read_error;         /* whether a read error has occurred, and which should cause further reads in the same strip/tile to be aborted */
 
 	/* Encoding specific data */
 	int     enc_oldcode;		/* last code encountered */
diff --git a/libtiff/tif_open.c b/libtiff/tif_open.c
index 549f56ce..85c2af47 100644
--- a/libtiff/tif_open.c
+++ b/libtiff/tif_open.c
@@ -354,7 +354,8 @@ TIFFClientOpen(
 			goto bad;
 		tif->tif_diroff = 0;
 		tif->tif_lastdiroff = 0;
-		tif->tif_dirlist = NULL;
+		tif->tif_dirlistoff = NULL;
+		tif->tif_dirlistdirn = NULL;
 		tif->tif_dirlistsize = 0;
 		tif->tif_dirnumber = 0;
 		return (tif);
diff --git a/libtiff/tif_zstd.c b/libtiff/tif_zstd.c
index 960aa90a..263c17ca 100644
--- a/libtiff/tif_zstd.c
+++ b/libtiff/tif_zstd.c
@@ -160,7 +160,7 @@ ZSTDDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
                 TIFFErrorExt(tif->tif_clientdata, module,
                     "Not enough data at scanline %lu (short %lu bytes)",
                     (unsigned long) tif->tif_row,
-                    (unsigned long) (size_t)occ - out_buffer.pos);
+                    (unsigned long) ((size_t)occ - out_buffer.pos));
                 return 0;
         }
 
diff --git a/libtiff/tiffiop.h b/libtiff/tiffiop.h
index b4429f45..9f603a24 100644
--- a/libtiff/tiffiop.h
+++ b/libtiff/tiffiop.h
@@ -118,7 +118,8 @@ struct tiff {
 	uint64_t               tif_diroff;       /* file offset of current directory */
 	uint64_t               tif_nextdiroff;   /* file offset of following directory */
 	uint64_t               tif_lastdiroff;   /* file offset of last directory written so far */
-	uint64_t*              tif_dirlist;      /* list of offsets to already seen directories to prevent IFD looping */
+	uint64_t*              tif_dirlistoff;   /* list of offsets to already seen directories to prevent IFD looping */
+	uint16_t*              tif_dirlistdirn;  /* list of directory numbers to already seen directories to prevent IFD looping */
 	uint16_t               tif_dirlistsize;  /* number of entries in offset list */
 	uint16_t               tif_dirnumber;    /* number of already seen directories */
 	TIFFDirectory        tif_dir;          /* internal rep of current directory */
diff --git a/port/CMakeLists.txt b/port/CMakeLists.txt
index fd459162..04bd3ea8 100755
--- a/port/CMakeLists.txt
+++ b/port/CMakeLists.txt
@@ -31,21 +31,21 @@ set(port_HEADERS libport.h)
 
 # Only build if any needed features are missing
 if(NOT HAVE_GETOPT)
-  add_library(port STATIC ../placeholder.h)
+  add_library(tiff_port STATIC ../placeholder.h)
 
   # Add getopt if missing
   if(NOT HAVE_GETOPT)
-    target_sources(port PUBLIC
+    target_sources(tiff_port PUBLIC
             ${CMAKE_CURRENT_SOURCE_DIR}/getopt.c)
   endif()
 
-  target_include_directories(port PUBLIC
+  target_include_directories(tiff_port PUBLIC
           ${CMAKE_CURRENT_BINARY_DIR}
           ${CMAKE_CURRENT_SOURCE_DIR})
 else()
   # Dummy interface library
-  add_library(port INTERFACE)
-  target_include_directories(port INTERFACE
+  add_library(tiff_port INTERFACE)
+  target_include_directories(tiff_port INTERFACE
           ${CMAKE_CURRENT_BINARY_DIR}
           ${CMAKE_CURRENT_SOURCE_DIR})
 endif()
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 66de9376..3554b214 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -102,77 +102,77 @@ set(simple_tests)
 
 add_executable(test_signed_tags ../placeholder.h)
 target_sources(test_signed_tags PRIVATE test_signed_tags.c)
-target_link_libraries(test_signed_tags PRIVATE tiff port)
+target_link_libraries(test_signed_tags PRIVATE tiff tiff_port)
 list(APPEND simple_tests test_signed_tags)
 
 add_executable(ascii_tag ../placeholder.h)
 target_sources(ascii_tag PRIVATE ascii_tag.c)
-target_link_libraries(ascii_tag PRIVATE tiff port)
+target_link_libraries(ascii_tag PRIVATE tiff tiff_port)
 list(APPEND simple_tests ascii_tag)
 
 add_executable(long_tag ../placeholder.h)
 target_sources(long_tag PRIVATE long_tag.c check_tag.c)
-target_link_libraries(long_tag PRIVATE tiff port)
+target_link_libraries(long_tag PRIVATE tiff tiff_port)
 list(APPEND simple_tests long_tag)
 
 add_executable(short_tag ../placeholder.h)
 target_sources(short_tag PRIVATE short_tag.c check_tag.c)
-target_link_libraries(short_tag PRIVATE tiff port)
+target_link_libraries(short_tag PRIVATE tiff tiff_port)
 list(APPEND simple_tests short_tag)
 
 add_executable(strip_rw ../placeholder.h)
 target_sources(strip_rw PRIVATE strip_rw.c strip.c test_arrays.c test_arrays.h)
-target_link_libraries(strip_rw PRIVATE tiff port)
+target_link_libraries(strip_rw PRIVATE tiff tiff_port)
 list(APPEND simple_tests strip_rw)
 
 add_executable(rewrite ../placeholder.h)
 target_sources(rewrite PRIVATE rewrite_tag.c)
-target_link_libraries(rewrite PRIVATE tiff port)
+target_link_libraries(rewrite PRIVATE tiff tiff_port)
 list(APPEND simple_tests rewrite)
 
 if(JPEG_SUPPORT)
   add_executable(raw_decode ../placeholder.h)
   target_sources(raw_decode PRIVATE raw_decode.c)
-  target_link_libraries(raw_decode PRIVATE tiff port JPEG::JPEG)
+  target_link_libraries(raw_decode PRIVATE tiff tiff_port JPEG::JPEG)
   list(APPEND simple_tests raw_decode)
 endif()
 
 add_executable(custom_dir ../placeholder.h)
 target_sources(custom_dir PRIVATE custom_dir.c)
-target_link_libraries(custom_dir PRIVATE tiff port)
+target_link_libraries(custom_dir PRIVATE tiff tiff_port)
 list(APPEND simple_tests custom_dir)
 
 # Uses private functions from static library
 if(NOT BUILD_SHARED_LIBS)
   add_executable(rational_precision2double ../placeholder.h)
   target_sources(rational_precision2double PRIVATE rational_precision2double.c)
-  target_link_libraries(rational_precision2double PRIVATE tiff port)
+  target_link_libraries(rational_precision2double PRIVATE tiff tiff_port)
   list(APPEND simple_tests rational_precision2double)
 endif()
 
 add_executable(custom_dir_EXIF_231 ../placeholder.h)
 target_sources(custom_dir_EXIF_231 PRIVATE custom_dir_EXIF_231.c)
-target_link_libraries(custom_dir_EXIF_231 PRIVATE tiff port)
+target_link_libraries(custom_dir_EXIF_231 PRIVATE tiff tiff_port)
 list(APPEND simple_tests custom_dir_EXIF_231)
 
 add_executable(defer_strile_loading ../placeholder.h)
 target_sources(defer_strile_loading PRIVATE defer_strile_loading.c)
-target_link_libraries(defer_strile_loading PRIVATE tiff port)
+target_link_libraries(defer_strile_loading PRIVATE tiff tiff_port)
 list(APPEND simple_tests defer_strile_loading)
 
 add_executable(defer_strile_writing ../placeholder.h)
 target_sources(defer_strile_writing PRIVATE defer_strile_writing.c)
-target_link_libraries(defer_strile_writing PRIVATE tiff port)
+target_link_libraries(defer_strile_writing PRIVATE tiff tiff_port)
 list(APPEND simple_tests defer_strile_writing)
 
 add_executable(test_directory ../placeholder.h)
 target_sources(test_directory PRIVATE test_directory.c)
-target_link_libraries(test_directory PRIVATE tiff port)
+target_link_libraries(test_directory PRIVATE tiff tiff_port)
 list(APPEND simple_tests test_directory)
 
 add_executable(testtypes ../placeholder.h)
 target_sources(testtypes PRIVATE testtypes.c)
-target_link_libraries(testtypes PRIVATE tiff port)
+target_link_libraries(testtypes PRIVATE tiff tiff_port)
 list(APPEND simple_tests testtypes)
 
 if(WEBP_SUPPORT AND EMSCRIPTEN)
@@ -372,6 +372,7 @@ add_reader_test(tiffdump "" "images/miniswhite-1c-1b.tiff")
 # tiffinfo
 add_reader_test(tiffinfo "-c -D -d -j -s" "images/custom_dir_EXIF_GPS.tiff")
 add_reader_test(tiffinfo "-c -D -d -j -s" "images/minisblack-1c-16b.tiff")
+add_reader_test(tiffinfo " " "images/tiff_with_subifd_chain.tif")
 
 # tiffcp split/join
 foreach(image ${UNCOMPRESSEDIMAGES})
diff --git a/test/Makefile.am b/test/Makefile.am
index 2da13dbf..09a83065 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -209,6 +209,7 @@ IMAGES_EXTRA_DIST = \
 	images/miniswhite-1c-1b.g3 \
 	images/test_float64_predictor2_le_lzw.tif \
 	images/test_float64_predictor2_be_lzw.tif \
+	images/tiff_with_subifd_chain.tif \
 	$(PNMIMAGES) \
 	$(TIFFIMAGES)
 
diff --git a/test/common.sh b/test/common.sh
index 0219ab3a..3d8e6533 100644
--- a/test/common.sh
+++ b/test/common.sh
@@ -48,6 +48,7 @@ IMG_MINISWHITE_1C_1B_PBM=${IMAGES}/miniswhite-1c-1b.pbm
 IMG_MINISBLACK_1C_8B_PGM=${IMAGES}/minisblack-1c-8b.pgm
 IMG_RGB_3C_16B_PPM=${IMAGES}/rgb-3c-16b.ppm
 IMG_RGB_3C_8B_PPM=${IMAGES}/rgb-3c-8b.ppm
+IMG_TIFF_WITH_SUBIFD_CHAIN=${IMAGES}/tiff_with_subifd_chain.tif
 
 # All uncompressed image files
 IMG_UNCOMPRESSED="${IMG_MINISBLACK_1C_16B} ${IMG_MINISBLACK_1C_8B} ${IMG_MINISWHITE_1C_1B} ${IMG_PALETTE_1C_1B} ${IMG_PALETTE_1C_4B} ${IMG_PALETTE_1C_4B} ${IMG_PALETTE_1C_8B} ${IMG_RGB_3C_8B} ${IMG_RGB_3C_16B}"
diff --git a/test/images/tiff_with_subifd_chain.tif b/test/images/tiff_with_subifd_chain.tif
new file mode 100644
index 00000000..7acbba18
Binary files /dev/null and b/test/images/tiff_with_subifd_chain.tif differ
diff --git a/test/rational_precision2double.c b/test/rational_precision2double.c
index df01e5a3..8312ef9b 100644
--- a/test/rational_precision2double.c
+++ b/test/rational_precision2double.c
@@ -528,7 +528,7 @@ write_test_tiff(TIFF* tif, const char* filenameRead, int blnAllCustomTags) {
 			tFieldName = tFieldArray->fields[i].field_name;
 			pVoid = NULL;
 
-			if (tType == TIFF_RATIONAL && tFieldBit == FIELD_CUSTOM) {
+			if ((tType == TIFF_RATIONAL || tType == TIFF_SRATIONAL) && tFieldBit == FIELD_CUSTOM) {
 				/*-- dependent on set_field_type write value --*/
 				switch (tSetFieldType) {
 					case TIFF_SETGET_FLOAT:
@@ -818,7 +818,7 @@ write_test_tiff(TIFF* tif, const char* filenameRead, int blnAllCustomTags) {
 			pVoid = NULL;
 			auxDblUnion.dbl = 0;
 
-			if (tType == TIFF_RATIONAL && tFieldBit == FIELD_CUSTOM) {
+			if ((tType == TIFF_RATIONAL || tType == TIFF_SRATIONAL) && tFieldBit == FIELD_CUSTOM) {
 				/*-- dependent on set_field_type read value --*/
 				switch (tSetFieldType) {
 					case TIFF_SETGET_FLOAT:
diff --git a/test/tiffinfo.sh b/test/tiffinfo.sh
index cb572483..9764bd51 100755
--- a/test/tiffinfo.sh
+++ b/test/tiffinfo.sh
@@ -4,3 +4,4 @@
 #
 . ${srcdir:-.}/common.sh
 f_test_reader "${TIFFINFO} -c -D -d -j -s " "${IMG_MINISBLACK_1C_16B}"
+f_test_reader "${TIFFINFO}  " "${IMG_TIFF_WITH_SUBIFD_CHAIN}"
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index e0feaebe..2d203763 100755
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -24,83 +24,83 @@
 
 add_executable(fax2ps ../placeholder.h)
 target_sources(fax2ps PRIVATE fax2ps.c)
-target_link_libraries(fax2ps PRIVATE tiff port)
+target_link_libraries(fax2ps PRIVATE tiff tiff_port)
 
 add_executable(fax2tiff ../placeholder.h)
 target_sources(fax2tiff PRIVATE fax2tiff.c)
-target_link_libraries(fax2tiff PRIVATE tiff port)
+target_link_libraries(fax2tiff PRIVATE tiff tiff_port)
 
 add_executable(pal2rgb ../placeholder.h)
 target_sources(pal2rgb PRIVATE pal2rgb.c)
-target_link_libraries(pal2rgb PRIVATE tiff port)
+target_link_libraries(pal2rgb PRIVATE tiff tiff_port)
 
 add_executable(ppm2tiff ../placeholder.h)
 target_sources(ppm2tiff PRIVATE ppm2tiff.c)
-target_link_libraries(ppm2tiff PRIVATE tiff port)
+target_link_libraries(ppm2tiff PRIVATE tiff tiff_port)
 
 add_executable(raw2tiff ../placeholder.h)
 target_sources(raw2tiff PRIVATE raw2tiff.c)
-target_link_libraries(raw2tiff PRIVATE tiff port CMath::CMath)
+target_link_libraries(raw2tiff PRIVATE tiff tiff_port CMath::CMath)
 
 add_executable(rgb2ycbcr ../placeholder.h)
 target_sources(rgb2ycbcr PRIVATE rgb2ycbcr.c)
-target_link_libraries(rgb2ycbcr PRIVATE tiff port)
+target_link_libraries(rgb2ycbcr PRIVATE tiff tiff_port)
 
 add_executable(thumbnail ../placeholder.h)
 target_sources(thumbnail PRIVATE thumbnail.c)
-target_link_libraries(thumbnail PRIVATE tiff port CMath::CMath)
+target_link_libraries(thumbnail PRIVATE tiff tiff_port CMath::CMath)
 
 add_executable(tiff2bw ../placeholder.h)
 target_sources(tiff2bw PRIVATE tiff2bw.c)
-target_link_libraries(tiff2bw PRIVATE tiff port)
+target_link_libraries(tiff2bw PRIVATE tiff tiff_port)
 
 add_executable(tiff2pdf ../placeholder.h)
 target_sources(tiff2pdf PRIVATE tiff2pdf.c)
-target_link_libraries(tiff2pdf PRIVATE tiff port)
+target_link_libraries(tiff2pdf PRIVATE tiff tiff_port)
 
 add_executable(tiff2ps ../placeholder.h)
 target_sources(tiff2ps PRIVATE tiff2ps.c)
-target_link_libraries(tiff2ps PRIVATE tiff port CMath::CMath)
+target_link_libraries(tiff2ps PRIVATE tiff tiff_port CMath::CMath)
 
 add_executable(tiff2rgba ../placeholder.h)
 target_sources(tiff2rgba PRIVATE tiff2rgba.c)
-target_link_libraries(tiff2rgba PRIVATE tiff port)
+target_link_libraries(tiff2rgba PRIVATE tiff tiff_port)
 
 add_executable(tiffcmp ../placeholder.h)
 target_sources(tiffcmp PRIVATE tiffcmp.c)
-target_link_libraries(tiffcmp PRIVATE tiff port)
+target_link_libraries(tiffcmp PRIVATE tiff tiff_port)
 
 add_executable(tiffcp ../placeholder.h)
 target_sources(tiffcp PRIVATE tiffcp.c)
-target_link_libraries(tiffcp PRIVATE tiff port)
+target_link_libraries(tiffcp PRIVATE tiff tiff_port)
 
 add_executable(tiffcrop ../placeholder.h)
 target_sources(tiffcrop PRIVATE tiffcrop.c)
-target_link_libraries(tiffcrop PRIVATE tiff port CMath::CMath)
+target_link_libraries(tiffcrop PRIVATE tiff tiff_port CMath::CMath)
 
 add_executable(tiffdither ../placeholder.h)
 target_sources(tiffdither PRIVATE tiffdither.c)
-target_link_libraries(tiffdither PRIVATE tiff port)
+target_link_libraries(tiffdither PRIVATE tiff tiff_port)
 
 add_executable(tiffdump ../placeholder.h)
 target_sources(tiffdump PRIVATE tiffdump.c)
-target_link_libraries(tiffdump PRIVATE tiff port)
+target_link_libraries(tiffdump PRIVATE tiff tiff_port)
 
 add_executable(tiffinfo ../placeholder.h)
 target_sources(tiffinfo PRIVATE tiffinfo.c)
-target_link_libraries(tiffinfo PRIVATE tiff port)
+target_link_libraries(tiffinfo PRIVATE tiff tiff_port)
 
 add_executable(tiffmedian ../placeholder.h)
 target_sources(tiffmedian PRIVATE tiffmedian.c)
-target_link_libraries(tiffmedian PRIVATE tiff port)
+target_link_libraries(tiffmedian PRIVATE tiff tiff_port)
 
 add_executable(tiffset ../placeholder.h)
 target_sources(tiffset PRIVATE tiffset.c)
-target_link_libraries(tiffset PRIVATE tiff port)
+target_link_libraries(tiffset PRIVATE tiff tiff_port)
 
 add_executable(tiffsplit ../placeholder.h)
 target_sources(tiffsplit PRIVATE tiffsplit.c)
-target_link_libraries(tiffsplit PRIVATE tiff port)
+target_link_libraries(tiffsplit PRIVATE tiff tiff_port)
 
 # rgb2ycbcr and thumbnail are intended to *NOT* be installed. They are for
 # testing purposes only.
@@ -127,7 +127,7 @@ install(TARGETS fax2ps
 if(OPENGL_SUPPORT)
   add_executable(tiffgt ../placeholder.h)
   target_sources(tiffgt PRIVATE tiffgt.c)
-  target_link_libraries(tiffgt PRIVATE tiff port)
+  target_link_libraries(tiffgt PRIVATE tiff tiff_port)
   target_link_libraries(tiffgt PRIVATE OpenGL::GL GLUT::GLUT)
 
   install(TARGETS tiffgt
diff --git a/tools/tiffinfo.c b/tools/tiffinfo.c
index 36bd9520..c3d79eb7 100644
--- a/tools/tiffinfo.c
+++ b/tools/tiffinfo.c
@@ -151,7 +151,7 @@ main(int argc, char* argv[])
 	multiplefiles = (argc - optind > 1);
 	for (; optind < argc; optind++) {
 		if (multiplefiles)
-			printf("%s:\n", argv[optind]);
+			printf("File %s:\n", argv[optind]);
 		tif = TIFFOpen(argv[optind], chopstrips ? "rC" : "rc");
 		if (tif != NULL) {
 			if (dirnum != -1) {
@@ -168,6 +168,7 @@ main(int argc, char* argv[])
 					tiffinfo(tif, order, flags, 1);
 					if (TIFFGetField(tif, TIFFTAG_EXIFIFD,
 						&offset)) {
+						printf("--- EXIF directory within directory %d \n", curdir);
 						if (TIFFReadEXIFDirectory(tif, offset)) {
 							tiffinfo(tif, order, flags, 0);
 							/*-- Go back to previous directory, (directory is reloaded from file!) */
@@ -176,11 +177,43 @@ main(int argc, char* argv[])
 					}
 					if (TIFFGetField(tif, TIFFTAG_GPSIFD,
 						&offset)) {
+						printf("--- GPS directory within directory %d \n", curdir);
 						if (TIFFReadGPSDirectory(tif, offset)) {
 							tiffinfo(tif, order, flags, 0);
 							TIFFSetDirectory(tif, curdir);
 						}
 					}
+					/*-- Check for SubIFDs --*/
+					uint16_t nCount;
+					void *vPtr;
+					uint64_t *subIFDoffsets = NULL;
+					if (TIFFGetField(tif, TIFFTAG_SUBIFD, &nCount, &vPtr)) {
+						if (nCount > 0) {
+							subIFDoffsets = malloc(nCount * sizeof(uint64_t));
+							if (subIFDoffsets != NULL) {
+								memcpy(subIFDoffsets, vPtr, nCount * sizeof(subIFDoffsets[0]));
+								printf("--- SubIFD image descriptor tag within TIFF directory %d with array of %d SubIFD chains ---\n", curdir, nCount);
+								for (int i = 0; i < nCount; i++) {
+									offset = subIFDoffsets[i];
+									int s = 0;
+									if (TIFFSetSubDirectory(tif, offset)) {
+										/* print info and check for SubIFD chain */
+										do {
+											printf("--- SubIFD %d of chain %d at offset 0x%"PRIx64" (%"PRIu64"):\n", s, i, offset, offset);
+											tiffinfo(tif, order, flags, 0);
+											s++;
+										} while (TIFFReadDirectory(tif));
+									}
+								}
+								TIFFSetDirectory(tif, curdir);
+								free(subIFDoffsets);
+								subIFDoffsets = NULL;
+							} else {
+								fprintf(stderr, "Error: Could not allocate memory for SubIFDs list. SubIFDs not parsed.\n");
+							}
+						}
+					}
+					printf("\n");
 				} while (TIFFReadDirectory(tif));
 			}
 			TIFFClose(tif);
