commit a7ec7a4193a2eb3b5341243fc0b621c1ac9e4ec4
Author: Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
Date:   Thu Aug 23 17:00:25 2018 -0700

    hfsplus: fix NULL dereference in hfsplus_lookup()
    
    An HFS+ filesystem can be mounted read-only without having a metadata
    directory, which is needed to support hardlinks.  But if the catalog
    data is corrupted, a directory lookup may still find dentries claiming
    to be hardlinks.
    
    hfsplus_lookup() does check that ->hidden_dir is not NULL in such a
    situation, but mistakenly does so after dereferencing it for the first
    time.  Reorder this check to prevent a crash.
    
    This happens when looking up corrupted catalog data (dentry) on a
    filesystem with no metadata directory (this could only ever happen on a
    read-only mount).  Wen Xu sent the replication steps in detail to the
    fsdevel list: https://bugzilla.kernel.org/show_bug.cgi?id=200297
    
    Link: http://lkml.kernel.org/r/20180712215344.q44dyrhymm4ajkao@eaf
    Signed-off-by: Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
    Reported-by: Wen Xu <wen.xu@gatech.edu>
    Cc: Viacheslav Dubeyko <slava@dubeyko.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/hfsplus/dir.c b/fs/hfsplus/dir.c
index c5a70f8..f376626 100644
--- a/fs/hfsplus/dir.c
+++ b/fs/hfsplus/dir.c
@@ -77,13 +77,13 @@ static struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,
 				cpu_to_be32(HFSP_HARDLINK_TYPE) &&
 				entry.file.user_info.fdCreator ==
 				cpu_to_be32(HFSP_HFSPLUS_CREATOR) &&
+				HFSPLUS_SB(sb)->hidden_dir &&
 				(entry.file.create_date ==
 					HFSPLUS_I(HFSPLUS_SB(sb)->hidden_dir)->
 						create_date ||
 				entry.file.create_date ==
 					HFSPLUS_I(d_inode(sb->s_root))->
-						create_date) &&
-				HFSPLUS_SB(sb)->hidden_dir) {
+						create_date)) {
 			struct qstr str;
 			char name[32];
 
