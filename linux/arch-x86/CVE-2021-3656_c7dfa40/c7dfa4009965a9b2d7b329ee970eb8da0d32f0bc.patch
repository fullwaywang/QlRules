commit c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc
Author: Maxim Levitsky <mlevitsk@redhat.com>
Date:   Mon Jul 19 16:05:00 2021 +0300

    KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)
    
    If L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable
    Virtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),
    then VMLOAD/VMSAVE must operate on the L1 physical memory, which is only
    possible by making L0 intercept these instructions.
    
    Failure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,
    and thus read/write portions of the host physical memory.
    
    Fixes: 89c8a4984fc9 ("KVM: SVM: Enable Virtual VMLOAD VMSAVE feature")
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/svm/nested.c b/arch/x86/kvm/svm/nested.c
index 28381ca5221c..e5515477c30a 100644
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@ -158,6 +158,9 @@ void recalc_intercepts(struct vcpu_svm *svm)
 	/* If SMI is not intercepted, ignore guest SMI intercept as well  */
 	if (!intercept_smi)
 		vmcb_clr_intercept(c, INTERCEPT_SMI);
+
+	vmcb_set_intercept(c, INTERCEPT_VMLOAD);
+	vmcb_set_intercept(c, INTERCEPT_VMSAVE);
 }
 
 static void copy_vmcb_control_area(struct vmcb_control_area *dst,
