commit a0c69c492f4a8fad52f0a97565241c926160c9a4
Author: Ronald Wahl <ronald.wahl@raritan.com>
Date:   Sat Jul 6 12:13:37 2024 +0200

    net: ks8851: Fix deadlock with the SPI chip variant
    
    commit 0913ec336a6c0c4a2b296bd9f74f8e41c4c83c8c upstream.
    
    When SMP is enabled and spinlocks are actually functional then there is
    a deadlock with the 'statelock' spinlock between ks8851_start_xmit_spi
    and ks8851_irq:
    
        watchdog: BUG: soft lockup - CPU#0 stuck for 27s!
        call trace:
          queued_spin_lock_slowpath+0x100/0x284
          do_raw_spin_lock+0x34/0x44
          ks8851_start_xmit_spi+0x30/0xb8
          ks8851_start_xmit+0x14/0x20
          netdev_start_xmit+0x40/0x6c
          dev_hard_start_xmit+0x6c/0xbc
          sch_direct_xmit+0xa4/0x22c
          __qdisc_run+0x138/0x3fc
          qdisc_run+0x24/0x3c
          net_tx_action+0xf8/0x130
          handle_softirqs+0x1ac/0x1f0
          __do_softirq+0x14/0x20
          ____do_softirq+0x10/0x1c
          call_on_irq_stack+0x3c/0x58
          do_softirq_own_stack+0x1c/0x28
          __irq_exit_rcu+0x54/0x9c
          irq_exit_rcu+0x10/0x1c
          el1_interrupt+0x38/0x50
          el1h_64_irq_handler+0x18/0x24
          el1h_64_irq+0x64/0x68
          __netif_schedule+0x6c/0x80
          netif_tx_wake_queue+0x38/0x48
          ks8851_irq+0xb8/0x2c8
          irq_thread_fn+0x2c/0x74
          irq_thread+0x10c/0x1b0
          kthread+0xc8/0xd8
          ret_from_fork+0x10/0x20
    
    This issue has not been identified earlier because tests were done on
    a device with SMP disabled and so spinlocks were actually NOPs.
    
    Now use spin_(un)lock_bh for TX queue related locking to avoid execution
    of softirq work synchronously that would lead to a deadlock.
    
    Fixes: 3dc5d4454545 ("net: ks8851: Fix TX stall caused by TX buffer overrun")
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Paolo Abeni <pabeni@redhat.com>
    Cc: Simon Horman <horms@kernel.org>
    Cc: netdev@vger.kernel.org
    Cc: stable@vger.kernel.org # 5.10+
    Signed-off-by: Ronald Wahl <ronald.wahl@raritan.com>
    Reviewed-by: Simon Horman <horms@kernel.org>
    Link: https://patch.msgid.link/20240706101337.854474-1-rwahl@gmx.de
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/micrel/ks8851_common.c b/drivers/net/ethernet/micrel/ks8851_common.c
index 6453c92f0fa7..13462811eaae 100644
--- a/drivers/net/ethernet/micrel/ks8851_common.c
+++ b/drivers/net/ethernet/micrel/ks8851_common.c
@@ -352,11 +352,11 @@ static irqreturn_t ks8851_irq(int irq, void *_ks)
 		netif_dbg(ks, intr, ks->netdev,
 			  "%s: txspace %d\n", __func__, tx_space);
 
-		spin_lock(&ks->statelock);
+		spin_lock_bh(&ks->statelock);
 		ks->tx_space = tx_space;
 		if (netif_queue_stopped(ks->netdev))
 			netif_wake_queue(ks->netdev);
-		spin_unlock(&ks->statelock);
+		spin_unlock_bh(&ks->statelock);
 	}
 
 	if (status & IRQ_SPIBEI) {
@@ -635,14 +635,14 @@ static void ks8851_set_rx_mode(struct net_device *dev)
 
 	/* schedule work to do the actual set of the data if needed */
 
-	spin_lock(&ks->statelock);
+	spin_lock_bh(&ks->statelock);
 
 	if (memcmp(&rxctrl, &ks->rxctrl, sizeof(rxctrl)) != 0) {
 		memcpy(&ks->rxctrl, &rxctrl, sizeof(ks->rxctrl));
 		schedule_work(&ks->rxctrl_work);
 	}
 
-	spin_unlock(&ks->statelock);
+	spin_unlock_bh(&ks->statelock);
 }
 
 static int ks8851_set_mac_address(struct net_device *dev, void *addr)
diff --git a/drivers/net/ethernet/micrel/ks8851_spi.c b/drivers/net/ethernet/micrel/ks8851_spi.c
index 4dcbff789b19..e33a5e7beb39 100644
--- a/drivers/net/ethernet/micrel/ks8851_spi.c
+++ b/drivers/net/ethernet/micrel/ks8851_spi.c
@@ -340,10 +340,10 @@ static void ks8851_tx_work(struct work_struct *work)
 
 	tx_space = ks8851_rdreg16_spi(ks, KS_TXMIR);
 
-	spin_lock(&ks->statelock);
+	spin_lock_bh(&ks->statelock);
 	ks->queued_len -= dequeued_len;
 	ks->tx_space = tx_space;
-	spin_unlock(&ks->statelock);
+	spin_unlock_bh(&ks->statelock);
 
 	ks8851_unlock_spi(ks, &flags);
 }
