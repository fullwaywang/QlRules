commit 6366e8f776a0fa0dd476d37b108eecdf42b950f3 (from 33aee1275d9d1384791d2206776eb8152d397f00)	6366e8f776a0fa0dd476d37b108eecdf42b950f3
Merge: 33aee127 688012dc
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Sun Feb 5 16:04:07 2023 +0000

    Merge branch 'tiffcrop_correctly_update_buffersize_after_rotate_fix#520' into 'master'
    
    tiffcrop correctly update buffersize after rotateImage() fix#520
    
    Closes #520
    
    See merge request libtiff/libtiff!467

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 480b927c..ebea7475 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -577,7 +577,7 @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,
 static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,
                                      uint32_t, uint32_t, uint8_t *, uint8_t *);
 static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t *,
-                       unsigned char **);
+                       unsigned char **, size_t *);
 static int mirrorImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
                        unsigned char *);
 static int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
@@ -7268,7 +7268,7 @@ static int correct_orientation(struct image_data *image,
         }
 
         if (rotateImage(rotation, image, &image->width, &image->length,
-                        work_buff_ptr))
+                        work_buff_ptr, NULL))
         {
             TIFFError("correct_orientation", "Unable to rotate image");
             return (-1);
@@ -8630,8 +8630,12 @@ static int processCropSelections(struct image_data *image,
         if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can
                                               reallocate the buffer */
         {
+            /* rotateImage() set up a new buffer and calculates its size
+             * individually. Therefore, seg_buffs size  needs to be updated
+             * accordingly. */
+            size_t rot_buf_size = 0;
             if (rotateImage(crop->rotation, image, &crop->combined_width,
-                            &crop->combined_length, &crop_buff))
+                            &crop->combined_length, &crop_buff, &rot_buf_size))
             {
                 TIFFError("processCropSelections",
                           "Failed to rotate composite regions by %" PRIu32
@@ -8640,9 +8644,7 @@ static int processCropSelections(struct image_data *image,
                 return (-1);
             }
             seg_buffs[0].buffer = crop_buff;
-            seg_buffs[0].size =
-                (((crop->combined_width * image->bps + 7) / 8) * image->spp) *
-                crop->combined_length;
+            seg_buffs[0].size = rot_buf_size;
         }
     }
     else /* Separated Images */
@@ -8753,10 +8755,13 @@ static int processCropSelections(struct image_data *image,
                  * ->yres, what it schouldn't do here, when more than one
                  * section is processed. ToDo: Therefore rotateImage() and its
                  * usage has to be reworked (e.g. like mirrorImage()) !!
-                 */
-                if (rotateImage(crop->rotation, image,
-                                &crop->regionlist[i].width,
-                                &crop->regionlist[i].length, &crop_buff))
+                 * Furthermore, rotateImage() set up a new buffer and calculates
+                 * its size individually. Therefore, seg_buffs size  needs to be
+                 * updated accordingly. */
+                size_t rot_buf_size = 0;
+                if (rotateImage(
+                        crop->rotation, image, &crop->regionlist[i].width,
+                        &crop->regionlist[i].length, &crop_buff, &rot_buf_size))
                 {
                     TIFFError("processCropSelections",
                               "Failed to rotate crop region by %" PRIu16
@@ -8769,10 +8774,7 @@ static int processCropSelections(struct image_data *image,
                 crop->combined_width = total_width;
                 crop->combined_length = total_length;
                 seg_buffs[i].buffer = crop_buff;
-                seg_buffs[i].size =
-                    (((crop->regionlist[i].width * image->bps + 7) / 8) *
-                     image->spp) *
-                    crop->regionlist[i].length;
+                seg_buffs[i].size = rot_buf_size;
             }
         } /* for crop->selections loop */
     }     /* Separated Images (else case) */
@@ -8903,7 +8905,7 @@ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,
         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
         if (rotateImage(crop->rotation, image, &crop->combined_width,
-                        &crop->combined_length, crop_buff_ptr))
+                        &crop->combined_length, crop_buff_ptr, NULL))
         {
             TIFFError("createCroppedImage",
                       "Failed to rotate image or cropped selection by %" PRIu16
@@ -9619,13 +9621,14 @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,
 /* Rotate an image by a multiple of 90 degrees clockwise */
 static int rotateImage(uint16_t rotation, struct image_data *image,
                        uint32_t *img_width, uint32_t *img_length,
-                       unsigned char **ibuff_ptr)
+                       unsigned char **ibuff_ptr, size_t *rot_buf_size)
 {
     int shift_width;
     uint32_t bytes_per_pixel, bytes_per_sample;
     uint32_t row, rowsize, src_offset, dst_offset;
     uint32_t i, col, width, length;
-    uint32_t colsize, buffsize, col_offset, pix_offset;
+    uint32_t colsize, col_offset, pix_offset;
+    tmsize_t buffsize;
     unsigned char *ibuff;
     unsigned char *src;
     unsigned char *dst;
@@ -9638,12 +9641,40 @@ static int rotateImage(uint16_t rotation, struct image_data *image,
     spp = image->spp;
     bps = image->bps;
 
+    if ((spp != 0 && bps != 0 &&
+         width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) ||
+        (spp != 0 && bps != 0 &&
+         length > (uint32_t)((UINT32_MAX - 7) / spp / bps)))
+    {
+        TIFFError("rotateImage", "Integer overflow detected.");
+        return (-1);
+    }
     rowsize = ((bps * spp * width) + 7) / 8;
     colsize = ((bps * spp * length) + 7) / 8;
     if ((colsize * width) > (rowsize * length))
-        buffsize = (colsize + 1) * width;
+    {
+        if (((tmsize_t)colsize + 1) != 0 &&
+            (tmsize_t)width > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
+                               ((tmsize_t)colsize + 1)))
+        {
+            TIFFError("rotateImage",
+                      "Integer overflow when calculating buffer size.");
+            return (-1);
+        }
+        buffsize = ((tmsize_t)colsize + 1) * width;
+    }
     else
+    {
+        if (((tmsize_t)rowsize + 1) != 0 &&
+            (tmsize_t)length > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) /
+                                ((tmsize_t)rowsize + 1)))
+        {
+            TIFFError("rotateImage",
+                      "Integer overflow when calculating buffer size.");
+            return (-1);
+        }
         buffsize = (rowsize + 1) * length;
+    }
 
     bytes_per_sample = (bps + 7) / 8;
     bytes_per_pixel = ((bps * spp) + 7) / 8;
@@ -9672,11 +9703,14 @@ static int rotateImage(uint16_t rotation, struct image_data *image,
               (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES)))
     {
         TIFFError("rotateImage",
-                  "Unable to allocate rotation buffer of %1u bytes",
+                  "Unable to allocate rotation buffer of %" TIFF_SSIZE_FORMAT
+                  " bytes ",
                   buffsize + NUM_BUFF_OVERSIZE_BYTES);
         return (-1);
     }
     _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
+    if (rot_buf_size != NULL)
+        *rot_buf_size = buffsize;
 
     ibuff = *ibuff_ptr;
     switch (rotation)

commit 6366e8f776a0fa0dd476d37b108eecdf42b950f3 (from 688012dca2c39033aa2dc7bcea9796787cfd1b44)	6366e8f776a0fa0dd476d37b108eecdf42b950f3
Merge: 33aee127 688012dc
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Sun Feb 5 16:04:07 2023 +0000

    Merge branch 'tiffcrop_correctly_update_buffersize_after_rotate_fix#520' into 'master'
    
    tiffcrop correctly update buffersize after rotateImage() fix#520
    
    Closes #520
    
    See merge request libtiff/libtiff!467

diff --git a/libtiff/tif_close.c b/libtiff/tif_close.c
index 985d290c..907d7f13 100644
--- a/libtiff/tif_close.c
+++ b/libtiff/tif_close.c
@@ -147,9 +147,12 @@ void _TIFFCleanupIFDOffsetAndNumberMaps(TIFF *tif)
 
 void TIFFClose(TIFF *tif)
 {
-    TIFFCloseProc closeproc = tif->tif_closeproc;
-    thandle_t fd = tif->tif_clientdata;
+    if (tif != NULL)
+    {
+        TIFFCloseProc closeproc = tif->tif_closeproc;
+        thandle_t fd = tif->tif_clientdata;
 
-    TIFFCleanup(tif);
-    (void)(*closeproc)(fd);
+        TIFFCleanup(tif);
+        (void)(*closeproc)(fd);
+    }
 }
diff --git a/test/Makefile.am b/test/Makefile.am
index b0fe276a..148406ab 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -216,6 +216,7 @@ IMAGES_EXTRA_DIST = \
 	images/test_ifd_loop_to_self.tif \
 	images/test_ifd_loop_to_first.tif \
 	images/test_two_ifds.tif \
+	images/test_ifd_loop_subifd.tif \
 	$(PNMIMAGES) \
 	$(TIFFIMAGES)
 
diff --git a/test/images/test_ifd_loop_subifd.tif b/test/images/test_ifd_loop_subifd.tif
new file mode 100644
index 00000000..7294085e
Binary files /dev/null and b/test/images/test_ifd_loop_subifd.tif differ
diff --git a/test/test_ifd_loop_detection.c b/test/test_ifd_loop_detection.c
index 52b089bf..99a749e5 100644
--- a/test/test_ifd_loop_detection.c
+++ b/test/test_ifd_loop_detection.c
@@ -36,6 +36,142 @@
 
 #include "tiffio.h"
 
+int is_requested_directory(TIFF *tif, int requested_dir_number,
+                           const char *filename)
+{
+    char *ptr;
+
+    if (!TIFFGetField(tif, TIFFTAG_PAGENAME, &ptr))
+    {
+        fprintf(stderr, "Can't get TIFFTAG_PAGENAME tag.\n");
+        return 0;
+    }
+    /* Retrieve directory number from ASCII string */
+    char *auxStr = strchr(ptr, ' ');
+    int nthIFD;
+    nthIFD = atoi(ptr);
+
+    /* Check for reading errors */
+    if (strncmp(auxStr, " th.", 4))
+    {
+        fprintf(stderr,
+                "Error reading IFD directory number from PageName tag: %s\n",
+                ptr);
+        return 0;
+    }
+
+    if (nthIFD == requested_dir_number)
+    {
+        return 1;
+    }
+    fprintf(stderr, "Expected directory %d from %s was not loaded but: %s\n",
+            requested_dir_number, filename, ptr);
+
+    return 0;
+}
+
+/* Test loop detection within chained SubIFDs.
+ * test_ifd_loop_subifd.tif contains seven main-IFDs (0 to 6) and within IFD 1
+ * there are three SubIFDs (0 to 2). Main IFD 4 loops back to main IFD 2.
+ * SubIFD 2 loops back to SubIFD 1.
+ * Within each IFD the tag PageName is filled with a string, indicating the
+ * IFD. The main IFDs are numbered 0 to 6 and the SubIFDs 200 to 202. */
+int test_subifd_loop(void)
+{
+    const char *filename = SOURCE_DIR "/images/test_ifd_loop_subifd.tif";
+    TIFF *tif;
+    int i, n;
+    int ret = 0;
+#define NUMBER_OF_SUBIFDs 3
+    toff_t sub_IFDs_offsets[NUMBER_OF_SUBIFDs] = {
+        0UL}; /* array for SubIFD tag */
+    void *ptr;
+    uint16_t number_of_sub_IFDs = 0;
+
+    tif = TIFFOpen(filename, "r");
+    if (!tif)
+    {
+        fprintf(stderr, "Can't open  %s\n", filename);
+        return 1;
+    }
+
+    /* Try to read six further main directories. Fifth read shall fail. */
+    for (i = 0; i < 6; i++)
+    {
+        if (!TIFFReadDirectory(tif))
+            break;
+    }
+    if (i != 4)
+    {
+        fprintf(stderr, "(20) Expected fifth TIFFReadDirectory() to fail\n");
+        ret = 1;
+    }
+    if (!is_requested_directory(tif, 4, filename))
+    {
+        fprintf(stderr, "(21) Expected fifth main IFD to be loaded\n");
+        ret = 1;
+    }
+
+    /* Switch to IFD 1 and get SubIFDs.
+     * Then read through SubIFDs and detect SubIFD loop.
+     * Finally go back to main-IFD and check if right IFD is loaded.
+     */
+    if (!TIFFSetDirectory(tif, 1))
+        ret = 1;
+
+    /* Check if there are SubIFD subfiles */
+    if (TIFFGetField(tif, TIFFTAG_SUBIFD, &number_of_sub_IFDs, &ptr) &&
+        (number_of_sub_IFDs == 3))
+    {
+        /* Copy SubIFD array from pointer */
+        memcpy(sub_IFDs_offsets, ptr,
+               number_of_sub_IFDs * sizeof(sub_IFDs_offsets[0]));
+
+        for (i = 0; i < number_of_sub_IFDs; i++)
+        {
+            /* Read SubIFD directory directly via offset.
+             * SubIFDs PageName string contains numbers 200 to 202. */
+            if (!TIFFSetSubDirectory(tif, sub_IFDs_offsets[i]))
+                ret = 1;
+            if (!is_requested_directory(tif, 200 + i, filename))
+            {
+                fprintf(stderr, "(22) Expected SubIFD %d to be loaded.\n", i);
+                ret = 1;
+            }
+            /* Now test SubIFD loop detection.
+             * The (i+n).th read in the SubIFD chain shall fail. */
+            for (n = 0; n < number_of_sub_IFDs; n++)
+            {
+                if (!TIFFReadDirectory(tif))
+                    break;
+            }
+            if ((i + n) != 2)
+            {
+                fprintf(
+                    stderr,
+                    "(23) Expected third SubIFD-TIFFReadDirectory() to fail\n");
+                ret = 1;
+            }
+        }
+        /* Go back to main-IFD chain and re-read that main-IFD directory */
+        if (!TIFFSetDirectory(tif, 3))
+            ret = 1;
+        if (!is_requested_directory(tif, 3, filename))
+        {
+            fprintf(stderr, "(24) Expected fourth main IFD to be loaded\n");
+            ret = 1;
+        }
+    }
+    else
+    {
+        fprintf(stderr, "(25) No or wrong expected SubIFDs within main IFD\n");
+        ret = 1;
+    }
+
+    TIFFClose(tif);
+    return ret;
+} /*-- test_subifd_loop() --*/
+
 int main()
 {
     int ret = 0;
@@ -175,5 +311,6 @@ int main()
         }
         TIFFClose(tif);
     }
+    ret += test_subifd_loop();
     return ret;
 }
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index ca23529b..ebea7475 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -2920,7 +2920,10 @@ int main(int argc, char *argv[])
         }
     }
 
-    TIFFClose(out);
+    if (out != NULL)
+    {
+        TIFFClose(out);
+    }
 
     return (0);
 } /* end main */
@@ -5932,18 +5935,40 @@ static int computeInputPixelOffsets(struct crop_mask *crop,
 
             crop->regionlist[i].buffsize = buffsize;
             crop->bufftotal += buffsize;
+
+            /* For composite images with more than one region, the
+             * combined_length or combined_width always needs to be equal,
+             * respectively.
+             * Otherwise, even the first section/region copy
+             * action might cause buffer overrun. */
             if (crop->img_mode == COMPOSITE_IMAGES)
             {
                 switch (crop->edge_ref)
                 {
                     case EDGE_LEFT:
                     case EDGE_RIGHT:
+                        if (i > 0 && zlength != crop->combined_length)
+                        {
+                            TIFFError(
+                                "computeInputPixelOffsets",
+                                "Only equal length regions can be combined for "
+                                "-E left or right");
+                            return (-1);
+                        }
                         crop->combined_length = zlength;
                         crop->combined_width += zwidth;
                         break;
                     case EDGE_BOTTOM:
                     case EDGE_TOP: /* width from left, length from top */
                     default:
+                        if (i > 0 && zwidth != crop->combined_width)
+                        {
+                            TIFFError("computeInputPixelOffsets",
+                                      "Only equal width regions can be "
+                                      "combined for -E "
+                                      "top or bottom");
+                            return (-1);
+                        }
                         crop->combined_width = zwidth;
                         crop->combined_length += zlength;
                         break;
@@ -7298,6 +7323,46 @@ static int extractCompositeRegions(struct image_data *image,
     crop->combined_width = 0;
     crop->combined_length = 0;
 
+    /* If there is more than one region, check beforehand whether all the width
+     * and length values of the regions are the same, respectively. */
+    switch (crop->edge_ref)
+    {
+        default:
+        case EDGE_TOP:
+        case EDGE_BOTTOM:
+            for (i = 1; i < crop->selections; i++)
+            {
+                uint32_t crop_width0 =
+                    crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;
+                uint32_t crop_width1 =
+                    crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;
+                if (crop_width0 != crop_width1)
+                {
+                    TIFFError("extractCompositeRegions",
+                              "Only equal width regions can be combined for -E "
+                              "top or bottom");
+                    return (1);
+                }
+            }
+            break;
+        case EDGE_LEFT:
+        case EDGE_RIGHT:
+            for (i = 1; i < crop->selections; i++)
+            {
+                uint32_t crop_length0 =
+                    crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;
+                uint32_t crop_length1 =
+                    crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;
+                if (crop_length0 != crop_length1)
+                {
+                    TIFFError("extractCompositeRegions",
+                              "Only equal length regions can be combined for "
+                              "-E left or right");
+                    return (1);
+                }
+            }
+    }
+
     for (i = 0; i < crop->selections; i++)
     {
         /* rows, columns, width, length are expressed in pixels */
@@ -7322,7 +7387,8 @@ static int extractCompositeRegions(struct image_data *image,
             default:
             case EDGE_TOP:
             case EDGE_BOTTOM:
-                if ((i > 0) && (crop_width != crop->regionlist[i - 1].width))
+                if ((crop->selections > i + 1) &&
+                    (crop_width != crop->regionlist[i + 1].width))
                 {
                     TIFFError("extractCompositeRegions",
                               "Only equal width regions can be combined for -E "
@@ -7415,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,
             case EDGE_LEFT: /* splice the pieces of each row together, side by
                                side */
             case EDGE_RIGHT:
-                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))
+                if ((crop->selections > i + 1) &&
+                    (crop_length != crop->regionlist[i + 1].length))
                 {
                     TIFFError("extractCompositeRegions",
                               "Only equal length regions can be combined for "
