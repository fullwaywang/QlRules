commit 96aa1b22bd6bb9fccf62f6261f390ed6f3e7967f
Author: Willem de Bruijn <willemb@google.com>
Date:   Sat May 30 15:41:31 2020 -0400

    tun: correct header offsets in napi frags mode
    
    Tun in IFF_NAPI_FRAGS mode calls napi_gro_frags. Unlike netif_rx and
    netif_gro_receive, this expects skb->data to point to the mac layer.
    
    But skb_probe_transport_header, __skb_get_hash_symmetric, and
    xdp_do_generic in tun_get_user need skb->data to point to the network
    header. Flow dissection also needs skb->protocol set, so
    eth_type_trans has to be called.
    
    Ensure the link layer header lies in linear as eth_type_trans pulls
    ETH_HLEN. Then take the same code paths for frags as for not frags.
    Push the link layer header back just before calling napi_gro_frags.
    
    By pulling up to ETH_HLEN from frag0 into linear, this disables the
    frag0 optimization in the special case when IFF_NAPI_FRAGS is used
    with zero length iov[0] (and thus empty skb->linear).
    
    Fixes: 90e33d459407 ("tun: enable napi_gro_frags() for TUN/TAP driver")
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Petar Penkov <ppenkov@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index c54f967..b0ab882 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1872,8 +1872,11 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		skb->dev = tun->dev;
 		break;
 	case IFF_TAP:
-		if (!frags)
-			skb->protocol = eth_type_trans(skb, tun->dev);
+		if (frags && !pskb_may_pull(skb, ETH_HLEN)) {
+			err = -ENOMEM;
+			goto drop;
+		}
+		skb->protocol = eth_type_trans(skb, tun->dev);
 		break;
 	}
 
@@ -1930,9 +1933,12 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	}
 
 	if (frags) {
+		u32 headlen;
+
 		/* Exercise flow dissector code path. */
-		u32 headlen = eth_get_headlen(tun->dev, skb->data,
-					      skb_headlen(skb));
+		skb_push(skb, ETH_HLEN);
+		headlen = eth_get_headlen(tun->dev, skb->data,
+					  skb_headlen(skb));
 
 		if (unlikely(headlen > skb_headlen(skb))) {
 			this_cpu_inc(tun->pcpu_stats->rx_dropped);
