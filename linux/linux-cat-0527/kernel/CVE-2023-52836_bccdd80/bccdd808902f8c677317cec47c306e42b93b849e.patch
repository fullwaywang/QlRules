commit bccdd808902f8c677317cec47c306e42b93b849e
Author: John Stultz <jstultz@google.com>
Date:   Fri Sep 22 04:36:00 2023 +0000

    locking/ww_mutex/test: Fix potential workqueue corruption
    
    In some cases running with the test-ww_mutex code, I was seeing
    odd behavior where sometimes it seemed flush_workqueue was
    returning before all the work threads were finished.
    
    Often this would cause strange crashes as the mutexes would be
    freed while they were being used.
    
    Looking at the code, there is a lifetime problem as the
    controlling thread that spawns the work allocates the
    "struct stress" structures that are passed to the workqueue
    threads. Then when the workqueue threads are finished,
    they free the stress struct that was passed to them.
    
    Unfortunately the workqueue work_struct node is in the stress
    struct. Which means the work_struct is freed before the work
    thread returns and while flush_workqueue is waiting.
    
    It seems like a better idea to have the controlling thread
    both allocate and free the stress structures, so that we can
    be sure we don't corrupt the workqueue by freeing the structure
    prematurely.
    
    So this patch reworks the test to do so, and with this change
    I no longer see the early flush_workqueue returns.
    
    Signed-off-by: John Stultz <jstultz@google.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20230922043616.19282-3-jstultz@google.com

diff --git a/kernel/locking/test-ww_mutex.c b/kernel/locking/test-ww_mutex.c
index 9bceba65858a..358d66150426 100644
--- a/kernel/locking/test-ww_mutex.c
+++ b/kernel/locking/test-ww_mutex.c
@@ -479,7 +479,6 @@ static void stress_inorder_work(struct work_struct *work)
 	} while (!time_after(jiffies, stress->timeout));
 
 	kfree(order);
-	kfree(stress);
 }
 
 struct reorder_lock {
@@ -544,7 +543,6 @@ static void stress_reorder_work(struct work_struct *work)
 	list_for_each_entry_safe(ll, ln, &locks, link)
 		kfree(ll);
 	kfree(order);
-	kfree(stress);
 }
 
 static void stress_one_work(struct work_struct *work)
@@ -565,8 +563,6 @@ static void stress_one_work(struct work_struct *work)
 			break;
 		}
 	} while (!time_after(jiffies, stress->timeout));
-
-	kfree(stress);
 }
 
 #define STRESS_INORDER BIT(0)
@@ -577,15 +573,24 @@ static void stress_one_work(struct work_struct *work)
 static int stress(int nlocks, int nthreads, unsigned int flags)
 {
 	struct ww_mutex *locks;
-	int n;
+	struct stress *stress_array;
+	int n, count;
 
 	locks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);
 	if (!locks)
 		return -ENOMEM;
 
+	stress_array = kmalloc_array(nthreads, sizeof(*stress_array),
+				     GFP_KERNEL);
+	if (!stress_array) {
+		kfree(locks);
+		return -ENOMEM;
+	}
+
 	for (n = 0; n < nlocks; n++)
 		ww_mutex_init(&locks[n], &ww_class);
 
+	count = 0;
 	for (n = 0; nthreads; n++) {
 		struct stress *stress;
 		void (*fn)(struct work_struct *work);
@@ -609,9 +614,7 @@ static int stress(int nlocks, int nthreads, unsigned int flags)
 		if (!fn)
 			continue;
 
-		stress = kmalloc(sizeof(*stress), GFP_KERNEL);
-		if (!stress)
-			break;
+		stress = &stress_array[count++];
 
 		INIT_WORK(&stress->work, fn);
 		stress->locks = locks;
@@ -626,6 +629,7 @@ static int stress(int nlocks, int nthreads, unsigned int flags)
 
 	for (n = 0; n < nlocks; n++)
 		ww_mutex_destroy(&locks[n]);
+	kfree(stress_array);
 	kfree(locks);
 
 	return 0;
