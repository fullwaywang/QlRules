commit fb96fd5f41bec823dbb208d9a7d53fbbf4d16ce4	fb96fd5f41bec823dbb208d9a7d53fbbf4d16ce4
Author: Hongchan Choi <hongchan@chromium.org>
Date:   Thu Nov 30 00:40:34 2023 +0000

    Wrap buffer read index in delay kernel
    
    The current code assumes that the first buffer read index in the delay
    kernel does not go out of bound. This CL applies the wrapping function
    to the read index array.
    
    Bug: 1505086
    Test: Locally confirmed the repro does not crash anymore
    Change-Id: Idca3dfc7dec5b5a7f9b22d87135e2d775729631a
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5072113
    Commit-Queue: Hongchan Choi <hongchan@chromium.org>
    Reviewed-by: Michael Wilson <mjwilson@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1231040}

diff --git a/third_party/blink/renderer/platform/audio/cpu/arm/delay_neon.cc b/third_party/blink/renderer/platform/audio/cpu/arm/delay_neon.cc
index 02aff4d89f9ed..a11b175b28697 100644
--- a/third_party/blink/renderer/platform/audio/cpu/arm/delay_neon.cc
+++ b/third_party/blink/renderer/platform/audio/cpu/arm/delay_neon.cc
@@ -61,6 +61,7 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
   int w_index = write_index_;
 
   const float32x4_t v_sample_rate = vdupq_n_f32(sample_rate);
+  const float32x4_t v_all_zeros = vdupq_n_f32(0);
 
   // The buffer length as a float and as an int so we don't need to constant
   // convert from one to the other.
@@ -88,7 +89,8 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
   int k = 0;
 
   for (int n = 0; n < number_of_loops; ++n, k += 4) {
-    const float32x4_t v_delay_time = vld1q_f32(delay_times + k);
+    const float32x4_t v_delay_time = vmaxq_f32(vld1q_f32(delay_times + k),
+                                               v_all_zeros);
     const float32x4_t v_desired_delay_frames =
         vmulq_f32(v_delay_time, v_sample_rate);
 
@@ -101,7 +103,8 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
         WrapPositionVector(v_read_position, v_buffer_length_float);
 
     // Get indices into the buffer for the samples we need for interpolation.
-    const int32x4_t v_read_index1 = vcvtq_s32_f32(v_read_position);
+    const int32x4_t v_read_index1 = WrapIndexVector(
+        vcvtq_s32_f32(v_read_position), v_buffer_length_int);
     const int32x4_t v_read_index2 = WrapIndexVector(
         vaddq_s32(v_read_index1, vdupq_n_s32(1)), v_buffer_length_int);
 
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
index 67f18cb758346..dfbf83fbfafba 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
@@ -56,10 +56,10 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
 
   const float sample_rate = sample_rate_;
   const float* delay_times = delay_times_.Data();
-
   int w_index = write_index_;
 
   const __m128 v_sample_rate = _mm_set1_ps(sample_rate);
+  const __m128 v_all_zeros = _mm_setzero_ps();
 
   // The buffer length as a float and as an int so we don't need to constant
   // convert from one to the other.
@@ -82,7 +82,10 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
   int k = 0;
 
   for (int n = 0; n < number_of_loops; ++n, k += 4) {
-    const __m128 v_delay_time = _mm_loadu_ps(delay_times + k);
+    // It's possible that `delay_time` contains negative values. Make sure
+    // they are greater than zero.
+    const __m128 v_delay_time = _mm_max_ps(_mm_loadu_ps(delay_times + k),
+                                           v_all_zeros);
     const __m128 v_desired_delay_frames =
         _mm_mul_ps(v_delay_time, v_sample_rate);
 
@@ -95,7 +98,8 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
         WrapPositionVector(v_read_position, v_buffer_length_float);
 
     // Get indices into the buffer for the samples we need for interpolation.
-    const __m128i v_read_index1 = _mm_cvttps_epi32(v_read_position);
+    const __m128i v_read_index1 = WrapIndexVector(
+        _mm_cvttps_epi32(v_read_position), v_buffer_length_int);
     const __m128i v_read_index2 = WrapIndexVector(
         _mm_add_epi32(v_read_index1, _mm_set1_epi32(1)), v_buffer_length_int);
 
diff --git a/third_party/blink/renderer/platform/audio/delay.cc b/third_party/blink/renderer/platform/audio/delay.cc
index e43211016cca9..be98e08a71737 100644
--- a/third_party/blink/renderer/platform/audio/delay.cc
+++ b/third_party/blink/renderer/platform/audio/delay.cc
@@ -135,7 +135,7 @@ int Delay::ProcessARateScalar(unsigned start,
   const float* delay_times = delay_times_.Data();
 
   for (unsigned i = start; i < frames_to_process; ++i) {
-    double delay_time = delay_times[i];
+    double delay_time = std::fmax(delay_times[i], 0);
     double desired_delay_frames = delay_time * sample_rate;
 
     double read_position = w_index + buffer_length - desired_delay_frames;
