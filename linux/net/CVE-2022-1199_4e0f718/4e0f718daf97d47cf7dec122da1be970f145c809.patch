commit 4e0f718daf97d47cf7dec122da1be970f145c809
Author: Duoming Zhou <duoming@zju.edu.cn>
Date:   Fri Jan 28 12:47:15 2022 +0800

    ax25: improve the incomplete fix to avoid UAF and NPD bugs
    
    The previous commit 1ade48d0c27d ("ax25: NPD bug when detaching
    AX25 device") introduce lock_sock() into ax25_kill_by_device to
    prevent NPD bug. But the concurrency NPD or UAF bug will occur,
    when lock_sock() or release_sock() dereferences the ax25_cb->sock.
    
    The NULL pointer dereference bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
                                 |     ax25_cb_del()
      ...                        |     ...
                                 |     ax25->sk=NULL;
      lock_sock(s->sk); //(1)    |
      s->ax25_dev = NULL;        |     ...
      release_sock(s->sk); //(2) |
      ...                        |
    
    The root cause is that the sock is set to null before dereference
    site (1) or (2). Therefore, this patch extracts the ax25_cb->sock
    in advance, and uses ax25_list_lock to protect it, which can synchronize
    with ax25_cb_del() and ensure the value of sock is not null before
    dereference sites.
    
    The concurrency UAF bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
      ...                        |   ...
                                 |   sock_put(sk); //FREE
      lock_sock(s->sk); //(1)    |
      s->ax25_dev = NULL;        |   ...
      release_sock(s->sk); //(2) |
      ...                        |
    
    The root cause is that the sock is released before dereference
    site (1) or (2). Therefore, this patch uses sock_hold() to increase
    the refcount of sock and uses ax25_list_lock to protect it, which
    can synchronize with ax25_cb_del() in ax25_destroy_socket() and
    ensure the sock wil not be released before dereference sites.
    
    Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 02f43f3..44a8730 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -77,6 +77,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 {
 	ax25_dev *ax25_dev;
 	ax25_cb *s;
+	struct sock *sk;
 
 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
 		return;
@@ -85,13 +86,15 @@ static void ax25_kill_by_device(struct net_device *dev)
 again:
 	ax25_for_each(s, &ax25_list) {
 		if (s->ax25_dev == ax25_dev) {
+			sk = s->sk;
+			sock_hold(sk);
 			spin_unlock_bh(&ax25_list_lock);
-			lock_sock(s->sk);
+			lock_sock(sk);
 			s->ax25_dev = NULL;
-			release_sock(s->sk);
+			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&ax25_list_lock);
-
+			sock_put(sk);
 			/* The entry could have been deleted from the
 			 * list meanwhile and thus the next pointer is
 			 * no longer valid.  Play it safe and restart
