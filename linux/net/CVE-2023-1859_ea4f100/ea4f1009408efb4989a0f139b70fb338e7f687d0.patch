commit ea4f1009408efb4989a0f139b70fb338e7f687d0
Author: Zheng Wang <zyytlz.wz@163.com>
Date:   Mon Mar 13 22:43:25 2023 +0800

    9p/xen : Fix use after free bug in xen_9pfs_front_remove due to race condition
    
    In xen_9pfs_front_probe, it calls xen_9pfs_front_alloc_dataring
    to init priv->rings and bound &ring->work with p9_xen_response.
    
    When it calls xen_9pfs_front_event_handler to handle IRQ requests,
    it will finally call schedule_work to start the work.
    
    When we call xen_9pfs_front_remove to remove the driver, there
    may be a sequence as follows:
    
    Fix it by finishing the work before cleanup in xen_9pfs_front_free.
    
    Note that, this bug is found by static analysis, which might be
    false positive.
    
    CPU0                  CPU1
    
                         |p9_xen_response
    xen_9pfs_front_remove|
      xen_9pfs_front_free|
    kfree(priv)          |
    //free priv          |
                         |p9_tag_lookup
                         |//use priv->client
    
    Fixes: 71ebd71921e4 ("xen/9pfs: connect to the backend")
    Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
    Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
    Signed-off-by: Eric Van Hensbergen <ericvh@kernel.org>

diff --git a/net/9p/trans_xen.c b/net/9p/trans_xen.c
index c64050e839ac..1fffe2bed5b0 100644
--- a/net/9p/trans_xen.c
+++ b/net/9p/trans_xen.c
@@ -280,6 +280,10 @@ static void xen_9pfs_front_free(struct xen_9pfs_front_priv *priv)
 	write_unlock(&xen_9pfs_lock);
 
 	for (i = 0; i < priv->num_rings; i++) {
+		struct xen_9pfs_dataring *ring = &priv->rings[i];
+
+		cancel_work_sync(&ring->work);
+
 		if (!priv->rings[i].intf)
 			break;
 		if (priv->rings[i].irq > 0)
