commit 19fdec19317884bacf8f48fce2f0c222d0497caa	19fdec19317884bacf8f48fce2f0c222d0497caa
Author: Haxatron Sec <haxatron1@gmail.com>
Date:   Thu Aug 3 17:44:55 2023 +0000

    Account for scroll in cursor checks
    
    Use the correct transform for frame rect to account for scroll.
    
    Video: https://bugs.chromium.org/p/chromium/issues/detail?id=1454515#c18
    
    Fixed: 1454515
    Change-Id: I996bfaaaddc22055f7f350c40357625c420141e6
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4728774
    Reviewed-by: Stefan Zager <szager@chromium.org>
    Reviewed-by: Mike Wasserman <msw@chromium.org>
    Commit-Queue: Mike Wasserman <msw@chromium.org>
    Reviewed-by: Ken Buchanan <kenrb@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1179139}

diff --git a/content/browser/site_per_process_hit_test_browsertest.cc b/content/browser/site_per_process_hit_test_browsertest.cc
index 456054bab5f89..62188a0b942da 100644
--- a/content/browser/site_per_process_hit_test_browsertest.cc
+++ b/content/browser/site_per_process_hit_test_browsertest.cc
@@ -4463,6 +4463,73 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessHitTestBrowserTest,
               set_cursor_interceptor->cursor());
   }
 }
+
+// Regression test for https://crbug.com/1454515. An OOPIF
+// scrolled away from the main document should not allow
+// large cursors to intersect browser UI.
+IN_PROC_BROWSER_TEST_F(SitePerProcessHitTestBrowserTest,
+                       LargeCursorRemovedInScrolledOOPIF) {
+  GURL url(R"(data:text/html,
+    <iframe id='iframe'
+            style ='position:absolute; top: 0px'
+            width=1000px height=1000px>
+    </iframe>)");
+  EXPECT_TRUE(NavigateToURL(shell(), url));
+
+  // The large-cursor.html document has a custom cursor that is 120x120 with a
+  // hotspot on the bottom right corner.
+  NavigateIframeToURL(shell()->web_contents(), "iframe",
+                      embedded_test_server()->GetURL("/large-cursor.html"));
+
+  auto* web_contents = static_cast<WebContentsImpl*>(shell()->web_contents());
+  FrameTreeNode* root = web_contents->GetPrimaryFrameTree().root();
+
+  FrameTreeNode* child_node = root->child_at(0);
+  EXPECT_NE(shell()->web_contents()->GetSiteInstance(),
+            child_node->current_frame_host()->GetSiteInstance());
+
+  WaitForHitTestData(child_node->current_frame_host());
+
+  RenderWidgetHostViewBase* root_view = static_cast<RenderWidgetHostViewBase*>(
+      root->current_frame_host()->GetRenderWidgetHost()->GetView());
+  RenderWidgetHostImpl* rwh_child =
+      root->child_at(0)->current_frame_host()->GetRenderWidgetHost();
+  RenderWidgetHostViewBase* child_view =
+      static_cast<RenderWidgetHostViewBase*>(rwh_child->GetView());
+
+  auto* router = web_contents->GetInputEventRouter();
+
+  // Scroll the main frame.
+  gfx::Rect initial_child_view_bounds = child_view->GetViewBounds();
+  EXPECT_TRUE(ExecJs(root, "window.scrollTo(0, 10);"));
+  // Wait until the OOPIF positions have been updated in the browser process.
+  while (true) {
+    base::RunLoop run_loop;
+    base::SingleThreadTaskRunner::GetCurrentDefault()->PostDelayedTask(
+        FROM_HERE, run_loop.QuitClosure(), TestTimeouts::tiny_timeout());
+    run_loop.Run();
+    if (initial_child_view_bounds.y() ==
+        child_view->GetViewBounds().y() + 10)
+      break;
+  }
+
+  // A cursor should not be shown when the main frame is scrolled
+  // and the iframe is outside the root view's visible viewport.
+  blink::WebMouseEvent mouse_event(
+      blink::WebInputEvent::Type::kMouseMove,
+      blink::WebInputEvent::kNoModifiers,
+      blink::WebInputEvent::GetStaticTimeStampForTests());
+  SetWebEventPositions(&mouse_event, gfx::Point(300, 115), root_view);
+  auto set_cursor_interceptor =
+      std::make_unique<SetCursorInterceptor>(rwh_child);
+  RouteMouseEventAndWaitUntilDispatch(router, root_view, child_view,
+                                      &mouse_event);
+  // We should see a new cursor come in that replaces the large one.
+  set_cursor_interceptor->Wait();
+  EXPECT_TRUE(set_cursor_interceptor->cursor().has_value());
+  EXPECT_EQ(ui::mojom::CursorType::kPointer,
+            set_cursor_interceptor->cursor());
+}
 #endif  // !BUILDFLAG(IS_ANDROID)
 
 #if defined(USE_AURA)
diff --git a/third_party/blink/renderer/core/input/event_handler.cc b/third_party/blink/renderer/core/input/event_handler.cc
index b8d14c603a8a3..6bf7ed1215342 100644
--- a/third_party/blink/renderer/core/input/event_handler.cc
+++ b/third_party/blink/renderer/core/input/event_handler.cc
@@ -597,8 +597,10 @@ absl::optional<ui::Cursor> EventHandler::SelectCursor(
             PhysicalOffset(hot_spot);
         PhysicalRect cursor_rect(cursor_offset,
                                  PhysicalSize::FromSizeFFloor(size));
-        if (!PhysicalRect(page->GetVisualViewport().VisibleContentRect())
-                 .Contains(cursor_rect)) {
+        PhysicalRect frame_rect(page->GetVisualViewport().VisibleContentRect());
+        frame_->ContentLayoutObject()->MapToVisualRectInAncestorSpace(
+            nullptr, frame_rect);
+        if (!frame_rect.Contains(cursor_rect)) {
           continue;
         }
       }
