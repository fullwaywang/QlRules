commit 27900d7119c464b43cd9eac69c85884d17bae240
Author: Peter Wang <peter.wang@mediatek.com>
Date:   Mon Nov 6 15:51:17 2023 +0800

    scsi: ufs: core: Fix racing issue between ufshcd_mcq_abort() and ISR
    
    If command timeout happens and cq complete IRQ is raised at the same time,
    ufshcd_mcq_abort clears lprb->cmd and a NULL pointer deref happens in the
    ISR. Error log:
    
    ufshcd_abort: Device abort task at tag 18
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000108
    pc : [0xffffffe27ef867ac] scsi_dma_unmap+0xc/0x44
    lr : [0xffffffe27f1b898c] ufshcd_release_scsi_cmd+0x24/0x114
    
    Fixes: f1304d442077 ("scsi: ufs: mcq: Added ufshcd_mcq_abort()")
    Cc: stable@vger.kernel.org
    Signed-off-by: Peter Wang <peter.wang@mediatek.com>
    Link: https://lore.kernel.org/r/20231106075117.8995-1-peter.wang@mediatek.com
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/ufs/core/ufs-mcq.c b/drivers/ufs/core/ufs-mcq.c
index 5c75ab9d6bb5..0787456c2b89 100644
--- a/drivers/ufs/core/ufs-mcq.c
+++ b/drivers/ufs/core/ufs-mcq.c
@@ -630,6 +630,7 @@ int ufshcd_mcq_abort(struct scsi_cmnd *cmd)
 	int tag = scsi_cmd_to_rq(cmd)->tag;
 	struct ufshcd_lrb *lrbp = &hba->lrb[tag];
 	struct ufs_hw_queue *hwq;
+	unsigned long flags;
 	int err = FAILED;
 
 	if (!ufshcd_cmd_inflight(lrbp->cmd)) {
@@ -670,8 +671,10 @@ int ufshcd_mcq_abort(struct scsi_cmnd *cmd)
 	}
 
 	err = SUCCESS;
+	spin_lock_irqsave(&hwq->cq_lock, flags);
 	if (ufshcd_cmd_inflight(lrbp->cmd))
 		ufshcd_release_scsi_cmd(hba, lrbp);
+	spin_unlock_irqrestore(&hwq->cq_lock, flags);
 
 out:
 	return err;
