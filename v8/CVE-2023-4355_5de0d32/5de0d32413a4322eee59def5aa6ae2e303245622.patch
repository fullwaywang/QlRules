commit 5de0d32413a4322eee59def5aa6ae2e303245622	5de0d32413a4322eee59def5aa6ae2e303245622
Author: Dominik Inführ <dinfuehr@chromium.org>
Date:   Wed Aug 9 15:56:52 2023 +0200

    [heap] Check that markers don't see filler objects
    
    Now that left trimming is disabled during incremental marking we
    should never have free space or filler objects in the marking
    worklist. CHECK that this is the case on main and concurrent threads.
    
    Bug: chromium:1468943
    Change-Id: Id7e046e4367f6269b310dbffea80bf9eba4a5d89
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4762696
    Reviewed-by: Omer Katz <omerkatz@chromium.org>
    Commit-Queue: Dominik Inführ <dinfuehr@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#89470}

diff --git a/src/heap/concurrent-marking.cc b/src/heap/concurrent-marking.cc
index fb974636b45..d1ef54a4ef5 100644
--- a/src/heap/concurrent-marking.cc
+++ b/src/heap/concurrent-marking.cc
@@ -306,6 +306,8 @@ void ConcurrentMarking::RunMajor(JobDelegate* delegate,
           local_marking_worklists.PushOnHold(object);
         } else {
           Map map = object->map(isolate, kAcquireLoad);
+          // The marking worklist should never contain filler objects.
+          CHECK(!IsFreeSpaceOrFillerMap(map));
           if (is_per_context_mode) {
             Address context;
             if (native_context_inferrer.Infer(isolate, map, object, &context)) {
diff --git a/src/heap/mark-compact.cc b/src/heap/mark-compact.cc
index cf4f807797a..3266937cbc2 100644
--- a/src/heap/mark-compact.cc
+++ b/src/heap/mark-compact.cc
@@ -2148,21 +2148,8 @@ std::pair<size_t, size_t> MarkCompactCollector::ProcessMarkingWorklist(
 
   while (local_marking_worklists_->Pop(&object) ||
          local_marking_worklists_->PopOnHold(&object)) {
-    // Left trimming may result in grey or black filler objects on the marking
-    // worklist. Ignore these objects.
-    if (IsFreeSpaceOrFiller(object, cage_base)) {
-      // Due to copying mark bits and the fact that grey and black have their
-      // first bit set, one word fillers are always black.
-      DCHECK_IMPLIES(object->map(cage_base) ==
-                         ReadOnlyRoots(isolate).one_pointer_filler_map(),
-                     marking_state_->IsMarked(object));
-      // Other fillers may be black or grey depending on the color of the object
-      // that was trimmed.
-      DCHECK_IMPLIES(object->map(cage_base) !=
-                         ReadOnlyRoots(isolate).one_pointer_filler_map(),
-                     marking_state_->IsMarked(object));
-      continue;
-    }
+    // The marking worklist should never contain filler objects.
+    CHECK(!IsFreeSpaceOrFiller(object, cage_base));
     DCHECK(IsHeapObject(object));
     DCHECK(!object.InReadOnlySpace());
     DCHECK_EQ(GetIsolateFromWritableObject(object), isolate);
