commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155
Author: Li Nan <linan122@huawei.com>
Date:   Fri Mar 29 09:23:19 2024 +0800

    block: fix overflow in blk_ioctl_discard()
    
    There is no check for overflow of 'start + len' in blk_ioctl_discard().
    Hung task occurs if submit an discard ioctl with the following param:
      start = 0x80000000000ff000, len = 0x8000000000fff000;
    Add the overflow validation now.
    
    Signed-off-by: Li Nan <linan122@huawei.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20240329012319.2034550-1-linan666@huaweicloud.com
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/block/ioctl.c b/block/ioctl.c
index 0c76137adcaa..a9028a2c2db5 100644
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@ -96,7 +96,7 @@ static int blk_ioctl_discard(struct block_device *bdev, blk_mode_t mode,
 		unsigned long arg)
 {
 	uint64_t range[2];
-	uint64_t start, len;
+	uint64_t start, len, end;
 	struct inode *inode = bdev->bd_inode;
 	int err;
 
@@ -117,7 +117,8 @@ static int blk_ioctl_discard(struct block_device *bdev, blk_mode_t mode,
 	if (len & 511)
 		return -EINVAL;
 
-	if (start + len > bdev_nr_bytes(bdev))
+	if (check_add_overflow(start, len, &end) ||
+	    end > bdev_nr_bytes(bdev))
 		return -EINVAL;
 
 	filemap_invalidate_lock(inode->i_mapping);
