commit dc0a8d8a80e653e13af8ff8cab0bf44b0f0baad0	dc0a8d8a80e653e13af8ff8cab0bf44b0f0baad0
Author: Jack Hsieh <chengweih@chromium.org>
Date:   Mon Mar 13 19:57:29 2023 +0000

    Reject Web USB requests with an opaque origin
    
    The Web USB API tracks permissions using the origin of the top-level
    document in the frame tree. If this document has an opaque origin then
    there is no way to format the origin for display to the user in
    permission prompts or to write their decision in the preferences file.
    
    Access to the Web USB API from such contexts should therefore be
    blocked.
    
    Bug: 1375133
    Change-Id: I47952bb230b3fdf0bfbc76f46d1ef91c19fc7ea1
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4248258
    Reviewed-by: Reilly Grant <reillyg@chromium.org>
    Commit-Queue: Jack Hsieh <chengweih@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1116559}

diff --git a/third_party/blink/renderer/modules/webusb/usb.cc b/third_party/blink/renderer/modules/webusb/usb.cc
index a107b59cf30ac..c9bc3161c3fff 100644
--- a/third_party/blink/renderer/modules/webusb/usb.cc
+++ b/third_party/blink/renderer/modules/webusb/usb.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/notreached.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/device/public/mojom/usb_device.mojom-blink.h"
 #include "services/device/public/mojom/usb_enumeration_options.mojom-blink.h"
@@ -20,6 +21,7 @@
 #include "third_party/blink/renderer/core/execution_context/navigator_base.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
 #include "third_party/blink/renderer/core/frame/local_frame.h"
+#include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 #include "third_party/blink/renderer/modules/event_target_modules.h"
 #include "third_party/blink/renderer/modules/webusb/usb_connection_event.h"
 #include "third_party/blink/renderer/modules/webusb/usb_device.h"
@@ -90,6 +92,76 @@ UsbDeviceFilterPtr ConvertDeviceFilter(const USBDeviceFilter* filter,
   return mojo_filter;
 }
 
+bool IsContextSupported(ExecutionContext* context) {
+  // Since WebUSB on Web Workers is in the process of being implemented, we
+  // check here if the runtime flag for the appropriate worker is enabled.
+  // TODO(https://crbug.com/837406): Remove this check once the feature has
+  // shipped.
+  if (!context) {
+    return false;
+  }
+
+  DCHECK(context->IsWindow() || context->IsDedicatedWorkerGlobalScope() ||
+         context->IsServiceWorkerGlobalScope());
+  DCHECK(!context->IsDedicatedWorkerGlobalScope() ||
+         RuntimeEnabledFeatures::WebUSBOnDedicatedWorkersEnabled());
+  DCHECK(!context->IsServiceWorkerGlobalScope() ||
+         RuntimeEnabledFeatures::WebUSBOnServiceWorkersEnabled());
+
+  return true;
+}
+
+// Carries out basic checks for the web-exposed APIs, to make sure the minimum
+// requirements for them to be served are met. Returns true if any conditions
+// fail to be met, generating an appropriate exception as well. Otherwise,
+// returns false to indicate the call should be allowed.
+bool ShouldBlockUsbServiceCall(LocalDOMWindow* window,
+                               ExecutionContext* context,
+                               ExceptionState* exception_state) {
+  if (!IsContextSupported(context)) {
+    if (exception_state) {
+      exception_state->ThrowDOMException(
+          DOMExceptionCode::kNotSupportedError,
+          "The implementation did not support the requested type of object or "
+          "operation.");
+    }
+    return true;
+  }
+  // For window and dedicated workers, reject the request if the top-level frame
+  // has an opaque origin. For Service Workers, we use their security origin
+  // directly as they do not use delegated permissions.
+  const SecurityOrigin* security_origin = nullptr;
+  if (context->IsWindow()) {
+    security_origin =
+        window->GetFrame()->Top()->GetSecurityContext()->GetSecurityOrigin();
+  } else if (context->IsDedicatedWorkerGlobalScope()) {
+    security_origin = static_cast<WorkerGlobalScope*>(context)
+                          ->top_level_frame_security_origin();
+  } else if (context->IsServiceWorkerGlobalScope()) {
+    security_origin = context->GetSecurityOrigin();
+  } else {
+    NOTREACHED_NORETURN();
+  }
+  if (security_origin->IsOpaque()) {
+    if (exception_state) {
+      exception_state->ThrowSecurityError(
+          "Access to the WebUSB API is denied from contexts where the "
+          "top-level document has an opaque origin.");
+    }
+    return true;
+  }
+
+  if (!context->IsFeatureEnabled(mojom::blink::PermissionsPolicyFeature::kUsb,
+                                 ReportOptions::kReportOnFailure)) {
+    if (exception_state) {
+      exception_state->ThrowSecurityError(kFeaturePolicyBlocked);
+    }
+    return true;
+  }
+
+  return false;
+}
+
 }  // namespace
 
 const char USB::kSupplementName[] = "USB";
@@ -118,16 +190,8 @@ USB::~USB() {
 
 ScriptPromise USB::getDevices(ScriptState* script_state,
                               ExceptionState& exception_state) {
-  if (!IsContextSupported()) {
-    exception_state.ThrowDOMException(
-        DOMExceptionCode::kNotSupportedError,
-        "The implementation did not support the requested type of object or "
-        "operation.");
-    return ScriptPromise();
-  }
-
-  if (!IsFeatureEnabled(ReportOptions::kReportOnFailure)) {
-    exception_state.ThrowSecurityError(kFeaturePolicyBlocked);
+  if (ShouldBlockUsbServiceCall(GetSupplementable()->DomWindow(),
+                                GetExecutionContext(), &exception_state)) {
     return ScriptPromise();
   }
 
@@ -151,8 +215,8 @@ ScriptPromise USB::requestDevice(ScriptState* script_state,
     return ScriptPromise();
   }
 
-  if (!IsFeatureEnabled(ReportOptions::kReportOnFailure)) {
-    exception_state.ThrowSecurityError(kFeaturePolicyBlocked);
+  if (ShouldBlockUsbServiceCall(GetSupplementable()->DomWindow(),
+                                GetExecutionContext(), &exception_state)) {
     return ScriptPromise();
   }
 
@@ -306,8 +370,10 @@ void USB::AddedEventListener(const AtomicString& event_type,
     return;
   }
 
-  if (!IsContextSupported() || !IsFeatureEnabled(ReportOptions::kDoNotReport))
+  if (ShouldBlockUsbServiceCall(GetSupplementable()->DomWindow(),
+                                GetExecutionContext(), nullptr)) {
     return;
+  }
 
   EnsureServiceConnection();
 }
@@ -316,7 +382,7 @@ void USB::EnsureServiceConnection() {
   if (service_.is_bound())
     return;
 
-  DCHECK(IsContextSupported());
+  DCHECK(IsContextSupported(GetExecutionContext()));
   DCHECK(IsFeatureEnabled(ReportOptions::kDoNotReport));
   // See https://bit.ly/2S0zRAS for task types.
   auto task_runner =
@@ -332,25 +398,6 @@ void USB::EnsureServiceConnection() {
       client_receiver_.BindNewEndpointAndPassRemote(task_runner));
 }
 
-bool USB::IsContextSupported() const {
-  // Since WebUSB on Web Workers is in the process of being implemented, we
-  // check here if the runtime flag for the appropriate worker is enabled.
-  // TODO(https://crbug.com/837406): Remove this check once the feature has
-  // shipped.
-  ExecutionContext* context = GetExecutionContext();
-  if (!context)
-    return false;
-
-  DCHECK(context->IsWindow() || context->IsDedicatedWorkerGlobalScope() ||
-         context->IsServiceWorkerGlobalScope());
-  DCHECK(!context->IsDedicatedWorkerGlobalScope() ||
-         RuntimeEnabledFeatures::WebUSBOnDedicatedWorkersEnabled());
-  DCHECK(!context->IsServiceWorkerGlobalScope() ||
-         RuntimeEnabledFeatures::WebUSBOnServiceWorkersEnabled());
-
-  return true;
-}
-
 bool USB::IsFeatureEnabled(ReportOptions report_options) const {
   return GetExecutionContext()->IsFeatureEnabled(
       mojom::blink::PermissionsPolicyFeature::kUsb, report_options);
diff --git a/third_party/blink/renderer/modules/webusb/usb.h b/third_party/blink/renderer/modules/webusb/usb.h
index a807d24de3d99..5431c1e620081 100644
--- a/third_party/blink/renderer/modules/webusb/usb.h
+++ b/third_party/blink/renderer/modules/webusb/usb.h
@@ -91,7 +91,6 @@ class USB final : public EventTargetWithInlineData,
  private:
   void EnsureServiceConnection();
 
-  bool IsContextSupported() const;
   bool IsFeatureEnabled(ReportOptions) const;
 
   HeapMojoRemote<mojom::blink::WebUsbService> service_;
diff --git a/third_party/blink/web_tests/external/wpt/resources/chromium/webusb-child-test.js b/third_party/blink/web_tests/external/wpt/resources/chromium/webusb-child-test.js
index add04fa58250d..21412f66b0a03 100644
--- a/third_party/blink/web_tests/external/wpt/resources/chromium/webusb-child-test.js
+++ b/third_party/blink/web_tests/external/wpt/resources/chromium/webusb-child-test.js
@@ -25,7 +25,14 @@
 
           // Wait for a call to GetDevices() to ensure that the interface
           // handles are forwarded to the parent context.
-          await navigator.usb.getDevices();
+          try {
+            await navigator.usb.getDevices();
+          } catch (e) {
+            // This can happen in case of, for example, testing usb disallowed
+            // iframe.
+            console.error(`getDevices() throws error: ${e.name}: ${e.message}`);
+          }
+
           messageChannel.port1.postMessage({ type: 'Complete' });
         }
       };
diff --git a/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html b/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html
new file mode 100644
index 0000000000000..7cb503ce3c9f6
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script>
+  'use strict';
+
+  promise_test(async (t) => {
+    await promise_rejects_dom(
+        t, 'SecurityError', navigator.usb.getDevices(),
+        'getDevices() should throw a SecurityError DOMException when called ' +
+        'from a context where the top-level document has an opaque origin.');
+  }, 'Calls to USB APIs from an origin with opaque top origin get blocked.');
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html.headers b/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html.headers
new file mode 100644
index 0000000000000..1efcf8c226fac
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/getDevices/reject_opaque_origin.https.html.headers
@@ -0,0 +1 @@
+Content-Security-Policy: sandbox allow-scripts
diff --git a/third_party/blink/web_tests/external/wpt/webusb/getDevices/sandboxed_iframe.https.window.js b/third_party/blink/web_tests/external/wpt/webusb/getDevices/sandboxed_iframe.https.window.js
new file mode 100644
index 0000000000000..60bdf30587efe
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/getDevices/sandboxed_iframe.https.window.js
@@ -0,0 +1,19 @@
+'use strict';
+
+promise_test(async (t) => {
+  let iframe = document.createElement('iframe');
+  await new Promise(resolve => {
+    iframe.src = '../resources/open-in-iframe.html';
+    iframe.sandbox.add('allow-scripts');
+    iframe.allow = 'usb';
+    document.body.appendChild(iframe);
+    iframe.addEventListener('load', resolve);
+  });
+  await new Promise(resolve => {
+    window.addEventListener('message', t.step_func(messageEvent => {
+      assert_equals(messageEvent.data, 'Success');
+      resolve();
+    }));
+    iframe.contentWindow.postMessage('GetDevices', '*');
+  });
+}, 'GetDevices from a sandboxed iframe is valid.');
diff --git a/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html
new file mode 100644
index 0000000000000..34798ce2b1d4c
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html
@@ -0,0 +1,15 @@
+<!DOCTYPE html>
+
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script>
+  'use strict';
+
+  promise_test(async (t) => {
+    await promise_rejects_dom(
+        t, 'SecurityError', navigator.usb.requestDevice({filters:[]}),
+        'requestDevice() should throw a SecurityError DOMException when ' +
+        'called from a context where the top-level document has an opaque ' +
+        'origin.');
+  }, 'Calls to USB APIs from an origin with opaque top origin get blocked.');
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html.headers b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html.headers
new file mode 100644
index 0000000000000..1efcf8c226fac
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/reject_opaque_origin.https.html.headers
@@ -0,0 +1 @@
+Content-Security-Policy: sandbox allow-scripts
diff --git a/third_party/blink/web_tests/external/wpt/webusb/requestDevice/sandboxed_iframe.https.window.js b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/sandboxed_iframe.https.window.js
new file mode 100644
index 0000000000000..b63f409480323
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webusb/requestDevice/sandboxed_iframe.https.window.js
@@ -0,0 +1,24 @@
+'use strict';
+
+promise_test(async (t) => {
+  let iframe = document.createElement('iframe');
+  await new Promise(resolve => {
+    iframe.src = '../resources/open-in-iframe.html';
+    iframe.sandbox.add('allow-scripts');
+    iframe.allow = 'usb';
+    document.body.appendChild(iframe);
+    iframe.addEventListener('load', resolve);
+  });
+  await new Promise(resolve => {
+    window.addEventListener('message', t.step_func(messageEvent => {
+      // The failure message of no device chosen is expected. The point here is
+      // to validate not failing because of a sandboxed iframe.
+      assert_equals(
+          'FAIL: NotFoundError: Failed to execute \'requestDevice\' on ' +
+              '\'USB\': No device selected.',
+          messageEvent.data);
+      resolve();
+    }));
+    iframe.contentWindow.postMessage('RequestDevice', '*');
+  });
+}, 'RequestDevice from a sandboxed iframe is valid.');
diff --git a/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-iframe.html b/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-iframe.html
index 730db24902964..ad0e12d3717dc 100644
--- a/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-iframe.html
+++ b/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-iframe.html
@@ -2,18 +2,41 @@
 <!-- Intentionally use relative paths here because this file is also used by blink/web_tests/usb/usbDevice-iframe.html. -->
 <script src="../../resources/test-only-api.js"></script>
 <script src="usb-helpers.js"></script>
+<script src="/resources/testdriver.js"></script>
+<script src="/resources/testdriver-vendor.js"></script>
+
+<body>
+  <button>Fake user gesture</button>
+</body>
+
 <script>
-'use strict';
-window.onmessage = messageEvent => {
-  if (messageEvent.data === 'Ready') {
-    navigator.usb.addEventListener('connect', connectEvent => {
-      connectEvent.device.open().then(() => {
-        parent.postMessage('Success', '*');
-      }).catch(error => {
-        parent.postMessage('FAIL: open rejected ' + error, '*');
-      });
-    });
-    parent.postMessage('Ready', '*');
-  }
-};
+  'use strict';
+  test_driver.set_test_context(parent);
+  window.onmessage = messageEvent => {
+    switch (messageEvent.data) {
+      case 'ConnectEvent':
+        navigator.usb.addEventListener('connect', connectEvent => {
+          connectEvent.device.open()
+              .then(() => parent.postMessage('Success', '*'))
+              .catch(err =>
+                  parent.postMessage(`FAIL: open rejected ${err}`, '*'));
+        });
+        parent.postMessage('Ready', '*');
+        break;
+      case 'GetDevices':
+        navigator.usb.getDevices()
+            .then(devices => parent.postMessage('Success', '*'))
+            .catch(err => parent.postMessage(`FAIL: ${err}`, '*'));
+        break;
+      case 'RequestDevice':
+        test_driver.click(document.getElementsByTagName('button')[0])
+            .then(() => navigator.usb.requestDevice({filters: []}))
+            .then(device => parent.postMessage('Success', '*'))
+            .catch(err => parent.postMessage(`FAIL: ${err}`, '*'));
+        break;
+      default:
+        parent.postMessage(
+            `FAIL: Bad message type: ${messageEvent.data}`, '*');
+    }
+  };
 </script>
diff --git a/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-worker.js b/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-worker.js
index e16621057a024..2175cfd39787a 100644
--- a/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-worker.js
+++ b/third_party/blink/web_tests/external/wpt/webusb/resources/open-in-worker.js
@@ -3,7 +3,7 @@ importScripts('/webusb/resources/usb-helpers.js');
 'use strict';
 
 onmessage = messageEvent => {
-  if (messageEvent.data.type === 'Ready') {
+  if (messageEvent.data.type === 'ConnectEvent') {
     navigator.usb.addEventListener('connect', connectEvent => {
       connectEvent.device.open().then(() => {
         postMessage({ type: 'Success' });
diff --git a/third_party/blink/web_tests/external/wpt/webusb/usbDevice-iframe.https.html b/third_party/blink/web_tests/external/wpt/webusb/usbDevice-iframe.https.html
index 5a6dd0565f51e..9e90adedc7c00 100644
--- a/third_party/blink/web_tests/external/wpt/webusb/usbDevice-iframe.https.html
+++ b/third_party/blink/web_tests/external/wpt/webusb/usbDevice-iframe.https.html
@@ -7,6 +7,14 @@
 <script>
 'use strict';
 
+async function sleep(timeout) {
+  return new Promise(resolve => {
+    step_timeout(() => {
+      resolve();
+    }, timeout);
+  });
+}
+
 async function connectInIframe() {
   let iframe = document.createElement('iframe');
   let opened = false;
@@ -19,7 +27,7 @@ async function connectInIframe() {
     return new Promise(resolve => window.addEventListener(
         'message', e => resolve(e.data)));
   }
-  iframe.contentWindow.postMessage('Ready', '*');
+  iframe.contentWindow.postMessage('ConnectEvent', '*');
 
   assert_equals('Ready', (await nextIFrameMessage()));
   let fakeDevice = navigator.usb.test.addFakeDevice(fakeDeviceInit);
@@ -42,4 +50,37 @@ usb_test(async () => {
   iframe.src = 'about:blank';
   await closedPromise;
 }, 'navigating iframe disconnects device.');
+
+usb_test(async (t) => {
+  let iframe = document.createElement('iframe');
+  iframe.src = 'resources/open-in-iframe.html';
+  iframe.allow = 'usb \'none\'';
+
+  await Promise.all([
+    new Promise(resolve => {
+      document.body.appendChild(iframe);
+      iframe.addEventListener('load', resolve);
+    }),
+    // This will wait for ReadyForAttachment event from iframe loading.
+    navigator.usb.test.attachToContext(iframe),
+  ]);
+
+  let messageWatcher = new EventWatcher(t, window, 'message');
+  iframe.contentWindow.postMessage('ConnectEvent', '*');
+  let messageEvent = await messageWatcher.wait_for('message');
+  assert_equals(messageEvent.data, 'Ready');
+
+  // This isn't necessary as the expected scenario shouldn't send any mojo
+  // request. However, in order to capture a bug that doesn't reject adding
+  // event listener, time delay here is to allow mojo request to be intercepted
+  // after iframe adding connect event listener.
+  await sleep(100);
+
+  // If device connect event fires, EventWatcher will assert for an unexpected
+  // event.
+  navigator.usb.test.addFakeDevice(fakeDeviceInit);
+  // Time delay here is to allow event to be fired if any.
+  await sleep(100);
+}, 'Connect event is not fired in iframe with usb disallowed.');
+
 </script>
diff --git a/third_party/blink/web_tests/external/wpt/webusb/usbDevice-worker.https.html b/third_party/blink/web_tests/external/wpt/webusb/usbDevice-worker.https.html
index dcad6ec08ea0d..940120495b60b 100644
--- a/third_party/blink/web_tests/external/wpt/webusb/usbDevice-worker.https.html
+++ b/third_party/blink/web_tests/external/wpt/webusb/usbDevice-worker.https.html
@@ -16,7 +16,7 @@ async function connectInWorker() {
     return new Promise(resolve => worker.addEventListener(
         'message', e => resolve(e.data)));
   }
-  worker.postMessage({ type: 'Ready' });
+  worker.postMessage({ type: 'ConnectEvent' });
 
   assert_equals('Ready', (await nextWorkerMessage()).type);
   let fakeDevice = navigator.usb.test.addFakeDevice(fakeDeviceInit);
diff --git a/third_party/blink/web_tests/wpt_internal/webusb/usbDevice-iframe.https.html b/third_party/blink/web_tests/wpt_internal/webusb/usbDevice-iframe.https.html
index e64fb9e121275..c1b92d9f05e27 100644
--- a/third_party/blink/web_tests/wpt_internal/webusb/usbDevice-iframe.https.html
+++ b/third_party/blink/web_tests/wpt_internal/webusb/usbDevice-iframe.https.html
@@ -45,7 +45,7 @@ usb_test(() => {
         }
       };
 
-      iframe.contentWindow.postMessage('Ready', '*');
+      iframe.contentWindow.postMessage('ConnectEvent', '*');
     });
   });
 }, 'events are not delivered to detached frames');
