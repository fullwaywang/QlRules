commit ab66c0409aece5bd57511792a3867920f31c589b	ab66c0409aece5bd57511792a3867920f31c589b
Author: Benoit Lize <lizeb@chromium.org>
Date:   Wed Mar 15 15:04:17 2023 +0000

    [blink/bindings] Take encoding into account for ParkableString hashing
    
    Hashing is used for string deduplication, must take encoding into
    account. See linked bug for details.
    
    Bug: 1418224
    Change-Id: I63c024d0a97e44b1f3323cd1ca4d9e953c2beed1
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4328136
    Commit-Queue: Benoit Lize <lizeb@chromium.org>
    Reviewed-by: Kentaro Hara <haraken@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1117528}

diff --git a/third_party/blink/renderer/core/loader/resource/resource_loader_code_cache_test.cc b/third_party/blink/renderer/core/loader/resource/resource_loader_code_cache_test.cc
index f01c55633108a..4e8752ea53e73 100644
--- a/third_party/blink/renderer/core/loader/resource/resource_loader_code_cache_test.cc
+++ b/third_party/blink/renderer/core/loader/resource/resource_loader_code_cache_test.cc
@@ -106,12 +106,10 @@ class ResourceLoaderCodeCacheTest : public testing::Test {
     std::vector<uint8_t> serialized_data(kSerializedDataSize);
     *reinterpret_cast<uint32_t*>(&serialized_data[0]) = outer_type;
     if (source_text.has_value()) {
-      DigestValue hash;
-      CHECK(ComputeDigest(kHashAlgorithmSha256,
-                          static_cast<const char*>(source_text->Bytes()),
-                          source_text->CharactersSizeInBytes(), hash));
-      CHECK_EQ(hash.size(), kSha256Bytes);
-      memcpy(&serialized_data[kCachedMetadataTypeSize], hash.data(),
+      std::unique_ptr<ParkableStringImpl::SecureDigest> hash =
+          ParkableStringImpl::HashString(source_text->Impl());
+      CHECK_EQ(hash->size(), kSha256Bytes);
+      memcpy(&serialized_data[kCachedMetadataTypeSize], hash->data(),
              kSha256Bytes);
     }
     *reinterpret_cast<uint32_t*>(
@@ -264,6 +262,7 @@ TEST_F(ResourceLoaderCodeCacheTest, WebUICodeCacheHashCheckSuccess) {
   // Now the metadata can be accessed.
   scoped_refptr<CachedMetadata> cached_metadata =
       resource_->CacheHandler()->GetCachedMetadata(0);
+  EXPECT_TRUE(cached_metadata.get());
   EXPECT_EQ(cached_metadata->size(), cache_data.size());
   EXPECT_EQ(*(cached_metadata->Data() + 2), cache_data[2]);
 
diff --git a/third_party/blink/renderer/platform/bindings/parkable_string.cc b/third_party/blink/renderer/platform/bindings/parkable_string.cc
index e1f96c9ddb908..7062721ff6122 100644
--- a/third_party/blink/renderer/platform/bindings/parkable_string.cc
+++ b/third_party/blink/renderer/platform/bindings/parkable_string.cc
@@ -4,6 +4,8 @@
 
 #include "third_party/blink/renderer/platform/bindings/parkable_string.h"
 
+#include <array>
+
 #include "base/allocator/partition_allocator/oom.h"
 #include "base/allocator/partition_allocator/partition_alloc.h"
 #include "base/check_op.h"
@@ -229,18 +231,26 @@ ParkableStringImpl::ParkableMetadata::ParkableMetadata(
       is_8bit_(string.Is8Bit()),
       length_(string.length()) {}
 
-// static
+// static2
 std::unique_ptr<ParkableStringImpl::SecureDigest>
 ParkableStringImpl::HashString(StringImpl* string) {
   DigestValue digest_result;
-  bool ok = ComputeDigest(kHashAlgorithmSha256,
-                          static_cast<const char*>(string->Bytes()),
-                          string->CharactersSizeInBytes(), digest_result);
+
+  Digestor digestor(kHashAlgorithmSha256);
+  digestor.Update(base::make_span(static_cast<const uint8_t*>(string->Bytes()),
+                                  string->CharactersSizeInBytes()));
+  // Also include encoding in the digest, otherwise two strings with identical
+  // byte content but different encoding will be assumed equal, leading to
+  // crashes when one is replaced by the other one.
+  std::array<uint8_t, 1> is_8bit;
+  is_8bit[0] = string->Is8Bit();
+  digestor.Update(is_8bit);
+  digestor.Finish(digest_result);
 
   // The only case where this can return false in BoringSSL is an allocation
   // failure of the temporary data required for hashing. In this case, there
   // is nothing better to do than crashing.
-  if (!ok) {
+  if (digestor.has_failed()) {
     // Don't know the exact size, the SHA256 spec hints at ~64 (block size)
     // + 32 (digest) bytes.
     base::TerminateBecauseOutOfMemory(64 + kDigestSize);
diff --git a/third_party/blink/renderer/platform/bindings/parkable_string.h b/third_party/blink/renderer/platform/bindings/parkable_string.h
index 12a8f3014126e..ee022592af6e6 100644
--- a/third_party/blink/renderer/platform/bindings/parkable_string.h
+++ b/third_party/blink/renderer/platform/bindings/parkable_string.h
@@ -54,6 +54,9 @@ class PLATFORM_EXPORT ParkableStringImpl
   constexpr static size_t kDigestSize = 32;  // SHA256.
   using SecureDigest = Vector<uint8_t, kDigestSize>;
   // Computes a secure hash of a |string|, to be passed to |MakeParkable()|.
+  //
+  // TODO(lizeb): This is the "right" way of hashing a string. Move this code
+  // into WTF, and make sure it's the only way that is used.
   static std::unique_ptr<SecureDigest> HashString(StringImpl* string);
 
   // Not all ParkableStringImpls are actually parkable.
diff --git a/third_party/blink/renderer/platform/bindings/parkable_string_test.cc b/third_party/blink/renderer/platform/bindings/parkable_string_test.cc
index 29a5497cd3f83..8a0719c88e9c6 100644
--- a/third_party/blink/renderer/platform/bindings/parkable_string_test.cc
+++ b/third_party/blink/renderer/platform/bindings/parkable_string_test.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <algorithm>
+#include <cstring>
 #include <limits>
 
 #include "base/functional/bind.h"
@@ -1322,6 +1323,36 @@ TEST_P(ParkableStringTest, ReportTotalDiskTime) {
       1);
 }
 
+TEST_P(ParkableStringTest, EncodingAndDeduplication) {
+  size_t size_in_chars = 2 * kSizeKb * 1000 / sizeof(UChar);
+  Vector<UChar> data_16(size_in_chars);
+  for (size_t i = 0; i < size_in_chars; ++i) {
+    data_16[i] = 0x2020;
+  }
+  String large_string_16 = String(&data_16[0], size_in_chars);
+
+  ParkableString parkable_16(large_string_16.Impl());
+  ASSERT_TRUE(parkable_16.Impl()->digest());
+  ASSERT_TRUE(parkable_16.may_be_parked());
+
+  Vector<LChar> data_8(2 * size_in_chars);
+  for (size_t i = 0; i < 2 * size_in_chars; ++i) {
+    data_8[i] = 0x20;
+  }
+  String large_string_8 = String(&data_8[0], 2 * size_in_chars);
+
+  ParkableString parkable_8(large_string_8.Impl());
+  ASSERT_TRUE(parkable_8.Impl()->digest());
+  ASSERT_TRUE(parkable_8.may_be_parked());
+
+  // Same content, but the hash must be differnt because the encoding is.
+  EXPECT_EQ(0, memcmp(large_string_16.Bytes(), large_string_8.Bytes(),
+                      large_string_8.CharactersSizeInBytes()));
+  EXPECT_EQ(parkable_16.CharactersSizeInBytes(),
+            parkable_8.CharactersSizeInBytes());
+  EXPECT_NE(*parkable_16.Impl()->digest(), *parkable_8.Impl()->digest());
+}
+
 class ParkableStringTestWithQueuedThreadPool : public ParkableStringTest {
  public:
   ParkableStringTestWithQueuedThreadPool()
