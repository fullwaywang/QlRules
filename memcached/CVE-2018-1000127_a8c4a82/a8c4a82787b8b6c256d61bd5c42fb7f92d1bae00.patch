commit a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00	a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00
Author: dormando <dormando@rydia.net>
Date:   Sun May 21 21:49:54 2017 -0700

    Don't overflow item refcount on get
    
    Counts as a miss if the refcount is too high. ASCII multigets are the only
    time refcounts can be held for so long.
    
    doing a dirty read of refcount. is aligned.
    
    trying to avoid adding an extra refcount branch for all calls of item_get due
    to performance. might be able to move it in there after logging refactoring
    simplifies some of the branches.

diff --git a/memcached.c b/memcached.c
index d0533c5..044064f 100644
--- a/memcached.c
+++ b/memcached.c
@@ -3249,6 +3249,16 @@ static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas)
     return (p - suffix) + 2;
 }
 
+#define IT_REFCOUNT_LIMIT 60000
+static inline item* limited_get(char *key, size_t nkey, conn *c) {
+    item *it = item_get(key, nkey, c, DO_UPDATE);
+    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
+        item_remove(it);
+        it = NULL;
+    }
+    return it;
+}
+
 /* ntokens is overwritten here... shrug.. */
 static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
     char *key;
@@ -3273,7 +3283,7 @@ static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,
                 return;
             }
 
-            it = item_get(key, nkey, c, DO_UPDATE);
+            it = limited_get(key, nkey, c);
             if (settings.detail_enabled) {
                 stats_prefix_record_get(key, nkey, NULL != it);
             }
