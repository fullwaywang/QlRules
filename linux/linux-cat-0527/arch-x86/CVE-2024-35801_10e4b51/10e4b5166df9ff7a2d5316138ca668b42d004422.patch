commit 10e4b5166df9ff7a2d5316138ca668b42d004422
Author: Adamos Ttofari <attofari@amazon.de>
Date:   Fri Mar 22 16:04:39 2024 -0700

    x86/fpu: Keep xfd_state in sync with MSR_IA32_XFD
    
    Commit 672365477ae8 ("x86/fpu: Update XFD state where required") and
    commit 8bf26758ca96 ("x86/fpu: Add XFD state to fpstate") introduced a
    per CPU variable xfd_state to keep the MSR_IA32_XFD value cached, in
    order to avoid unnecessary writes to the MSR.
    
    On CPU hotplug MSR_IA32_XFD is reset to the init_fpstate.xfd, which
    wipes out any stale state. But the per CPU cached xfd value is not
    reset, which brings them out of sync.
    
    As a consequence a subsequent xfd_update_state() might fail to update
    the MSR which in turn can result in XRSTOR raising a #NM in kernel
    space, which crashes the kernel.
    
    To fix this, introduce xfd_set_state() to write xfd_state together
    with MSR_IA32_XFD, and use it in all places that set MSR_IA32_XFD.
    
    Fixes: 672365477ae8 ("x86/fpu: Update XFD state where required")
    Signed-off-by: Adamos Ttofari <attofari@amazon.de>
    Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20240322230439.456571-1-chang.seok.bae@intel.com
    
    Closes: https://lore.kernel.org/lkml/20230511152818.13839-1-attofari@amazon.de

diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index 117e74c44e75..33a214b1a4ce 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -178,10 +178,11 @@ void fpu__init_cpu_xstate(void)
 	 * Must happen after CR4 setup and before xsetbv() to allow KVM
 	 * lazy passthrough.  Write independent of the dynamic state static
 	 * key as that does not work on the boot CPU. This also ensures
-	 * that any stale state is wiped out from XFD.
+	 * that any stale state is wiped out from XFD. Reset the per CPU
+	 * xfd cache too.
 	 */
 	if (cpu_feature_enabled(X86_FEATURE_XFD))
-		wrmsrl(MSR_IA32_XFD, init_fpstate.xfd);
+		xfd_set_state(init_fpstate.xfd);
 
 	/*
 	 * XCR_XFEATURE_ENABLED_MASK (aka. XCR0) sets user features
diff --git a/arch/x86/kernel/fpu/xstate.h b/arch/x86/kernel/fpu/xstate.h
index 3518fb26d06b..19ca623ffa2a 100644
--- a/arch/x86/kernel/fpu/xstate.h
+++ b/arch/x86/kernel/fpu/xstate.h
@@ -148,20 +148,26 @@ static inline void xfd_validate_state(struct fpstate *fpstate, u64 mask, bool rs
 #endif
 
 #ifdef CONFIG_X86_64
+static inline void xfd_set_state(u64 xfd)
+{
+	wrmsrl(MSR_IA32_XFD, xfd);
+	__this_cpu_write(xfd_state, xfd);
+}
+
 static inline void xfd_update_state(struct fpstate *fpstate)
 {
 	if (fpu_state_size_dynamic()) {
 		u64 xfd = fpstate->xfd;
 
-		if (__this_cpu_read(xfd_state) != xfd) {
-			wrmsrl(MSR_IA32_XFD, xfd);
-			__this_cpu_write(xfd_state, xfd);
-		}
+		if (__this_cpu_read(xfd_state) != xfd)
+			xfd_set_state(xfd);
 	}
 }
 
 extern int __xfd_enable_feature(u64 which, struct fpu_guest *guest_fpu);
 #else
+static inline void xfd_set_state(u64 xfd) { }
+
 static inline void xfd_update_state(struct fpstate *fpstate) { }
 
 static inline int __xfd_enable_feature(u64 which, struct fpu_guest *guest_fpu) {
