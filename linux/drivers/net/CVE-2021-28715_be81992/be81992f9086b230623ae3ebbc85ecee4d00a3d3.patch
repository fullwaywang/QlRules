commit be81992f9086b230623ae3ebbc85ecee4d00a3d3
Author: Juergen Gross <jgross@suse.com>
Date:   Tue Nov 30 08:36:12 2021 +0100

    xen/netback: don't queue unlimited number of packages
    
    In case a guest isn't consuming incoming network traffic as fast as it
    is coming in, xen-netback is buffering network packages in unlimited
    numbers today. This can result in host OOM situations.
    
    Commit f48da8b14d04ca8 ("xen-netback: fix unlimited guest Rx internal
    queue and carrier flapping") meant to introduce a mechanism to limit
    the amount of buffered data by stopping the Tx queue when reaching the
    data limit, but this doesn't work for cases like UDP.
    
    When hitting the limit don't queue further SKBs, but drop them instead.
    In order to be able to tell Rx packages have been dropped increment the
    rx_dropped statistics counter in this case.
    
    It should be noted that the old solution to continue queueing SKBs had
    the additional problem of an overflow of the 32-bit rx_queue_len value
    would result in intermittent Tx queue enabling.
    
    This is part of XSA-392
    
    Fixes: f48da8b14d04ca8 ("xen-netback: fix unlimited guest Rx internal queue and carrier flapping")
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>

diff --git a/drivers/net/xen-netback/rx.c b/drivers/net/xen-netback/rx.c
index a8511e27d6c1..dbac4c03d21a 100644
--- a/drivers/net/xen-netback/rx.c
+++ b/drivers/net/xen-netback/rx.c
@@ -88,16 +88,19 @@ void xenvif_rx_queue_tail(struct xenvif_queue *queue, struct sk_buff *skb)
 
 	spin_lock_irqsave(&queue->rx_queue.lock, flags);
 
-	if (skb_queue_empty(&queue->rx_queue))
-		xenvif_update_needed_slots(queue, skb);
-
-	__skb_queue_tail(&queue->rx_queue, skb);
-
-	queue->rx_queue_len += skb->len;
-	if (queue->rx_queue_len > queue->rx_queue_max) {
+	if (queue->rx_queue_len >= queue->rx_queue_max) {
 		struct net_device *dev = queue->vif->dev;
 
 		netif_tx_stop_queue(netdev_get_tx_queue(dev, queue->id));
+		kfree_skb(skb);
+		queue->vif->dev->stats.rx_dropped++;
+	} else {
+		if (skb_queue_empty(&queue->rx_queue))
+			xenvif_update_needed_slots(queue, skb);
+
+		__skb_queue_tail(&queue->rx_queue, skb);
+
+		queue->rx_queue_len += skb->len;
 	}
 
 	spin_unlock_irqrestore(&queue->rx_queue.lock, flags);
@@ -147,6 +150,7 @@ static void xenvif_rx_queue_drop_expired(struct xenvif_queue *queue)
 			break;
 		xenvif_rx_dequeue(queue);
 		kfree_skb(skb);
+		queue->vif->dev->stats.rx_dropped++;
 	}
 }
 
