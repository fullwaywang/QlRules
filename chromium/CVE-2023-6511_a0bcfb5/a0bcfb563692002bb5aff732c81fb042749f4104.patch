commit a0bcfb563692002bb5aff732c81fb042749f4104	a0bcfb563692002bb5aff732c81fb042749f4104
Author: Jan Keitel <jkeitel@google.com>
Date:   Fri Oct 6 06:54:01 2023 +0000

    Add support for suppressing custom cursors across all browser windows.
    
    Custom cursors (in particular large custom images) set via CSS by a
    web page can obscure elements in other browser windows if the
    browser windows are positioned on top of each other. In those cases,
    calling WebContents::CreateDisallowCustomCursorScope for the currently
    focused WebContents is not sufficient to block custom cursors.
    
    This CL adds a helper class to disallow custom cursor across all active
    WebContents of all browser windows. Its current only use case is
    Autofill popups, which is why the helper class is placed there. Should
    it turn out to be needed elsewhere, it can still be moved.
    
    One-pager (design discussions there, please):
    go/disallow-custom-cursors-across-windows
    
    Bug: 1478613
    Change-Id: Iab45831799e037d626bf3ecc9f5f51fc7cf2656a
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4874027
    Reviewed-by: Ken Buchanan <kenrb@chromium.org>
    Reviewed-by: Dana Fried <dfried@chromium.org>
    Commit-Queue: Jan Keitel <jkeitel@google.com>
    Cr-Commit-Position: refs/heads/main@{#1206256}

diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 47fb7debb2c4a..7c2a5967a4bcd 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -4803,6 +4803,8 @@ static_library("ui") {
       "views/autofill/payments/virtual_card_manual_fallback_bubble_views.h",
       "views/autofill/payments/virtual_card_manual_fallback_icon_view.cc",
       "views/autofill/payments/virtual_card_manual_fallback_icon_view.h",
+      "views/autofill/popup/custom_cursor_suppressor.cc",
+      "views/autofill/popup/custom_cursor_suppressor.h",
       "views/autofill/popup/popup_base_view.cc",
       "views/autofill/popup/popup_base_view.h",
       "views/autofill/popup/popup_cell_utils.cc",
diff --git a/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.cc b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.cc
new file mode 100644
index 0000000000000..5449de6bc8c20
--- /dev/null
+++ b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.cc
@@ -0,0 +1,81 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.h"
+
+#include <vector>
+
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "content/public/browser/global_routing_id.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/web_contents.h"
+
+CustomCursorSuppressor::CustomCursorSuppressor() = default;
+
+CustomCursorSuppressor::~CustomCursorSuppressor() = default;
+
+void CustomCursorSuppressor::Start(int max_dimension_dips) {
+  max_dimension_dips_ = max_dimension_dips;
+
+  // Observe the list of browsers.
+  browser_list_observation_.Observe(BrowserList::GetInstance());
+  // Observe all TabStripModels of existing browsers and suppress custom cursors
+  // on their active tabs.
+  for (Browser* browser : *BrowserList::GetInstance()) {
+    browser->tab_strip_model()->AddObserver(this);
+    if (content::WebContents* active_contents =
+            browser->tab_strip_model()->GetActiveWebContents()) {
+      SuppressForWebContents(*active_contents);
+    }
+  }
+}
+
+void CustomCursorSuppressor::Stop() {
+  disallow_custom_cursor_scopes_.clear();
+  TabStripModelObserver::StopObservingAll(this);
+  browser_list_observation_.Reset();
+}
+
+bool CustomCursorSuppressor::IsSuppressing() const {
+  return browser_list_observation_.IsObserving();
+}
+
+std::vector<content::GlobalRenderFrameHostId>
+CustomCursorSuppressor::SuppressedRenderFrameHostIdsForTesting() const {
+  std::vector<content::GlobalRenderFrameHostId> rfh_ids;
+  for (const auto& [rfh_id, scope] : disallow_custom_cursor_scopes_) {
+    rfh_ids.push_back(rfh_id);
+  }
+  return rfh_ids;
+}
+
+void CustomCursorSuppressor::SuppressForWebContents(
+    content::WebContents& web_contents) {
+  content::GlobalRenderFrameHostId main_frame_id =
+      web_contents.GetPrimaryMainFrame()->GetGlobalId();
+  if (disallow_custom_cursor_scopes_.contains(main_frame_id)) {
+    return;
+  }
+  disallow_custom_cursor_scopes_.insert(
+      {main_frame_id,
+       web_contents.CreateDisallowCustomCursorScope(max_dimension_dips_)});
+  // TODO(crbug.com/1478613): Start observing the WebContents at this point to
+  // guard against navigations in it that cause a change in the RFH of the
+  // primary main frame.
+}
+
+void CustomCursorSuppressor::OnBrowserAdded(Browser* browser) {
+  browser->tab_strip_model()->AddObserver(this);
+}
+
+void CustomCursorSuppressor::OnTabStripModelChanged(
+    TabStripModel* tab_strip_model,
+    const TabStripModelChange& change,
+    const TabStripSelectionChange& selection) {
+  if (selection.active_tab_changed() && selection.new_contents) {
+    SuppressForWebContents(*selection.new_contents);
+  }
+}
diff --git a/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.h b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.h
new file mode 100644
index 0000000000000..4b0b53a3f0590
--- /dev/null
+++ b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.h
@@ -0,0 +1,74 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_AUTOFILL_POPUP_CUSTOM_CURSOR_SUPPRESSOR_H_
+#define CHROME_BROWSER_UI_VIEWS_AUTOFILL_POPUP_CUSTOM_CURSOR_SUPPRESSOR_H_
+
+#include <map>
+#include <vector>
+
+#include "base/functional/callback_helpers.h"
+#include "base/scoped_observation.h"
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/browser/ui/browser_list_observer.h"
+#include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
+#include "content/public/browser/global_routing_id.h"
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+// While active, it suppresses custom cursors exceeding a given size limit on
+// all the active `WebContents` or all `Browser`s of the current profile.
+class CustomCursorSuppressor : public BrowserListObserver,
+                               public TabStripModelObserver {
+ public:
+  CustomCursorSuppressor();
+  CustomCursorSuppressor(const CustomCursorSuppressor&) = delete;
+  CustomCursorSuppressor(CustomCursorSuppressor&&) = delete;
+  CustomCursorSuppressor& operator=(const CustomCursorSuppressor&) = delete;
+  CustomCursorSuppressor& operator=(CustomCursorSuppressor&&) = delete;
+  ~CustomCursorSuppressor() override;
+
+  // Starts suppressing cursors with height or width >= `max_dimension_dips` on
+  // all active tabs of all browser windows.
+  void Start(int max_dimension_dips = 0);
+  // Stops suppressing custom cursors.
+  void Stop();
+  bool IsSuppressing() const;
+
+  // Returns the ids of `RenderFrameHost`s on which custom cursors are
+  // suppressed. Note that not every id needs to correspond to an active
+  // `RenderFrameHost` - some may already have been deleted.
+  std::vector<content::GlobalRenderFrameHostId>
+  SuppressedRenderFrameHostIdsForTesting() const;
+
+ private:
+  // Disallows custom cursors beyond the permitted size on `web_contents`. If
+  // `this` is already disallowing custom cursors on `web_contents`, this is a
+  // no-op.
+  void SuppressForWebContents(content::WebContents& web_contents);
+
+  // BrowserListObserver:
+  // Starts observing the tab strip model of `browser`. Note that there is
+  // no corresponding `OnBrowserRemoved`, since `TabStripModelObserver`
+  // already handles model destruction itself.
+  void OnBrowserAdded(Browser* browser) override;
+
+  // TabStripModelObserver:
+  void OnTabStripModelChanged(
+      TabStripModel* tab_strip_model,
+      const TabStripModelChange& change,
+      const TabStripSelectionChange& selection) override;
+
+  base::ScopedObservation<BrowserList, BrowserListObserver>
+      browser_list_observation_{this};
+
+  int max_dimension_dips_ = 0;
+
+  std::map<content::GlobalRenderFrameHostId, base::ScopedClosureRunner>
+      disallow_custom_cursor_scopes_;
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_AUTOFILL_POPUP_CUSTOM_CURSOR_SUPPRESSOR_H_
diff --git a/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor_unittest.cc b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor_unittest.cc
new file mode 100644
index 0000000000000..6055b44900cd3
--- /dev/null
+++ b/chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor_unittest.cc
@@ -0,0 +1,211 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/autofill/popup/custom_cursor_suppressor.h"
+
+#include <memory>
+#include <string_view>
+#include <vector>
+
+#include "chrome/browser/ui/browser_navigator.h"
+#include "chrome/browser/ui/browser_navigator_params.h"
+#include "chrome/test/base/browser_with_test_window_test.h"
+#include "content/public/browser/global_routing_id.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/ui_base_types.h"
+#include "url/gurl.h"
+
+namespace {
+
+using ::content::GlobalRenderFrameHostId;
+using ::testing::SizeIs;
+using ::testing::UnorderedElementsAre;
+using ::testing::UnorderedElementsAreArray;
+
+constexpr std::string_view kUrl1 = "https://www.foo.com";
+constexpr std::string_view kUrl2 = "https://www.bar.com";
+constexpr std::string_view kUrl3 = "https://www.doe.com";
+
+}  // namespace
+
+class CustomCursorSuppressorTest : public BrowserWithTestWindowTest {
+ public:
+  CustomCursorSuppressorTest() = default;
+  ~CustomCursorSuppressorTest() override = default;
+
+  void AddBackgroundTab(Browser* browser, const GURL& url) {
+    NavigateParams params(browser, url, ui::PAGE_TRANSITION_TYPED);
+    params.tabstrip_index = 0;
+    params.disposition = WindowOpenDisposition::NEW_BACKGROUND_TAB;
+    Navigate(&params);
+    CommitPendingLoad(&params.navigated_or_inserted_contents->GetController());
+  }
+
+  GlobalRenderFrameHostId GetRfhIdOfActiveWebContents(Browser& browser) {
+    return browser.tab_strip_model()
+        ->GetActiveWebContents()
+        ->GetPrimaryMainFrame()
+        ->GetGlobalId();
+  }
+};
+
+// Tests that custom cursor suppression works for a single browser window with a
+// single tab.
+TEST_F(CustomCursorSuppressorTest, SingleBrowserSingleTab) {
+  AddTab(browser(), GURL(kUrl1));
+
+  CustomCursorSuppressor suppressor;
+  EXPECT_FALSE(suppressor.IsSuppressing());
+
+  suppressor.Start();
+  EXPECT_TRUE(suppressor.IsSuppressing());
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser())));
+
+  suppressor.Stop();
+  EXPECT_FALSE(suppressor.IsSuppressing());
+}
+
+// Tests that custom cursor suppression reacts to active tab changes in a single
+// browser window.
+TEST_F(CustomCursorSuppressorTest, SingleBrowserWithTabChange) {
+  AddTab(browser(), GURL(kUrl1));
+  AddTab(browser(), GURL(kUrl2));
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl2));
+
+  CustomCursorSuppressor suppressor;
+  suppressor.Start();
+
+  std::vector<GlobalRenderFrameHostId> expected_suppressed_ids = {
+      GetRfhIdOfActiveWebContents(*browser())};
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAreArray(expected_suppressed_ids));
+
+  // Activating the tab with `kUrl1` (now at index 1) adds a new suppression
+  // scope.
+  browser()->tab_strip_model()->ActivateTabAt(1);
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl1));
+  expected_suppressed_ids.push_back(GetRfhIdOfActiveWebContents(*browser()));
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAreArray(expected_suppressed_ids));
+
+  // Switching back to the previously focused tab does not add another
+  // suppression scope, since one already exists.
+  browser()->tab_strip_model()->ActivateTabAt(0);
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl2));
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAreArray(expected_suppressed_ids));
+}
+
+// Tests that custom cursor suppression reacts to new foreground tabs that are
+// added to a single browser window.
+TEST_F(CustomCursorSuppressorTest, SingleBrowserWithForegroundTabAddition) {
+  AddTab(browser(), GURL(kUrl1));
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl1));
+
+  CustomCursorSuppressor suppressor;
+  suppressor.Start();
+  std::vector<GlobalRenderFrameHostId> expected_suppressed_ids = {
+      GetRfhIdOfActiveWebContents(*browser())};
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAreArray(expected_suppressed_ids));
+
+  // Adding a new tab adds a new suppression scope.
+  AddTab(browser(), GURL(kUrl2));
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl2));
+  expected_suppressed_ids.push_back(GetRfhIdOfActiveWebContents(*browser()));
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAreArray(expected_suppressed_ids));
+}
+
+// Tests that custom cursor suppression does not react to a tab that is added to
+// the background.
+TEST_F(CustomCursorSuppressorTest, SingleBrowserWithBackgroundTabAddition) {
+  AddTab(browser(), GURL(kUrl1));
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl1));
+
+  CustomCursorSuppressor suppressor;
+  suppressor.Start();
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser())));
+
+  // Adding a new background tab does not lead to a new suppression scope.
+  AddBackgroundTab(browser(), GURL(kUrl2));
+  ASSERT_THAT(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetVisibleURL(),
+      GURL(kUrl1));
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser())));
+}
+
+// Tests that custom cursor suppression scopes are created for all active tabs
+// in all active browser windows.
+TEST_F(CustomCursorSuppressorTest, MultipleBrowsers) {
+  AddTab(browser(), GURL(kUrl1));
+  AddTab(browser(), GURL(kUrl2));
+  std::vector<GlobalRenderFrameHostId> expected_suppressed_ids = {
+      GetRfhIdOfActiveWebContents(*browser())};
+
+  // Set up a second browser window.
+  Browser::CreateParams native_params(profile(), true);
+  native_params.initial_show_state = ui::SHOW_STATE_NORMAL;
+  std::unique_ptr<Browser> browser2(
+      CreateBrowserWithTestWindowForParams(native_params));
+  ASSERT_THAT(*BrowserList::GetInstance(), SizeIs(2));
+  AddTab(browser2.get(), GURL(kUrl3));
+
+  CustomCursorSuppressor suppressor;
+  suppressor.Start();
+  EXPECT_TRUE(suppressor.IsSuppressing());
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser()),
+                                   GetRfhIdOfActiveWebContents(*browser2)));
+
+  // All tabs must be closed prior to browser destruction.
+  browser2->tab_strip_model()->CloseAllTabs();
+}
+
+// Tests that a new custom cursor suppression scope is created on browser window
+// creation.
+TEST_F(CustomCursorSuppressorTest, BrowserAddition) {
+  AddTab(browser(), GURL(kUrl1));
+  std::vector<GlobalRenderFrameHostId> expected_suppressed_ids = {
+      GetRfhIdOfActiveWebContents(*browser())};
+
+  CustomCursorSuppressor suppressor;
+  suppressor.Start();
+  EXPECT_TRUE(suppressor.IsSuppressing());
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser())));
+
+  // Open a second browser window while the suppression is already on.
+  Browser::CreateParams native_params(profile(), true);
+  native_params.initial_show_state = ui::SHOW_STATE_NORMAL;
+  std::unique_ptr<Browser> browser2(
+      CreateBrowserWithTestWindowForParams(native_params));
+  ASSERT_THAT(*BrowserList::GetInstance(), SizeIs(2));
+  AddTab(browser2.get(), GURL(kUrl2));
+  EXPECT_THAT(suppressor.SuppressedRenderFrameHostIdsForTesting(),
+              UnorderedElementsAre(GetRfhIdOfActiveWebContents(*browser()),
+                                   GetRfhIdOfActiveWebContents(*browser2)));
+
+  suppressor.Stop();
+  EXPECT_FALSE(suppressor.IsSuppressing());
+
+  // All tabs must be closed prior to browser destruction.
+  browser2->tab_strip_model()->CloseAllTabs();
+}
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 233722c06e7e8..7fc4e5abb25db 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -9579,6 +9579,7 @@ test("unit_tests") {
       "../browser/ui/views/accelerator_table_unittest.cc",
       "../browser/ui/views/apps/app_info_dialog/app_info_dialog_views_unittest.cc",
       "../browser/ui/views/apps/app_info_dialog/app_info_permissions_panel_unittest.cc",
+      "../browser/ui/views/autofill/popup/custom_cursor_suppressor_unittest.cc",
       "../browser/ui/views/autofill/popup/popup_cell_view_unittest.cc",
       "../browser/ui/views/autofill/popup/popup_cell_with_button_view_unittest.cc",
       "../browser/ui/views/autofill/popup/popup_row_strategy_unittest.cc",
