commit ee7cb4e461c1cdf0ac14817b03687d5908b85f84
Author: Pietro Cerutti (@gahr) <gahr@gahr.ch>
Date:   Wed Apr 13 12:21:34 2022 +0000

    Fix uudecode buffer overflow
    
    mutt_decode_uuencoded() used each line's initial "length character"
    without any validation.  It would happily read past the end of the
    input line, and with a suitable value even past the length of the
    input buffer.
    
    As I noted in ticket 404, there are several other changes that could
    be added to make the parser more robust.  However, to avoid
    accidentally introducing another bug or regression, I'm restricting
    this patch to simply addressing the overflow.
    
    Thanks to Tavis Ormandy for reporting the issue, along with a sample
    message demonstrating the problem.
    
    Upstream-commit: https://gitlab.com/muttmua/mutt/commit/e5ed080c00e59701ca62ef9b2a6d2612ebf765a5
    
    Co-authored-by: Kevin McCarthy <kevin@8t8.us>

diff --git a/handler.c b/handler.c
index 8b0a54063..78bef1788 100644
--- a/handler.c
+++ b/handler.c
@@ -390,9 +390,9 @@ static void decode_uuencoded(struct State *s, long len, bool istext, iconv_t cd)
     pt = tmps;
     const unsigned char linelen = decode_byte(*pt);
     pt++;
-    for (unsigned char c = 0; c < linelen;)
+    for (unsigned char c = 0; (c < linelen) && *pt;)
     {
-      for (char l = 2; l <= 6; l += 2)
+      for (char l = 2; (l <= 6) && pt[0] && pt[1]; l += 2)
       {
         char out = decode_byte(*pt) << l;
         pt++;
