commit 9bfe5ded054b8e28a94c78580f233d6879a00146
Author: Michal Hocko <mhocko@suse.com>
Date:   Fri Aug 17 15:49:04 2018 -0700

    mm, oom: remove sleep from under oom_lock
    
    Tetsuo has pointed out that since 27ae357fa82b ("mm, oom: fix concurrent
    munlock and oom reaper unmap, v3") we have a strong synchronization
    between the oom_killer and victim's exiting because both have to take
    the oom_lock.  Therefore the original heuristic to sleep for a short
    time in out_of_memory doesn't serve the original purpose.
    
    Moreover Tetsuo has noticed that the short sleep can be more harmful
    than actually useful.  Hammering the system with many processes can lead
    to a starvation when the task holding the oom_lock can block for a long
    time (minutes) and block any further progress because the oom_reaper
    depends on the oom_lock as well.
    
    Drop the short sleep from out_of_memory when we hold the lock.  Keep the
    sleep when the trylock fails to throttle the concurrent OOM paths a bit.
    This should be solved in a more reasonable way (e.g.  sleep proportional
    to the time spent in the active reclaiming etc.) but this is much more
    complex thing to achieve.  This is a quick fixup to remove a stale code.
    
    Link: http://lkml.kernel.org/r/20180709074706.30635-1-mhocko@kernel.org
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: David Rientjes <rientjes@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 84081e7..cd6520f 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -1077,15 +1077,9 @@ bool out_of_memory(struct oom_control *oc)
 		dump_header(oc, NULL);
 		panic("Out of memory and no killable processes...\n");
 	}
-	if (oc->chosen && oc->chosen != (void *)-1UL) {
+	if (oc->chosen && oc->chosen != (void *)-1UL)
 		oom_kill_process(oc, !is_memcg_oom(oc) ? "Out of memory" :
 				 "Memory cgroup out of memory");
-		/*
-		 * Give the killed process a good chance to exit before trying
-		 * to allocate memory again.
-		 */
-		schedule_timeout_killable(1);
-	}
 	return !!oc->chosen;
 }
 
