commit f58b1da35ee8ce5c7a4aebe270c9e00c09330f96	f58b1da35ee8ce5c7a4aebe270c9e00c09330f96
Author: Tobias Tebbi <tebbi@chromium.org>
Date:   Mon Jun 19 13:36:44 2023 +0200

    [compiler] only handle side-effect free interrupts in loop stack checks
    
    Bug: chromium:1452137
    Change-Id: Ia52efbc2c473cf9c1e6492eac3643480a8441275
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4614699
    Auto-Submit: Tobias Tebbi <tebbi@chromium.org>
    Commit-Queue: Toon Verwaest <verwaest@chromium.org>
    Reviewed-by: Toon Verwaest <verwaest@chromium.org>
    Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#88413}

diff --git a/include/v8-internal.h b/include/v8-internal.h
index f59eaea3cb9..9d163de1efe 100644
--- a/include/v8-internal.h
+++ b/include/v8-internal.h
@@ -557,7 +557,7 @@ class Internals {
   static const int kExternalOneByteRepresentationTag = 0x0a;
 
   static const uint32_t kNumIsolateDataSlots = 4;
-  static const int kStackGuardSize = 7 * kApiSystemPointerSize;
+  static const int kStackGuardSize = 8 * kApiSystemPointerSize;
   static const int kBuiltinTier0EntryTableSize = 7 * kApiSystemPointerSize;
   static const int kBuiltinTier0TableSize = 7 * kApiSystemPointerSize;
   static const int kLinearAllocationAreaSize = 3 * kApiSystemPointerSize;
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index 6460bad07de..9c1bcba372b 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -521,6 +521,15 @@ ExternalReference ExternalReference::address_of_jslimit(Isolate* isolate) {
   return ExternalReference(address);
 }
 
+ExternalReference ExternalReference::address_of_no_heap_write_interrupt_request(
+    Isolate* isolate) {
+  Address address = isolate->stack_guard()->address_of_interrupt_request(
+      StackGuard::InterruptLevel::kNoHeapWrites);
+  // For efficient generated code, this should be root-register-addressable.
+  DCHECK(isolate->root_register_addressable_region().contains(address));
+  return ExternalReference(address);
+}
+
 ExternalReference ExternalReference::address_of_real_jslimit(Isolate* isolate) {
   Address address = isolate->stack_guard()->address_of_real_jslimit();
   // For efficient generated code, this should be root-register-addressable.
diff --git a/src/codegen/external-reference.h b/src/codegen/external-reference.h
index b19d8d911a8..b26dae98c6d 100644
--- a/src/codegen/external-reference.h
+++ b/src/codegen/external-reference.h
@@ -38,6 +38,9 @@ class StatsCounter;
   V(isolate_root, "Isolate::isolate_root()")                                   \
   V(allocation_sites_list_address, "Heap::allocation_sites_list_address()")    \
   V(address_of_jslimit, "StackGuard::address_of_jslimit()")                    \
+  V(address_of_no_heap_write_interrupt_request,                                \
+    "StackGuard::address_of_interrupt_request(StackGuard::InterruptLevel::"    \
+    "kNoHeapWrites)")                                                          \
   V(address_of_real_jslimit, "StackGuard::address_of_real_jslimit()")          \
   V(heap_is_marking_flag_address, "heap_is_marking_flag_address")              \
   V(heap_is_minor_marking_flag_address, "heap_is_minor_marking_flag_address")  \
diff --git a/src/compiler/js-generic-lowering.cc b/src/compiler/js-generic-lowering.cc
index 794884520c4..dd94393d8eb 100644
--- a/src/compiler/js-generic-lowering.cc
+++ b/src/compiler/js-generic-lowering.cc
@@ -1140,16 +1140,28 @@ StackCheckKind StackCheckKindOfJSStackCheck(const Operator* op) {
 void JSGenericLowering::LowerJSStackCheck(Node* node) {
   Node* effect = NodeProperties::GetEffectInput(node);
   Node* control = NodeProperties::GetControlInput(node);
-
-  Node* limit = effect =
-      graph()->NewNode(machine()->Load(MachineType::Pointer()),
-                       jsgraph()->ExternalConstant(
-                           ExternalReference::address_of_jslimit(isolate())),
-                       jsgraph()->IntPtrConstant(0), effect, control);
-
   StackCheckKind stack_check_kind = StackCheckKindOfJSStackCheck(node->op());
-  Node* check = effect = graph()->NewNode(
-      machine()->StackPointerGreaterThan(stack_check_kind), limit, effect);
+
+  Node* check;
+  if (stack_check_kind == StackCheckKind::kJSIterationBody) {
+    check = effect = graph()->NewNode(
+        machine()->Load(MachineType::Uint8()),
+        jsgraph()->ExternalConstant(
+            ExternalReference::address_of_no_heap_write_interrupt_request(
+                isolate())),
+        jsgraph()->IntPtrConstant(0), effect, control);
+    check = graph()->NewNode(machine()->Word32Equal(), check,
+                             jsgraph()->Int32Constant(0));
+  } else {
+    Node* limit = effect =
+        graph()->NewNode(machine()->Load(MachineType::Pointer()),
+                         jsgraph()->ExternalConstant(
+                             ExternalReference::address_of_jslimit(isolate())),
+                         jsgraph()->IntPtrConstant(0), effect, control);
+
+    check = effect = graph()->NewNode(
+        machine()->StackPointerGreaterThan(stack_check_kind), limit, effect);
+  }
   Node* branch =
       graph()->NewNode(common()->Branch(BranchHint::kTrue), check, control);
 
@@ -1193,6 +1205,8 @@ void JSGenericLowering::LowerJSStackCheck(Node* node) {
     node->InsertInput(zone(), 0,
                       graph()->NewNode(machine()->LoadStackCheckOffset()));
     ReplaceWithRuntimeCall(node, Runtime::kStackGuardWithGap);
+  } else if (stack_check_kind == StackCheckKind::kJSIterationBody) {
+    ReplaceWithRuntimeCall(node, Runtime::kHandleNoHeapWritesInterrupts);
   } else {
     ReplaceWithRuntimeCall(node, Runtime::kStackGuard);
   }
diff --git a/src/compiler/js-operator.cc b/src/compiler/js-operator.cc
index a91242f456c..a9a850a21b6 100644
--- a/src/compiler/js-operator.cc
+++ b/src/compiler/js-operator.cc
@@ -10,6 +10,7 @@
 #include "src/compiler/js-graph.h"
 #include "src/compiler/js-heap-broker.h"
 #include "src/compiler/node-matchers.h"
+#include "src/compiler/operator-properties.h"
 #include "src/compiler/operator.h"
 #include "src/handles/handles-inl.h"
 #include "src/objects/objects-inl.h"
@@ -1401,9 +1402,20 @@ const Operator* JSOperatorBuilder::CloneObject(FeedbackSource const& feedback,
 }
 
 const Operator* JSOperatorBuilder::StackCheck(StackCheckKind kind) {
+  Operator::Properties properties;
+  switch (kind) {
+    case StackCheckKind::kJSFunctionEntry:
+    case StackCheckKind::kCodeStubAssembler:
+    case StackCheckKind::kWasm:
+      properties = Operator::kNoProperties;
+      break;
+    case StackCheckKind::kJSIterationBody:
+      properties = Operator::kNoWrite;
+      break;
+  }
   return zone()->New<Operator1<StackCheckKind>>(  // --
       IrOpcode::kJSStackCheck,                    // opcode
-      Operator::kNoProperties,                    // properties
+      properties,                                 // properties
       "JSStackCheck",                             // name
       0, 1, 1, 0, 1, 2,                           // counts
       kind);                                      // parameter
diff --git a/src/compiler/machine-operator.cc b/src/compiler/machine-operator.cc
index 14c5666abe8..bfce25cf6b2 100644
--- a/src/compiler/machine-operator.cc
+++ b/src/compiler/machine-operator.cc
@@ -1650,7 +1650,6 @@ struct MachineOperatorGlobalCache {
   StackPointerGreaterThan##Kind##Operator kStackPointerGreaterThan##Kind;
 
   STACK_POINTER_GREATER_THAN(JSFunctionEntry)
-  STACK_POINTER_GREATER_THAN(JSIterationBody)
   STACK_POINTER_GREATER_THAN(CodeStubAssembler)
   STACK_POINTER_GREATER_THAN(Wasm)
 #undef STACK_POINTER_GREATER_THAN
@@ -2041,12 +2040,12 @@ const Operator* MachineOperatorBuilder::StackPointerGreaterThan(
   switch (kind) {
     case StackCheckKind::kJSFunctionEntry:
       return &cache_.kStackPointerGreaterThanJSFunctionEntry;
-    case StackCheckKind::kJSIterationBody:
-      return &cache_.kStackPointerGreaterThanJSIterationBody;
     case StackCheckKind::kCodeStubAssembler:
       return &cache_.kStackPointerGreaterThanCodeStubAssembler;
     case StackCheckKind::kWasm:
       return &cache_.kStackPointerGreaterThanWasm;
+    case StackCheckKind::kJSIterationBody:
+      UNREACHABLE();
   }
   UNREACHABLE();
 }
diff --git a/src/debug/debug-evaluate.cc b/src/debug/debug-evaluate.cc
index 361c943bffd..244f6f88f3f 100644
--- a/src/debug/debug-evaluate.cc
+++ b/src/debug/debug-evaluate.cc
@@ -385,6 +385,7 @@ bool DebugEvaluate::IsSideEffectFreeIntrinsic(Runtime::FunctionId id) {
   V(ObjectIsExtensible)                       \
   V(RegExpInitializeAndCompile)               \
   V(StackGuard)                               \
+  V(HandleNoHeapWritesInterrupts)             \
   V(StringAdd)                                \
   V(StringCharCodeAt)                         \
   V(StringEqual)                              \
diff --git a/src/execution/stack-guard.cc b/src/execution/stack-guard.cc
index ff64beb8b22..efa6a6f0c46 100644
--- a/src/execution/stack-guard.cc
+++ b/src/execution/stack-guard.cc
@@ -26,16 +26,22 @@
 namespace v8 {
 namespace internal {
 
-void StackGuard::set_interrupt_limits(const ExecutionAccess& lock) {
+void StackGuard::update_interrupt_requests_and_stack_limits(
+    const ExecutionAccess& lock) {
   DCHECK_NOT_NULL(isolate_);
-  thread_local_.set_jslimit(kInterruptLimit);
-  thread_local_.set_climit(kInterruptLimit);
-}
-
-void StackGuard::reset_limits(const ExecutionAccess& lock) {
-  DCHECK_NOT_NULL(isolate_);
-  thread_local_.set_jslimit(thread_local_.real_jslimit_);
-  thread_local_.set_climit(thread_local_.real_climit_);
+  if (has_pending_interrupts(lock)) {
+    thread_local_.set_jslimit(kInterruptLimit);
+    thread_local_.set_climit(kInterruptLimit);
+  } else {
+    thread_local_.set_jslimit(thread_local_.real_jslimit_);
+    thread_local_.set_climit(thread_local_.real_climit_);
+  }
+  for (InterruptLevel level :
+       std::array{InterruptLevel::kNoGC, InterruptLevel::kNoHeapWrites,
+                  InterruptLevel::kAnyEffect}) {
+    thread_local_.set_interrupt_requested(
+        level, InterruptLevelMask(level) & thread_local_.interrupt_flags_);
+  }
 }
 
 void StackGuard::SetStackLimit(uintptr_t limit) {
@@ -64,18 +70,6 @@ void StackGuard::AdjustStackLimitForSimulator() {
   }
 }
 
-void StackGuard::EnableInterrupts() {
-  ExecutionAccess access(isolate_);
-  if (has_pending_interrupts(access)) {
-    set_interrupt_limits(access);
-  }
-}
-
-void StackGuard::DisableInterrupts() {
-  ExecutionAccess access(isolate_);
-  reset_limits(access);
-}
-
 void StackGuard::PushInterruptsScope(InterruptsScope* scope) {
   ExecutionAccess access(isolate_);
   DCHECK_NE(scope->mode_, InterruptsScope::kNoop);
@@ -95,10 +89,8 @@ void StackGuard::PushInterruptsScope(InterruptsScope* scope) {
       current->intercepted_flags_ &= ~scope->intercept_mask_;
     }
     thread_local_.interrupt_flags_ |= restored_flags;
-
-    if (has_pending_interrupts(access)) set_interrupt_limits(access);
   }
-  if (!has_pending_interrupts(access)) reset_limits(access);
+  update_interrupt_requests_and_stack_limits(access);
   // Add scope to the chain.
   scope->prev_ = thread_local_.interrupt_scopes_;
   thread_local_.interrupt_scopes_ = scope;
@@ -126,7 +118,7 @@ void StackGuard::PopInterruptsScope() {
       }
     }
   }
-  if (has_pending_interrupts(access)) set_interrupt_limits(access);
+  update_interrupt_requests_and_stack_limits(access);
   // Remove scope from chain.
   thread_local_.interrupt_scopes_ = top->prev_;
 }
@@ -146,7 +138,7 @@ void StackGuard::RequestInterrupt(InterruptFlag flag) {
 
   // Not intercepted.  Set as active interrupt flag.
   thread_local_.interrupt_flags_ |= flag;
-  set_interrupt_limits(access);
+  update_interrupt_requests_and_stack_limits(access);
 
   // If this isolate is waiting in a futex, notify it to wake up.
   isolate_->futex_wait_list_node()->NotifyWake();
@@ -162,37 +154,36 @@ void StackGuard::ClearInterrupt(InterruptFlag flag) {
 
   // Clear the interrupt flag from the active interrupt flags.
   thread_local_.interrupt_flags_ &= ~flag;
-  if (!has_pending_interrupts(access)) reset_limits(access);
+  update_interrupt_requests_and_stack_limits(access);
 }
 
 bool StackGuard::HasTerminationRequest() {
+  if (!thread_local_.has_interrupt_requested(InterruptLevel::kNoGC)) {
+    return false;
+  }
   ExecutionAccess access(isolate_);
   if ((thread_local_.interrupt_flags_ & TERMINATE_EXECUTION) != 0) {
     thread_local_.interrupt_flags_ &= ~TERMINATE_EXECUTION;
-    if (!has_pending_interrupts(access)) reset_limits(access);
+    update_interrupt_requests_and_stack_limits(access);
     return true;
   }
   return false;
 }
 
-int StackGuard::FetchAndClearInterrupts() {
+int StackGuard::FetchAndClearInterrupts(InterruptLevel level) {
   ExecutionAccess access(isolate_);
-
-  int result = 0;
+  InterruptFlag mask = InterruptLevelMask(level);
   if ((thread_local_.interrupt_flags_ & TERMINATE_EXECUTION) != 0) {
     // The TERMINATE_EXECUTION interrupt is special, since it terminates
     // execution but should leave V8 in a resumable state. If it exists, we only
     // fetch and clear that bit. On resume, V8 can continue processing other
     // interrupts.
-    result = TERMINATE_EXECUTION;
-    thread_local_.interrupt_flags_ &= ~TERMINATE_EXECUTION;
-    if (!has_pending_interrupts(access)) reset_limits(access);
-  } else {
-    result = static_cast<int>(thread_local_.interrupt_flags_);
-    thread_local_.interrupt_flags_ = 0;
-    reset_limits(access);
+    mask = TERMINATE_EXECUTION;
   }
 
+  int result = static_cast<int>(thread_local_.interrupt_flags_ & mask);
+  thread_local_.interrupt_flags_ &= ~mask;
+  update_interrupt_requests_and_stack_limits(access);
   return result;
 }
 
@@ -264,7 +255,7 @@ class V8_NODISCARD ShouldBeZeroOnReturnScope final {
 
 }  // namespace
 
-Object StackGuard::HandleInterrupts() {
+Object StackGuard::HandleInterrupts(InterruptLevel level) {
   TRACE_EVENT0("v8.execute", "V8.HandleInterrupts");
 
 #if DEBUG
@@ -278,7 +269,7 @@ Object StackGuard::HandleInterrupts() {
 
   // Fetch and clear interrupt bits in one go. See comments inside the method
   // for special handling of TERMINATE_EXECUTION.
-  int interrupt_flags = FetchAndClearInterrupts();
+  int interrupt_flags = FetchAndClearInterrupts(level);
 
   // All interrupts should be fully processed when returning from this method.
   ShouldBeZeroOnReturnScope should_be_zero_on_return(&interrupt_flags);
diff --git a/src/execution/stack-guard.h b/src/execution/stack-guard.h
index 8cdf755c0d2..5e460499a53 100644
--- a/src/execution/stack-guard.h
+++ b/src/execution/stack-guard.h
@@ -45,20 +45,30 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
   // Sets up the default stack guard for this thread.
   void InitThread(const ExecutionAccess& lock);
 
-#define INTERRUPT_LIST(V)                                         \
-  V(TERMINATE_EXECUTION, TerminateExecution, 0)                   \
-  V(GC_REQUEST, GC, 1)                                            \
-  V(INSTALL_CODE, InstallCode, 2)                                 \
-  V(INSTALL_BASELINE_CODE, InstallBaselineCode, 3)                \
-  V(API_INTERRUPT, ApiInterrupt, 4)                               \
-  V(DEOPT_MARKED_ALLOCATION_SITES, DeoptMarkedAllocationSites, 5) \
-  V(GROW_SHARED_MEMORY, GrowSharedMemory, 6)                      \
-  V(LOG_WASM_CODE, LogWasmCode, 7)                                \
-  V(WASM_CODE_GC, WasmCodeGC, 8)                                  \
-  V(INSTALL_MAGLEV_CODE, InstallMaglevCode, 9)                    \
-  V(GLOBAL_SAFEPOINT, GlobalSafepoint, 10)
-
-#define V(NAME, Name, id)                                    \
+  // Code locations that check for interrupts might only handle a subset of the
+  // available interrupts, expressed as an `InterruptLevel`. These levels are
+  // also associated with side effects that are allowed for the respective
+  // level. The levels are inclusive, which is specified using the order in the
+  // enum. For example, a site that handles `kAnyEffect` will also handle the
+  // preceding levels.
+  enum class InterruptLevel { kNoGC, kNoHeapWrites, kAnyEffect };
+  static constexpr int kNumberOfInterruptLevels = 3;
+
+#define INTERRUPT_LIST(V)                                                      \
+  V(TERMINATE_EXECUTION, TerminateExecution, 0, InterruptLevel::kNoGC)         \
+  V(GC_REQUEST, GC, 1, InterruptLevel::kNoHeapWrites)                          \
+  V(INSTALL_CODE, InstallCode, 2, InterruptLevel::kAnyEffect)                  \
+  V(INSTALL_BASELINE_CODE, InstallBaselineCode, 3, InterruptLevel::kAnyEffect) \
+  V(API_INTERRUPT, ApiInterrupt, 4, InterruptLevel::kNoHeapWrites)             \
+  V(DEOPT_MARKED_ALLOCATION_SITES, DeoptMarkedAllocationSites, 5,              \
+    InterruptLevel::kNoHeapWrites)                                             \
+  V(GROW_SHARED_MEMORY, GrowSharedMemory, 6, InterruptLevel::kAnyEffect)       \
+  V(LOG_WASM_CODE, LogWasmCode, 7, InterruptLevel::kAnyEffect)                 \
+  V(WASM_CODE_GC, WasmCodeGC, 8, InterruptLevel::kNoHeapWrites)                \
+  V(INSTALL_MAGLEV_CODE, InstallMaglevCode, 9, InterruptLevel::kAnyEffect)     \
+  V(GLOBAL_SAFEPOINT, GlobalSafepoint, 10, InterruptLevel::kNoHeapWrites)
+
+#define V(NAME, Name, id, interrupt_level)                   \
   inline bool Check##Name() { return CheckInterrupt(NAME); } \
   inline void Request##Name() { RequestInterrupt(NAME); }    \
   inline void Clear##Name() { ClearInterrupt(NAME); }
@@ -67,16 +77,23 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
 
   // Flag used to set the interrupt causes.
   enum InterruptFlag : uint32_t {
-#define V(NAME, Name, id) NAME = (1 << id),
+#define V(NAME, Name, id, interrupt_level) NAME = (1 << id),
     INTERRUPT_LIST(V)
 #undef V
-#define V(NAME, Name, id) NAME |
+#define V(NAME, Name, id, interrupt_level) NAME |
         ALL_INTERRUPTS = INTERRUPT_LIST(V) 0
 #undef V
   };
   static_assert(InterruptFlag::ALL_INTERRUPTS <
                 std::numeric_limits<uint32_t>::max());
 
+  static constexpr InterruptFlag InterruptLevelMask(InterruptLevel level) {
+#define V(NAME, Name, id, interrupt_level) \
+  | (interrupt_level <= level ? NAME : 0)
+    return static_cast<InterruptFlag>(0 INTERRUPT_LIST(V));
+#undef V
+  }
+
   uintptr_t climit() { return thread_local_.climit(); }
   uintptr_t jslimit() { return thread_local_.jslimit(); }
   // This provides an asynchronous read of the stack limits for the current
@@ -90,17 +107,23 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
   Address address_of_real_jslimit() {
     return reinterpret_cast<Address>(&thread_local_.real_jslimit_);
   }
+  Address address_of_interrupt_request(InterruptLevel level) {
+    return reinterpret_cast<Address>(
+        &thread_local_.interrupt_requested_[static_cast<int>(level)]);
+  }
 
   // If the stack guard is triggered, but it is not an actual
   // stack overflow, then handle the interruption accordingly.
-  Object HandleInterrupts();
+  // Only interrupts that match the given `InterruptLevel` will be handled,
+  // leaving other interrupts pending as if this method had not been called.
+  Object HandleInterrupts(InterruptLevel level = InterruptLevel::kAnyEffect);
 
   // Special case of {HandleInterrupts}: checks for termination requests only.
   // This is guaranteed to never cause GC, so can be used to interrupt
   // long-running computations that are not GC-safe.
   bool HasTerminationRequest();
 
-  static constexpr int kSizeInBytes = 7 * kSystemPointerSize;
+  static constexpr int kSizeInBytes = 8 * kSystemPointerSize;
 
   static char* Iterate(RootVisitor* v, char* thread_storage) {
     return thread_storage + ArchiveSpacePerThread();
@@ -110,7 +133,7 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
   bool CheckInterrupt(InterruptFlag flag);
   void RequestInterrupt(InterruptFlag flag);
   void ClearInterrupt(InterruptFlag flag);
-  int FetchAndClearInterrupts();
+  int FetchAndClearInterrupts(InterruptLevel level);
 
   // You should hold the ExecutionAccess lock when calling this method.
   bool has_pending_interrupts(const ExecutionAccess& lock) {
@@ -118,15 +141,8 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
   }
 
   // You should hold the ExecutionAccess lock when calling this method.
-  inline void set_interrupt_limits(const ExecutionAccess& lock);
-
-  // Reset limits to actual values. For example after handling interrupt.
-  // You should hold the ExecutionAccess lock when calling this method.
-  inline void reset_limits(const ExecutionAccess& lock);
-
-  // Enable or disable interrupts.
-  void EnableInterrupts();
-  void DisableInterrupts();
+  inline void update_interrupt_requests_and_stack_limits(
+      const ExecutionAccess& lock);
 
 #if V8_TARGET_ARCH_64_BIT
   static const uintptr_t kInterruptLimit = uintptr_t{0xfffffffffffffffe};
@@ -180,6 +196,20 @@ class V8_EXPORT_PRIVATE V8_NODISCARD StackGuard final {
                                  static_cast<base::AtomicWord>(limit));
     }
 
+    // Interrupt request bytes can be read without any lock.
+    // Writing requires the ExecutionAccess lock.
+    base::Atomic8 interrupt_requested_[kNumberOfInterruptLevels] = {
+        false, false, false};
+
+    void set_interrupt_requested(InterruptLevel level, bool requested) {
+      base::Relaxed_Store(&interrupt_requested_[static_cast<int>(level)],
+                          requested);
+    }
+
+    bool has_interrupt_requested(InterruptLevel level) {
+      return base::Relaxed_Load(&interrupt_requested_[static_cast<int>(level)]);
+    }
+
     InterruptsScope* interrupt_scopes_ = nullptr;
     uint32_t interrupt_flags_ = 0;
   };
diff --git a/src/runtime/runtime-internal.cc b/src/runtime/runtime-internal.cc
index bb66817f024..ad36c37c78a 100644
--- a/src/runtime/runtime-internal.cc
+++ b/src/runtime/runtime-internal.cc
@@ -356,7 +356,23 @@ RUNTIME_FUNCTION(Runtime_StackGuard) {
     return isolate->StackOverflow();
   }
 
-  return isolate->stack_guard()->HandleInterrupts();
+  return isolate->stack_guard()->HandleInterrupts(
+      StackGuard::InterruptLevel::kAnyEffect);
+}
+
+RUNTIME_FUNCTION(Runtime_HandleNoHeapWritesInterrupts) {
+  SealHandleScope shs(isolate);
+  DCHECK_EQ(0, args.length());
+  TRACE_EVENT0("v8.execute", "V8.StackGuard");
+
+  // First check if this is a real stack overflow.
+  StackLimitCheck check(isolate);
+  if (check.JsHasOverflowed()) {
+    return isolate->StackOverflow();
+  }
+
+  return isolate->stack_guard()->HandleInterrupts(
+      StackGuard::InterruptLevel::kNoHeapWrites);
 }
 
 RUNTIME_FUNCTION(Runtime_StackGuardWithGap) {
@@ -371,7 +387,8 @@ RUNTIME_FUNCTION(Runtime_StackGuardWithGap) {
     return isolate->StackOverflow();
   }
 
-  return isolate->stack_guard()->HandleInterrupts();
+  return isolate->stack_guard()->HandleInterrupts(
+      StackGuard::InterruptLevel::kAnyEffect);
 }
 
 namespace {
diff --git a/src/runtime/runtime-wasm.cc b/src/runtime/runtime-wasm.cc
index 63b9802a67f..7fa22b57b34 100644
--- a/src/runtime/runtime-wasm.cc
+++ b/src/runtime/runtime-wasm.cc
@@ -298,7 +298,8 @@ RUNTIME_FUNCTION(Runtime_WasmStackGuard) {
   StackLimitCheck check(isolate);
   if (check.JsHasOverflowed()) return isolate->StackOverflow();
 
-  return isolate->stack_guard()->HandleInterrupts();
+  return isolate->stack_guard()->HandleInterrupts(
+      StackGuard::InterruptLevel::kAnyEffect);
 }
 
 RUNTIME_FUNCTION(Runtime_WasmCompileLazy) {
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index 5c39587e6bd..ca71d07fcdb 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -251,6 +251,7 @@ namespace internal {
   F(PerformMicrotaskCheckpoint, 0, 1)                      \
   F(SharedValueBarrierSlow, 1, 1)                          \
   F(StackGuard, 0, 1)                                      \
+  F(HandleNoHeapWritesInterrupts, 0, 1)                    \
   F(StackGuardWithGap, 1, 1)                               \
   F(Throw, 1, 1)                                           \
   F(ThrowApplyNonFunction, 1, 1)                           \
