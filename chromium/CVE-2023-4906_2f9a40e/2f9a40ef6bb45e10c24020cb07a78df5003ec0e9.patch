commit 2f9a40ef6bb45e10c24020cb07a78df5003ec0e9	2f9a40ef6bb45e10c24020cb07a78df5003ec0e9
Author: Dmitry Vykochko <vykochko@google.com>
Date:   Mon Jun 26 07:52:59 2023 +0000

    Fix the autofill popup sufficient space check.
    
    The footer height was not taken into account. Fixed by adding
    its full height into the min_height restrictions, as it is not
    scrollable.
    
    Bug: 1449874
    Change-Id: I69954550d2e7b2e516c6de89830c3d28133b6501
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4624570
    Reviewed-by: Vasilii Sukhanov <vasilii@chromium.org>
    Commit-Queue: Dmitry Vykochko <vykochko@google.com>
    Reviewed-by: Christoph Schwering <schwering@google.com>
    Code-Coverage: Findit <findit-for-me@appspot.gserviceaccount.com>
    Cr-Commit-Position: refs/heads/main@{#1162273}

diff --git a/chrome/browser/autofill/mock_autofill_popup_controller.h b/chrome/browser/autofill/mock_autofill_popup_controller.h
index c735d664446c2..c5bfd173dfcb9 100644
--- a/chrome/browser/autofill/mock_autofill_popup_controller.h
+++ b/chrome/browser/autofill/mock_autofill_popup_controller.h
@@ -38,9 +38,9 @@ class MockAutofillPopupController
   MOCK_METHOD(gfx::Rect, popup_bounds, (), (const override));
   MOCK_METHOD(gfx::NativeView, container_view, (), (const override));
   MOCK_METHOD(content::WebContents*, GetWebContents, (), (const override));
-  const gfx::RectF& element_bounds() const override {
-    static const gfx::RectF bounds(100, 100, 250, 50);
-    return bounds;
+  const gfx::RectF& element_bounds() const override { return element_bounds_; }
+  void set_element_bounds(const gfx::RectF& bounds) {
+    element_bounds_ = bounds;
   }
   MOCK_METHOD(base::i18n::TextDirection,
               GetElementTextDirection,
@@ -87,6 +87,8 @@ class MockAutofillPopupController
   MOCK_METHOD(PopupType, GetPopupType, (), (const override));
 
   void set_suggestions(const std::vector<PopupItemId>& ids) {
+    suggestions_.clear();
+
     for (const auto& id : ids) {
       // Accessibility requires all focusable AutofillPopupItemView to have
       // ui::AXNodeData with non-empty names. We specify dummy values and labels
@@ -104,6 +106,7 @@ class MockAutofillPopupController
  private:
   std::vector<autofill::Suggestion> suggestions_;
   gfx::ScopedDefaultFontDescription default_font_desc_setter_;
+  gfx::RectF element_bounds_ = {100, 100, 250, 50};
 
   base::WeakPtrFactory<MockAutofillPopupController> weak_ptr_factory_{this};
 };
diff --git a/chrome/browser/ui/views/autofill/popup/popup_view_utils.cc b/chrome/browser/ui/views/autofill/popup/popup_view_utils.cc
index 16d00c0d6120b..7bc9a23b4dc53 100644
--- a/chrome/browser/ui/views/autofill/popup/popup_view_utils.cc
+++ b/chrome/browser/ui/views/autofill/popup/popup_view_utils.cc
@@ -249,6 +249,7 @@ bool CanShowDropdownHere(int item_height,
       element_bounds.bottom() > content_area_bounds.y() &&
       element_bounds.bottom() <= content_area_bounds.bottom();
 
+  // TODO(crbug.com/1455336): Test the space on the left/right or forbid it explicitly.
   return (enough_space_for_one_item_in_content_area_above_element &&
           element_top_is_within_content_area_bounds) ||
          (enough_space_for_one_item_in_content_area_below_element &&
diff --git a/chrome/browser/ui/views/autofill/popup/popup_view_views.cc b/chrome/browser/ui/views/autofill/popup/popup_view_views.cc
index 9d04ac5f8c552..8b6f0ecb79f10 100644
--- a/chrome/browser/ui/views/autofill/popup/popup_view_views.cc
+++ b/chrome/browser/ui/views/autofill/popup/popup_view_views.cc
@@ -363,6 +363,11 @@ void PopupViewViews::OnWidgetVisibilityChanged(views::Widget* widget,
       feature_engagement::kIPHAutofillExternalAccountProfileSuggestionFeature);
 }
 
+bool PopupViewViews::CanShowDropdownInBoundsForTesting(
+    const gfx::Rect& bounds) const {
+  return CanShowDropdownInBounds(bounds);
+}
+
 bool PopupViewViews::HasPopupRowViewAt(size_t index) const {
   return index < rows_.size() &&
          absl::holds_alternative<PopupRowView*>(rows_[index]);
@@ -464,28 +469,26 @@ void PopupViewViews::CreateChildViews() {
   // Footer items need to be in their own container because they should not be
   // affected by scrolling behavior (they are "sticky" at the bottom) and
   // because they have a special background color
-  std::unique_ptr<views::BoxLayoutView> footer_container =
+  footer_container_ = content_view->AddChildView(
       views::Builder<views::BoxLayoutView>()
           .SetOrientation(views::BoxLayout::Orientation::kVertical)
           .SetBackground(
               views::CreateThemedSolidBackground(ui::kColorDropdownBackground))
-          .Build();
+          .Build());
+  content_view->SetFlexForView(footer_container_, 0);
 
   for (; current_line_number < kSuggestions.size(); ++current_line_number) {
     DCHECK(IsFooterItem(kSuggestions, current_line_number));
     // The footer can contain either footer views or separator lines.
     if (kSuggestions[current_line_number].popup_item_id ==
         PopupItemId::kSeparator) {
-      rows_.push_back(footer_container->AddChildView(
+      rows_.push_back(footer_container_->AddChildView(
           std::make_unique<PopupSeparatorView>()));
     } else {
-      rows_.push_back(footer_container->AddChildView(
+      rows_.push_back(footer_container_->AddChildView(
           PopupRowView::Create(*this, current_line_number)));
     }
   }
-
-  content_view->SetFlexForView(
-      content_view->AddChildView(std::move(footer_container)), 0);
 }
 
 int PopupViewViews::AdjustWidth(int width) const {
@@ -538,22 +541,13 @@ bool PopupViewViews::DoUpdateBoundsAndRedrawPopup() {
   element_bounds.Inset(
       gfx::Insets::VH(/*vertical=*/-kElementBorderPadding, /*horizontal=*/0));
 
-  // At least first and last rows of the popup -- a suggestion and, if present,
-  // the footer -- should be shown in the bounds of the content area so that the
-  // user notices the presence of the popup and, in particular, the first
-  // suggestion.
-  int min_height = std::numeric_limits<int>::max();
-  if (body_container_) {
-    const View::Views& children = body_container_->children();
-    if (!children.empty()) {
-      min_height = children.front()->GetPreferredSize().height();
-      if (children.size() > 1) {
-        min_height += children.back()->GetPreferredSize().height();
-      }
-    }
+  if ((!body_container_ || body_container_->children().empty()) &&
+      (!footer_container_ || footer_container_->children().empty())) {
+    controller_->Hide(PopupHidingReason::kNoSuggestions);
+    return false;
   }
 
-  if (!CanShowDropdownHere(min_height, max_bounds_for_popup, element_bounds)) {
+  if (!CanShowDropdownInBounds(max_bounds_for_popup)) {
     controller_->Hide(PopupHidingReason::kInsufficientSpace);
     return false;
   }
@@ -627,6 +621,24 @@ bool PopupViewViews::DoUpdateBoundsAndRedrawPopup() {
   return true;
 }
 
+bool PopupViewViews::CanShowDropdownInBounds(const gfx::Rect& bounds) const {
+  gfx::Rect element_bounds =
+      gfx::ToEnclosingRect(controller_->element_bounds());
+
+  // At least one suggestion and the sticky footer should be shown in the bounds
+  // of the content area so that the user notices the presence of the popup.
+  int min_height = 0;
+  if (body_container_ && !body_container_->children().empty()) {
+    min_height += body_container_->children()[0]->GetPreferredSize().height();
+  }
+  if (footer_container_ && !footer_container_->children().empty()) {
+    // The footer is not scrollable, its full height should be considered.
+    min_height += footer_container_->GetPreferredSize().height();
+  }
+
+  return CanShowDropdownHere(min_height, bounds, element_bounds);
+}
+
 base::WeakPtr<AutofillPopupView> PopupViewViews::GetWeakPtr() {
   return weak_ptr_factory_.GetWeakPtr();
 }
diff --git a/chrome/browser/ui/views/autofill/popup/popup_view_views.h b/chrome/browser/ui/views/autofill/popup/popup_view_views.h
index 78bf79068f20b..8a5df286d862a 100644
--- a/chrome/browser/ui/views/autofill/popup/popup_view_views.h
+++ b/chrome/browser/ui/views/autofill/popup/popup_view_views.h
@@ -69,6 +69,8 @@ class PopupViewViews : public PopupBaseView,
   // PopupBaseView:
   void OnWidgetVisibilityChanged(views::Widget* widget, bool visible) override;
 
+  bool CanShowDropdownInBoundsForTesting(const gfx::Rect& bounds) const;
+
  private:
   friend class PopupViewViewsBrowsertest;
   friend class PopupViewViewsTest;
@@ -128,6 +130,8 @@ class PopupViewViews : public PopupBaseView,
   // PopupBaseView:
   bool DoUpdateBoundsAndRedrawPopup() override;
 
+  bool CanShowDropdownInBounds(const gfx::Rect& bounds) const;
+
   // Controller for this view.
   base::WeakPtr<AutofillPopupController> controller_ = nullptr;
   // The index of the row with a selected cell.
@@ -135,6 +139,7 @@ class PopupViewViews : public PopupBaseView,
   std::vector<RowPointer> rows_;
   raw_ptr<views::ScrollView, DanglingUntriaged> scroll_view_ = nullptr;
   raw_ptr<views::BoxLayoutView, DanglingUntriaged> body_container_ = nullptr;
+  raw_ptr<views::BoxLayoutView, DanglingUntriaged> footer_container_ = nullptr;
 
   base::WeakPtrFactory<AutofillPopupView> weak_ptr_factory_{this};
 };
diff --git a/chrome/browser/ui/views/autofill/popup/popup_view_views_unittest.cc b/chrome/browser/ui/views/autofill/popup/popup_view_views_unittest.cc
index 60b5bfb6c0951..bd676335ae4a5 100644
--- a/chrome/browser/ui/views/autofill/popup/popup_view_views_unittest.cc
+++ b/chrome/browser/ui/views/autofill/popup/popup_view_views_unittest.cc
@@ -213,6 +213,40 @@ TEST_F(PopupViewViewsTest, ShowHideTest) {
   view().Hide();
 }
 
+TEST_F(PopupViewViewsTest, CanShowDropdownInBounds) {
+  CreateAndShowView({PopupItemId::kAutocompleteEntry, PopupItemId::kSeparator,
+                     PopupItemId::kAutofillOptions});
+
+  const int kSingleItemPopupHeight = view().GetPreferredSize().height();
+  const int kElementY = 10;
+  const int kElementHeight = 15;
+  controller().set_element_bounds({10, kElementY, 100, kElementHeight});
+
+  EXPECT_FALSE(view().CanShowDropdownInBoundsForTesting({0, 0, 100, 35}));
+
+  // Test a smaller than the popup height (-10px) available space.
+  EXPECT_FALSE(view().CanShowDropdownInBoundsForTesting(
+      {0, 0, 100, kElementY + kElementHeight + kSingleItemPopupHeight - 10}));
+
+  // Test a larger than the popup height (+10px) available space.
+  EXPECT_TRUE(view().CanShowDropdownInBoundsForTesting(
+      {0, 0, 100, kElementY + kElementHeight + kSingleItemPopupHeight + 10}));
+
+  view().Hide();
+
+  // Repeat the same tests as for the single-suggestion popup above,
+  // the list is scrollable so that the same restrictions apply.
+  CreateAndShowView({PopupItemId::kAutocompleteEntry,
+                     PopupItemId::kAutocompleteEntry,
+                     PopupItemId::kAutocompleteEntry, PopupItemId::kSeparator,
+                     PopupItemId::kAutofillOptions});
+  EXPECT_FALSE(view().CanShowDropdownInBoundsForTesting({0, 0, 100, 35}));
+  EXPECT_FALSE(view().CanShowDropdownInBoundsForTesting(
+      {0, 0, 100, kElementY + kElementHeight + kSingleItemPopupHeight - 10}));
+  EXPECT_TRUE(view().CanShowDropdownInBoundsForTesting(
+      {0, 0, 100, kElementY + kElementHeight + kSingleItemPopupHeight + 10}));
+}
+
 // This is a regression test for crbug.com/1113255.
 TEST_F(PopupViewViewsTest, ShowViewWithOnlyFooterItemsShouldNotCrash) {
   // Set suggestions to have only a footer item.
