commit b9fa16949d18e06bdf728a560f5c8af56d2bdcaf
Author: Rick Edgecombe <rick.p.edgecombe@intel.com>
Date:   Wed Feb 21 16:17:21 2024 -0800

    dma-direct: Leak pages on dma_set_decrypted() failure
    
    On TDX it is possible for the untrusted host to cause
    set_memory_encrypted() or set_memory_decrypted() to fail such that an
    error is returned and the resulting memory is shared. Callers need to
    take care to handle these errors to avoid returning decrypted (shared)
    memory to the page allocator, which could lead to functional or security
    issues.
    
    DMA could free decrypted/shared pages if dma_set_decrypted() fails. This
    should be a rare case. Just leak the pages in this case instead of
    freeing them.
    
    Signed-off-by: Rick Edgecombe <rick.p.edgecombe@intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index 98b2e192fd69..4d543b1e9d57 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -286,7 +286,7 @@ void *dma_direct_alloc(struct device *dev, size_t size,
 	} else {
 		ret = page_address(page);
 		if (dma_set_decrypted(dev, ret, size))
-			goto out_free_pages;
+			goto out_leak_pages;
 	}
 
 	memset(ret, 0, size);
@@ -307,6 +307,8 @@ void *dma_direct_alloc(struct device *dev, size_t size,
 out_free_pages:
 	__dma_direct_free_pages(dev, page, size);
 	return NULL;
+out_leak_pages:
+	return NULL;
 }
 
 void dma_direct_free(struct device *dev, size_t size,
@@ -367,12 +369,11 @@ struct page *dma_direct_alloc_pages(struct device *dev, size_t size,
 
 	ret = page_address(page);
 	if (dma_set_decrypted(dev, ret, size))
-		goto out_free_pages;
+		goto out_leak_pages;
 	memset(ret, 0, size);
 	*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));
 	return page;
-out_free_pages:
-	__dma_direct_free_pages(dev, page, size);
+out_leak_pages:
 	return NULL;
 }
 
