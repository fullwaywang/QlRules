commit 7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10
Author: Duoming Zhou <duoming@zju.edu.cn>
Date:   Tue Feb 8 23:40:00 2022 +0800

    ax25: fix NPD bug in ax25_disconnect
    
    The ax25_disconnect() in ax25_kill_by_device() is not
    protected by any locks, thus there is a race condition
    between ax25_disconnect() and ax25_destroy_socket().
    when ax25->sk is assigned as NULL by ax25_destroy_socket(),
    a NULL pointer dereference bug will occur if site (1) or (2)
    dereferences ax25->sk.
    
    ax25_kill_by_device()                | ax25_release()
      ax25_disconnect()                  |   ax25_destroy_socket()
        ...                              |
        if(ax25->sk != NULL)             |     ...
          ...                            |     ax25->sk = NULL;
          bh_lock_sock(ax25->sk); //(1)  |     ...
          ...                            |
          bh_unlock_sock(ax25->sk); //(2)|
    
    This patch moves ax25_disconnect() into lock_sock(), which can
    synchronize with ax25_destroy_socket() in ax25_release().
    
    Fail log:
    ===============================================================
    BUG: kernel NULL pointer dereference, address: 0000000000000088
    ...
    RIP: 0010:_raw_spin_lock+0x7e/0xd0
    ...
    Call Trace:
    ax25_disconnect+0xf6/0x220
    ax25_device_event+0x187/0x250
    raw_notifier_call_chain+0x5e/0x70
    dev_close_many+0x17d/0x230
    rollback_registered_many+0x1f1/0x950
    unregister_netdevice_queue+0x133/0x200
    unregister_netdev+0x13/0x20
    ...
    
    Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 3e49d28824ed..3d87040d1bfc 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -92,8 +92,8 @@ static void ax25_kill_by_device(struct net_device *dev)
 			lock_sock(sk);
 			s->ax25_dev = NULL;
 			ax25_dev_put(ax25_dev);
-			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
+			release_sock(sk);
 			spin_lock_bh(&ax25_list_lock);
 			sock_put(sk);
 			/* The entry could have been deleted from the
