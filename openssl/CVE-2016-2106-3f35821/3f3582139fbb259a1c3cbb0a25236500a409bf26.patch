commit 3f3582139fbb259a1c3cbb0a25236500a409bf26
Author: Matt Caswell <matt@openssl.org>
Date:   Thu Mar 3 23:36:23 2016 +0000

    Fix encrypt overflow
    
    An overflow can occur in the EVP_EncryptUpdate function. If an attacker is
    able to supply very large amounts of input data after a previous call to
    EVP_EncryptUpdate with a partial block then a length check can overflow
    resulting in a heap corruption.
    
    Following an analysis of all OpenSSL internal usage of the
    EVP_EncryptUpdate function all usage is one of two forms.
    
    The first form is like this:
    EVP_EncryptInit()
    EVP_EncryptUpdate()
    
    i.e. where the EVP_EncryptUpdate() call is known to be the first called
    function after an EVP_EncryptInit(), and therefore that specific call
    must be safe.
    
    The second form is where the length passed to EVP_EncryptUpdate() can be
    seen from the code to be some small value and therefore there is no
    possibility of an overflow.
    
    Since all instances are one of these two forms, I believe that there can
    be no overflows in internal code due to this problem.
    
    It should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()
    in certain code paths. Also EVP_CipherUpdate() is a synonym for
    EVP_EncryptUpdate(). Therefore I have checked all instances of these
    calls too, and came to the same conclusion, i.e. there are no instances
    in internal usage where an overflow could occur.
    
    This could still represent a security issue for end user code that calls
    this function directly.
    
    CVE-2016-2106
    
    Issue reported by Guido Vranken.
    
    Reviewed-by: Tim Hudson <tjh@openssl.org>

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index d7cc1f453c..e02e801949 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -332,7 +332,7 @@ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     bl = ctx->cipher->block_size;
     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
     if (i != 0) {
-        if (i + inl < bl) {
+        if (bl - i > inl) {
             memcpy(&(ctx->buf[i]), in, inl);
             ctx->buf_len += inl;
             *outl = 0;
