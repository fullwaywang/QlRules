commit 3e493173b7841259a08c5c8e5cbe90adb349da7e
Author: Jouni Malinen <jouni@codeaurora.org>
Date:   Wed Sep 11 16:03:05 2019 +0300

    mac80211: Do not send Layer 2 Update frame before authorization
    
    The Layer 2 Update frame is used to update bridges when a station roams
    to another AP even if that STA does not transmit any frames after the
    reassociation. This behavior was described in IEEE Std 802.11F-2003 as
    something that would happen based on MLME-ASSOCIATE.indication, i.e.,
    before completing 4-way handshake. However, this IEEE trial-use
    recommended practice document was published before RSN (IEEE Std
    802.11i-2004) and as such, did not consider RSN use cases. Furthermore,
    IEEE Std 802.11F-2003 was withdrawn in 2006 and as such, has not been
    maintained amd should not be used anymore.
    
    Sending out the Layer 2 Update frame immediately after association is
    fine for open networks (and also when using SAE, FT protocol, or FILS
    authentication when the station is actually authenticated by the time
    association completes). However, it is not appropriate for cases where
    RSN is used with PSK or EAP authentication since the station is actually
    fully authenticated only once the 4-way handshake completes after
    authentication and attackers might be able to use the unauthenticated
    triggering of Layer 2 Update frame transmission to disrupt bridge
    behavior.
    
    Fix this by postponing transmission of the Layer 2 Update frame from
    station entry addition to the point when the station entry is marked
    authorized. Similarly, send out the VLAN binding update only if the STA
    entry has already been authorized.
    
    Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 111c400..4105c97 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1529,7 +1529,6 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 	struct sta_info *sta;
 	struct ieee80211_sub_if_data *sdata;
 	int err;
-	int layer2_update;
 
 	if (params->vlan) {
 		sdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);
@@ -1573,18 +1572,12 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 	    test_sta_flag(sta, WLAN_STA_ASSOC))
 		rate_control_rate_init(sta);
 
-	layer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
-		sdata->vif.type == NL80211_IFTYPE_AP;
-
 	err = sta_info_insert_rcu(sta);
 	if (err) {
 		rcu_read_unlock();
 		return err;
 	}
 
-	if (layer2_update)
-		cfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);
-
 	rcu_read_unlock();
 
 	return 0;
@@ -1682,10 +1675,11 @@ static int ieee80211_change_station(struct wiphy *wiphy,
 		sta->sdata = vlansdata;
 		ieee80211_check_fast_xmit(sta);
 
-		if (test_sta_flag(sta, WLAN_STA_AUTHORIZED))
+		if (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {
 			ieee80211_vif_inc_num_mcast(sta->sdata);
-
-		cfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);
+			cfg80211_send_layer2_update(sta->sdata->dev,
+						    sta->sta.addr);
+		}
 	}
 
 	err = sta_apply_parameters(local, sta, params);
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index 95eb822..5fb368c 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -1979,6 +1979,10 @@ int sta_info_move_state(struct sta_info *sta,
 			ieee80211_check_fast_xmit(sta);
 			ieee80211_check_fast_rx(sta);
 		}
+		if (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+		    sta->sdata->vif.type == NL80211_IFTYPE_AP)
+			cfg80211_send_layer2_update(sta->sdata->dev,
+						    sta->sta.addr);
 		break;
 	default:
 		break;
