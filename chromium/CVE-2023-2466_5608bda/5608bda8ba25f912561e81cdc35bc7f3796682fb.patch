commit 5608bda8ba25f912561e81cdc35bc7f3796682fb	5608bda8ba25f912561e81cdc35bc7f3796682fb
Author: Andy Paicu <andypaicu@chromium.org>
Date:   Fri Mar 3 15:09:20 2023 +0000

    Disallow custom cursors when a permission prompt is displayed
    
    Bug: 1385714
    Change-Id: I73ee22d0d8ad331efc5cb40ce800a47939c66663
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4154719
    Reviewed-by: Daniel Cheng <dcheng@chromium.org>
    Reviewed-by: Avi Drissman <avi@chromium.org>
    Commit-Queue: Andy Paicu <andypaicu@chromium.org>
    Reviewed-by: Elias Klim <elklm@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1112775}

diff --git a/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.cc b/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.cc
index 75ae8a5399d67..16222bf2cdef0 100644
--- a/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.cc
+++ b/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.cc
@@ -61,6 +61,11 @@ bool TestPermissionBubbleViewDelegate::RecreateView() {
   return false;
 }
 
+content::WebContents*
+TestPermissionBubbleViewDelegate::GetAssociatedWebContents() {
+  return nullptr;
+}
+
 base::WeakPtr<permissions::PermissionPrompt::Delegate>
 TestPermissionBubbleViewDelegate::GetWeakPtr() {
   return weak_factory_.GetWeakPtr();
diff --git a/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.h b/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.h
index ffa4c85422050..e40d00cae8d09 100644
--- a/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.h
+++ b/chrome/browser/ui/permission_bubble/permission_bubble_browser_test_util.h
@@ -63,6 +63,7 @@ class TestPermissionBubbleViewDelegate
   void SetPromptShown() override {}
   void SetDecisionTime() override {}
   bool RecreateView() override;
+  content::WebContents* GetAssociatedWebContents() override;
 
   base::WeakPtr<permissions::PermissionPrompt::Delegate> GetWeakPtr() override;
 
diff --git a/chrome/browser/ui/views/permissions/chip_controller.cc b/chrome/browser/ui/views/permissions/chip_controller.cc
index d0e689325ba8c..f52ea8aa181b8 100644
--- a/chrome/browser/ui/views/permissions/chip_controller.cc
+++ b/chrome/browser/ui/views/permissions/chip_controller.cc
@@ -176,6 +176,7 @@ void ChipController::OnWidgetDestroying(views::Widget* widget) {
     OnPromptBubbleDismissed();
   }
 
+  disallowed_custom_cursors_scope_.RunAndReset();
   widget->RemoveObserver(this);
 
   CollapsePrompt(/*allow_restart=*/false);
@@ -308,6 +309,7 @@ void ChipController::ResetChipCallbacks() {
 void ChipController::RemoveBubbleObserverAndResetTimersAndChipCallbacks() {
   views::Widget* const bubble_widget = GetBubbleWidget();
   if (bubble_widget) {
+    disallowed_custom_cursors_scope_.RunAndReset();
     bubble_widget->RemoveObserver(this);
     bubble_widget->Close();
   }
@@ -479,6 +481,11 @@ void ChipController::OpenPermissionPromptBubble() {
     return;
   }
 
+  disallowed_custom_cursors_scope_ = permission_prompt_model_->GetDelegate()
+                                         .value()
+                                         ->GetAssociatedWebContents()
+                                         ->CreateDisallowCustomCursorScope();
+
   // prevent chip from collapsing while prompt bubble is open
   ResetTimers();
 
diff --git a/chrome/browser/ui/views/permissions/chip_controller.h b/chrome/browser/ui/views/permissions/chip_controller.h
index 2918d0baa25b4..7de77fac64547 100644
--- a/chrome/browser/ui/views/permissions/chip_controller.h
+++ b/chrome/browser/ui/views/permissions/chip_controller.h
@@ -8,6 +8,7 @@
 #include <cstddef>
 #include <memory>
 #include "base/check_is_test.h"
+#include "base/functional/callback_helpers.h"
 #include "base/timer/timer.h"
 #include "chrome/browser/ui/views/location_bar/omnibox_chip_button.h"
 #include "components/permissions/permission_prompt.h"
@@ -217,6 +218,8 @@ class ChipController : public permissions::PermissionRequestManager::Observer,
 
   views::ViewTracker bubble_tracker_;
 
+  base::ScopedClosureRunner disallowed_custom_cursors_scope_;
+
   base::WeakPtrFactory<ChipController> weak_factory_{this};
 };
 
diff --git a/chrome/browser/ui/views/permissions/permission_chip_unittest.cc b/chrome/browser/ui/views/permissions/permission_chip_unittest.cc
index 319fc246a1bdb..bc0b76db58e81 100644
--- a/chrome/browser/ui/views/permissions/permission_chip_unittest.cc
+++ b/chrome/browser/ui/views/permissions/permission_chip_unittest.cc
@@ -21,16 +21,22 @@ class TestDelegate : public permissions::PermissionPrompt::Delegate {
   explicit TestDelegate(
       const GURL& origin,
       const std::vector<permissions::RequestType> request_types,
-      bool with_gesture)
-      : TestDelegate(origin, request_types, with_gesture, absl::nullopt) {}
+      bool with_gesture,
+      content::WebContents* web_contents)
+      : TestDelegate(origin,
+                     request_types,
+                     with_gesture,
+                     absl::nullopt,
+                     web_contents) {}
 
   explicit TestDelegate(
       const GURL& origin,
       const std::vector<permissions::RequestType> request_types,
       bool with_gesture,
       absl::optional<permissions::PermissionUiSelector::QuietUiReason>
-          quiet_ui_reason)
-      : quiet_ui_reason_(quiet_ui_reason) {
+          quiet_ui_reason,
+      content::WebContents* web_contents)
+      : quiet_ui_reason_(quiet_ui_reason), web_contents_(web_contents) {
     std::transform(
         request_types.begin(), request_types.end(),
         std::back_inserter(requests_), [&](auto& request_type) {
@@ -90,6 +96,10 @@ class TestDelegate : public permissions::PermissionPrompt::Delegate {
     return weak_factory_.GetWeakPtr();
   }
 
+  content::WebContents* GetAssociatedWebContents() override {
+    return web_contents_;
+  }
+
   bool IsRequestInProgress() { return !requests_.empty(); }
 
   void SetAlreadyDisplayed() { was_current_request_already_displayed_ = true; }
@@ -100,6 +110,7 @@ class TestDelegate : public permissions::PermissionPrompt::Delegate {
   bool was_current_request_already_displayed_ = false;
   absl::optional<permissions::PermissionUiSelector::QuietUiReason>
       quiet_ui_reason_;
+  raw_ptr<content::WebContents> web_contents_;
   base::WeakPtrFactory<TestDelegate> weak_factory_{this};
 };
 }  // namespace
@@ -137,7 +148,8 @@ class PermissionChipUnitTest : public TestWithBrowserView {
 
 TEST_F(PermissionChipUnitTest, AlreadyDisplayedRequestTest) {
   TestDelegate delegate(GURL("https://test.origin"),
-                        {permissions::RequestType::kNotifications}, false);
+                        {permissions::RequestType::kNotifications}, false,
+                        web_contents_);
   delegate.SetAlreadyDisplayed();
 
   EXPECT_TRUE(delegate.WasCurrentRequestAlreadyDisplayed());
@@ -172,7 +184,8 @@ TEST_F(PermissionChipUnitTest, AlreadyDisplayedRequestTest) {
 
 TEST_F(PermissionChipUnitTest, DisplayChipAutoPopupTest) {
   TestDelegate delegate(GURL("https://test.origin"),
-                        {permissions::RequestType::kNotifications}, true);
+                        {permissions::RequestType::kNotifications}, true,
+                        web_contents_);
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
       chip_prompt.get_chip_controller_for_testing();
@@ -216,7 +229,8 @@ TEST_F(PermissionChipUnitTest, DisplayChipAutoPopupTest) {
 
 TEST_F(PermissionChipUnitTest, MultiClickOnChipAutoPopupTest) {
   TestDelegate delegate(GURL("https://test.origin"),
-                        {permissions::RequestType::kNotifications}, true);
+                        {permissions::RequestType::kNotifications}, true,
+                        web_contents_);
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
       chip_prompt.get_chip_controller_for_testing();
@@ -293,7 +307,8 @@ TEST_F(PermissionChipUnitTest, MultiClickOnChipAutoPopupTest) {
 TEST_F(PermissionChipUnitTest, DisplayQuietChipNoAbusiveTest) {
   TestDelegate delegate(
       GURL("https://test.origin"), {permissions::RequestType::kNotifications},
-      true, permissions::PermissionUiSelector::QuietUiReason::kEnabledInPrefs);
+      true, permissions::PermissionUiSelector::QuietUiReason::kEnabledInPrefs,
+      web_contents_);
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
       chip_prompt.get_chip_controller_for_testing();
@@ -338,7 +353,8 @@ TEST_F(PermissionChipUnitTest, DisplayQuietChipNoAbusiveTest) {
 TEST_F(PermissionChipUnitTest, MultiClickOnQuietChipNoAbusiveTest) {
   TestDelegate delegate(
       GURL("https://test.origin"), {permissions::RequestType::kNotifications},
-      true, permissions::PermissionUiSelector::QuietUiReason::kEnabledInPrefs);
+      true, permissions::PermissionUiSelector::QuietUiReason::kEnabledInPrefs,
+      web_contents_);
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
       chip_prompt.get_chip_controller_for_testing();
@@ -431,7 +447,8 @@ TEST_F(PermissionChipUnitTest, DisplayQuietChipAbusiveTest) {
   TestDelegate delegate(GURL("https://test.origin"),
                         {permissions::RequestType::kNotifications}, true,
                         permissions::PermissionUiSelector::QuietUiReason::
-                            kTriggeredDueToAbusiveRequests);
+                            kTriggeredDueToAbusiveRequests,
+                        web_contents_);
 
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
@@ -465,7 +482,8 @@ TEST_F(PermissionChipUnitTest, MultiClickOnQuietChipAbusiveTest) {
   TestDelegate delegate(GURL("https://test.origin"),
                         {permissions::RequestType::kNotifications}, true,
                         permissions::PermissionUiSelector::QuietUiReason::
-                            kTriggeredDueToAbusiveRequests);
+                            kTriggeredDueToAbusiveRequests,
+                        web_contents_);
   PermissionPromptChip chip_prompt(browser(), web_contents_, &delegate);
   ChipController* chip_controller =
       chip_prompt.get_chip_controller_for_testing();
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
index bd4ee44829c3b..84f2b5f9e13ec 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
@@ -42,6 +42,9 @@ void PermissionPromptBubble::ShowBubble() {
   prompt_bubble_->GetWidget()->AddObserver(this);
   parent_was_visible_when_activation_changed_ =
       prompt_bubble_->GetWidget()->GetPrimaryWindowWidget()->IsVisible();
+
+  disallowed_custom_cursors_scope_ =
+      delegate()->GetAssociatedWebContents()->CreateDisallowCustomCursorScope();
 }
 
 void PermissionPromptBubble::CleanUpPromptBubble() {
@@ -50,6 +53,7 @@ void PermissionPromptBubble::CleanUpPromptBubble() {
     widget->RemoveObserver(this);
     widget->CloseWithReason(views::Widget::ClosedReason::kUnspecified);
     prompt_bubble_ = nullptr;
+    disallowed_custom_cursors_scope_.RunAndReset();
   }
 }
 
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble.h b/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
index e6f656a7a0d0e..f81c7024049dc 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
@@ -49,6 +49,8 @@ class PermissionPromptBubble : public PermissionPromptDesktop,
 
   bool parent_was_visible_when_activation_changed_;
 
+  base::ScopedClosureRunner disallowed_custom_cursors_scope_;
+
   base::WeakPtrFactory<PermissionPromptBubble> weak_factory_{this};
 };
 
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view.cc
index d1132d68dab39..05f54f785854a 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view.cc
@@ -328,8 +328,6 @@ PermissionPromptBubbleView::~PermissionPromptBubbleView() = default;
 void PermissionPromptBubbleView::Show() {
   DCHECK(browser_->window());
 
-  // Set |parent_window| because some valid anchors can become hidden.
-  DCHECK(browser_->window());
   UpdateAnchorPosition();
 
   views::Widget* widget = views::BubbleDialogDelegateView::CreateBubble(this);
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_browsertest.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_browsertest.cc
index b099bf6dfeb1f..b2bf51e17ef2f 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_browsertest.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_browsertest.cc
@@ -46,8 +46,10 @@
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/test/browser_test.h"
+#include "content/public/test/cursor_utils.h"
 #include "content/public/test/test_utils.h"
 #include "net/dns/mock_host_resolver.h"
+#include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
 #include "ui/events/base_event_utils.h"
 #include "ui/views/test/ax_event_counter.h"
 #include "ui/views/test/button_test_api.h"
@@ -677,6 +679,44 @@ IN_PROC_BROWSER_TEST_P(PermissionPromptBubbleViewBrowserTest,
   }
 }
 
+IN_PROC_BROWSER_TEST_P(PermissionPromptBubbleViewBrowserTest,
+                       PermissionPromptBubbleDisallowsCustomCursors) {
+  ui::Cursor custom_cursor(ui::mojom::CursorType::kCustom);
+
+  content::RenderWidgetHost* widget_host = test_api_->manager()
+                                               ->GetAssociatedWebContents()
+                                               ->GetRenderViewHost()
+                                               ->GetWidget();
+
+  // Initially custom cursors are allowed.
+  widget_host->SetCursor(custom_cursor);
+  EXPECT_EQ(content::CursorUtils::GetLastCursorForWebContents(
+                test_api_->manager()->GetAssociatedWebContents()),
+            ui::mojom::CursorType::kCustom);
+
+  // While a permission prompt is active custom cursors are not allowed.
+  ShowUi("geolocation");
+  EXPECT_EQ(
+      test_api_->manager()->current_request_prompt_disposition_for_testing(),
+      GetParam() ? permissions::PermissionPromptDisposition::
+                       LOCATION_BAR_LEFT_CHIP_AUTO_BUBBLE
+                 : permissions::PermissionPromptDisposition::ANCHORED_BUBBLE);
+
+  widget_host->SetCursor(custom_cursor);
+  EXPECT_EQ(content::CursorUtils::GetLastCursorForWebContents(
+                test_api_->manager()->GetAssociatedWebContents()),
+            ui::mojom::CursorType::kPointer);
+
+  // After the prompt is resolved, custom cursors are allowed again.
+  test_api_->manager()->Accept();
+  base::RunLoop().RunUntilIdle();
+
+  widget_host->SetCursor(custom_cursor);
+  EXPECT_EQ(content::CursorUtils::GetLastCursorForWebContents(
+                test_api_->manager()->GetAssociatedWebContents()),
+            ui::mojom::CursorType::kCustom);
+}
+
 class PermissionPromptBubbleViewQuietUiBrowserTest
     : public PermissionPromptBubbleViewBrowserTest {
  public:
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_unittest.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_unittest.cc
index e29318afd6f94..64f7a04158769 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_unittest.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble_view_unittest.cc
@@ -73,6 +73,8 @@ class TestDelegate : public permissions::PermissionPrompt::Delegate {
     return weak_factory_.GetWeakPtr();
   }
 
+  content::WebContents* GetAssociatedWebContents() override { return nullptr; }
+
  private:
   std::vector<std::unique_ptr<permissions::PermissionRequest>> requests_;
   std::vector<permissions::PermissionRequest*> raw_requests_;
diff --git a/components/permissions/permission_prompt.h b/components/permissions/permission_prompt.h
index 9835f3ace9b00..f05f9550a8ebb 100644
--- a/components/permissions/permission_prompt.h
+++ b/components/permissions/permission_prompt.h
@@ -112,6 +112,8 @@ class PermissionPrompt {
     // survey is triggered to take appropriate actions.
     virtual void SetHatsShownCallback(base::OnceCallback<void()> callback) = 0;
 
+    virtual content::WebContents* GetAssociatedWebContents() = 0;
+
     virtual base::WeakPtr<Delegate> GetWeakPtr() = 0;
 
     // Recreate the UI view because the UI flavor needs to change. Returns true
diff --git a/components/permissions/permission_request_manager.cc b/components/permissions/permission_request_manager.cc
index 59c679344065e..fcecf8bad2da9 100644
--- a/components/permissions/permission_request_manager.cc
+++ b/components/permissions/permission_request_manager.cc
@@ -683,6 +683,11 @@ PermissionRequestManager::GetWeakPtr() {
   return weak_factory_.GetWeakPtr();
 }
 
+content::WebContents* PermissionRequestManager::GetAssociatedWebContents() {
+  content::WebContents& web_contents = GetWebContents();
+  return &web_contents;
+}
+
 bool PermissionRequestManager::RecreateView() {
   view_ = view_factory_.Run(web_contents(), this);
   if (!view_) {
diff --git a/components/permissions/permission_request_manager.h b/components/permissions/permission_request_manager.h
index 6f71a62258122..226b91cc3f2fb 100644
--- a/components/permissions/permission_request_manager.h
+++ b/components/permissions/permission_request_manager.h
@@ -20,6 +20,7 @@
 #include "components/permissions/permission_uma_util.h"
 #include "components/permissions/request_type.h"
 #include "content/public/browser/global_routing_id.h"
+#include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
@@ -173,6 +174,7 @@ class PermissionRequestManager
   void SetManageClicked() override;
   void SetLearnMoreClicked() override;
   base::WeakPtr<PermissionPrompt::Delegate> GetWeakPtr() override;
+  content::WebContents* GetAssociatedWebContents() override;
   bool RecreateView() override;
 
   void set_manage_clicked() { did_click_manage_ = true; }
diff --git a/content/browser/renderer_host/cursor_manager.cc b/content/browser/renderer_host/cursor_manager.cc
index 845c116dc4a6b..e783e00d23893 100644
--- a/content/browser/renderer_host/cursor_manager.cc
+++ b/content/browser/renderer_host/cursor_manager.cc
@@ -13,13 +13,14 @@ namespace content {
 CursorManager::CursorManager(RenderWidgetHostViewBase* root)
     : view_under_cursor_(root), root_view_(root) {}
 
-CursorManager::~CursorManager() {}
+CursorManager::~CursorManager() = default;
 
 void CursorManager::UpdateCursor(RenderWidgetHostViewBase* view,
                                  const ui::Cursor& cursor) {
   cursor_map_[view] = cursor;
-  if (view == view_under_cursor_)
-    root_view_->DisplayCursor(cursor);
+  if (view == view_under_cursor_) {
+    UpdateCursor();
+  }
 }
 
 void CursorManager::UpdateViewUnderCursor(RenderWidgetHostViewBase* view) {
@@ -33,13 +34,7 @@ void CursorManager::UpdateViewUnderCursor(RenderWidgetHostViewBase* view) {
   // ignored.
   root_view_->UpdateTooltip(std::u16string());
   view_under_cursor_ = view;
-  ui::Cursor cursor(ui::mojom::CursorType::kPointer);
-
-  auto it = cursor_map_.find(view);
-  if (it != cursor_map_.end())
-    cursor = it->second;
-
-  root_view_->DisplayCursor(cursor);
+  UpdateCursor();
 }
 
 void CursorManager::ViewBeingDestroyed(RenderWidgetHostViewBase* view) {
@@ -55,13 +50,65 @@ bool CursorManager::IsViewUnderCursor(RenderWidgetHostViewBase* view) const {
   return view == view_under_cursor_;
 }
 
+base::ScopedClosureRunner CursorManager::CreateDisallowCustomCursorScope() {
+  bool should_update_cursor = false;
+
+  // If custom cursors are about to be disallowed and the current view uses a
+  // custom cursor, the cursor needs to be updated to replace the custom cursor.
+  if (AreCustomCursorsAllowed() && cursor_map_[view_under_cursor_].type() ==
+                                       ui::mojom::CursorType::kCustom) {
+    should_update_cursor = true;
+  }
+
+  ++disallow_custom_cursor_scope_count_;
+
+  if (should_update_cursor) {
+    UpdateCursor();
+  }
+
+  return base::ScopedClosureRunner(
+      base::BindOnce(&CursorManager::DisallowCustomCursorScopeExpired,
+                     weak_factory_.GetWeakPtr()));
+}
+
 bool CursorManager::GetCursorForTesting(RenderWidgetHostViewBase* view,
                                         ui::Cursor& cursor) {
-  if (cursor_map_.find(view) == cursor_map_.end())
+  if (cursor_map_.find(view) == cursor_map_.end()) {
     return false;
+  }
 
   cursor = cursor_map_[view];
   return true;
 }
 
+bool CursorManager::AreCustomCursorsAllowed() const {
+  return disallow_custom_cursor_scope_count_ == 0;
+}
+
+void CursorManager::DisallowCustomCursorScopeExpired() {
+  --disallow_custom_cursor_scope_count_;
+
+  // If custom cursors started being allowed and the current view has a custom
+  // cursor, update the cursor to ensure the custom cursor is now displayed.
+  if (AreCustomCursorsAllowed() && cursor_map_[view_under_cursor_].type() ==
+                                       ui::mojom::CursorType::kCustom) {
+    UpdateCursor();
+  }
+}
+
+void CursorManager::UpdateCursor() {
+  ui::Cursor cursor(ui::mojom::CursorType::kPointer);
+
+  auto it = cursor_map_.find(view_under_cursor_);
+  if (it != cursor_map_.end() &&
+      (AreCustomCursorsAllowed() ||
+       it->second.type() != ui::mojom::CursorType::kCustom)) {
+    cursor = it->second;
+  }
+
+  last_set_cursor_type_for_testing_ = cursor.type();
+
+  root_view_->DisplayCursor(cursor);
+}
+
 }  // namespace content
diff --git a/content/browser/renderer_host/cursor_manager.h b/content/browser/renderer_host/cursor_manager.h
index 9e8a32f32054c..daffc080331f0 100644
--- a/content/browser/renderer_host/cursor_manager.h
+++ b/content/browser/renderer_host/cursor_manager.h
@@ -7,9 +7,12 @@
 
 #include <map>
 
+#include "base/functional/callback_helpers.h"
 #include "base/memory/raw_ptr.h"
+#include "base/memory/weak_ptr.h"
 #include "content/common/content_export.h"
 #include "ui/base/cursor/cursor.h"
+#include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
 
 namespace content {
 
@@ -22,8 +25,7 @@ class RenderWidgetHostViewBase;
 // update was received for the current view.
 class CONTENT_EXPORT CursorManager {
  public:
-
-  CursorManager(RenderWidgetHostViewBase* root);
+  explicit CursorManager(RenderWidgetHostViewBase* root);
   ~CursorManager();
 
   // Called for any RenderWidgetHostView that received an UpdateCursor message
@@ -43,12 +45,22 @@ class CONTENT_EXPORT CursorManager {
   // cursor. This is only used for cursor triggered tooltips.
   bool IsViewUnderCursor(RenderWidgetHostViewBase*) const;
 
+  [[nodiscard]] base::ScopedClosureRunner CreateDisallowCustomCursorScope();
+
   // Accessor for browser tests, enabling verification of the cursor_map_.
   // Returns false if the provided View is not in the map, and outputs
   // the cursor otherwise.
   bool GetCursorForTesting(RenderWidgetHostViewBase*, ui::Cursor&);
 
+  ui::mojom::CursorType GetLastSetCursorTypeForTesting() {
+    return last_set_cursor_type_for_testing_;
+  }
+
  private:
+  bool AreCustomCursorsAllowed() const;
+  void DisallowCustomCursorScopeExpired();
+  void UpdateCursor();
+
   // Stores the last received cursor from each RenderWidgetHostView.
   std::map<RenderWidgetHostViewBase*, ui::Cursor> cursor_map_;
 
@@ -59,6 +71,12 @@ class CONTENT_EXPORT CursorManager {
   // The root view is the target for DisplayCursor calls whenever the active
   // cursor needs to change.
   raw_ptr<RenderWidgetHostViewBase> root_view_;
+
+  int disallow_custom_cursor_scope_count_ = 0;
+
+  ui::mojom::CursorType last_set_cursor_type_for_testing_;
+
+  base::WeakPtrFactory<CursorManager> weak_factory_{this};
 };
 
 }  // namespace content
diff --git a/content/browser/renderer_host/cursor_manager_unittest.cc b/content/browser/renderer_host/cursor_manager_unittest.cc
index 3f2e7a76f9ff7..f78fff251c3b8 100644
--- a/content/browser/renderer_host/cursor_manager_unittest.cc
+++ b/content/browser/renderer_host/cursor_manager_unittest.cc
@@ -26,6 +26,11 @@ namespace content {
 
 namespace {
 
+const ui::Cursor kCursorHand(ui::mojom::CursorType::kHand);
+const ui::Cursor kCursorCross(ui::mojom::CursorType::kCross);
+const ui::Cursor kCursorPointer(ui::mojom::CursorType::kPointer);
+const ui::Cursor kCursorCustom(ui::mojom::CursorType::kCustom);
+
 class MockRenderWidgetHostViewForCursors : public TestRenderWidgetHostView {
  public:
   MockRenderWidgetHostViewForCursors(RenderWidgetHost* host, bool top_view)
@@ -107,13 +112,11 @@ TEST_F(CursorManagerTest, CursorOnSingleView) {
   // The view should be using the default cursor.
   EXPECT_EQ(top_view_->cursor(), ui::Cursor());
 
-  ui::Cursor cursor_hand(ui::mojom::CursorType::kHand);
-
   // Update the view with a non-default cursor.
-  top_view_->GetCursorManager()->UpdateCursor(top_view_, cursor_hand);
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
 
   // Verify the RenderWidgetHostView now uses the correct cursor.
-  EXPECT_EQ(top_view_->cursor(), cursor_hand);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
 }
 
 // Verify cursor interactions between a parent frame and an out-of-process
@@ -123,20 +126,18 @@ TEST_F(CursorManagerTest, CursorOverChildView) {
   std::unique_ptr<MockRenderWidgetHostViewForCursors> child_view(
       new MockRenderWidgetHostViewForCursors(widget_host.get(), false));
 
-  ui::Cursor cursor_hand(ui::mojom::CursorType::kHand);
-
   // Set the child frame's cursor to a hand. This should not propagate to the
   // top-level view without the mouse moving over the child frame.
-  top_view_->GetCursorManager()->UpdateCursor(child_view.get(), cursor_hand);
-  EXPECT_NE(top_view_->cursor(), cursor_hand);
+  top_view_->GetCursorManager()->UpdateCursor(child_view.get(), kCursorHand);
+  EXPECT_NE(top_view_->cursor(), kCursorHand);
 
   // Now moving the mouse over the child frame should update the overall cursor.
   top_view_->GetCursorManager()->UpdateViewUnderCursor(child_view.get());
-  EXPECT_EQ(top_view_->cursor(), cursor_hand);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
 
   // Destruction of the child view should restore the parent frame's cursor.
   top_view_->GetCursorManager()->ViewBeingDestroyed(child_view.get());
-  EXPECT_NE(top_view_->cursor(), cursor_hand);
+  EXPECT_NE(top_view_->cursor(), kCursorHand);
 }
 
 // Verify interactions between two independent OOPIFs, including interleaving
@@ -150,39 +151,163 @@ TEST_F(CursorManagerTest, CursorOverMultipleChildViews) {
   std::unique_ptr<MockRenderWidgetHostViewForCursors> child_view2(
       new MockRenderWidgetHostViewForCursors(widget_host2.get(), false));
 
-  ui::Cursor cursor_hand(ui::mojom::CursorType::kHand);
-  ui::Cursor cursor_cross(ui::mojom::CursorType::kCross);
-  ui::Cursor cursor_pointer(ui::mojom::CursorType::kPointer);
-
   // Initialize each View to a different cursor.
-  top_view_->GetCursorManager()->UpdateCursor(top_view_, cursor_hand);
-  top_view_->GetCursorManager()->UpdateCursor(child_view1.get(), cursor_cross);
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  top_view_->GetCursorManager()->UpdateCursor(child_view1.get(), kCursorCross);
   top_view_->GetCursorManager()->UpdateCursor(child_view2.get(),
-                                              cursor_pointer);
-  EXPECT_EQ(top_view_->cursor(), cursor_hand);
+                                              kCursorPointer);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
 
   // Simulate moving the mouse between child views and receiving cursor updates.
   top_view_->GetCursorManager()->UpdateViewUnderCursor(child_view1.get());
-  EXPECT_EQ(top_view_->cursor(), cursor_cross);
+  EXPECT_EQ(top_view_->cursor(), kCursorCross);
   top_view_->GetCursorManager()->UpdateViewUnderCursor(child_view2.get());
-  EXPECT_EQ(top_view_->cursor(), cursor_pointer);
+  EXPECT_EQ(top_view_->cursor(), kCursorPointer);
 
   // Simulate cursor updates to both child views and the parent view. An
   // update to child_view1 or the parent view should not change the current
   // cursor because the mouse is over child_view2.
-  top_view_->GetCursorManager()->UpdateCursor(child_view1.get(), cursor_hand);
-  EXPECT_EQ(top_view_->cursor(), cursor_pointer);
-  top_view_->GetCursorManager()->UpdateCursor(child_view2.get(), cursor_cross);
-  EXPECT_EQ(top_view_->cursor(), cursor_cross);
-  top_view_->GetCursorManager()->UpdateCursor(top_view_, cursor_hand);
-  EXPECT_EQ(top_view_->cursor(), cursor_cross);
+  top_view_->GetCursorManager()->UpdateCursor(child_view1.get(), kCursorHand);
+  EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+  top_view_->GetCursorManager()->UpdateCursor(child_view2.get(), kCursorCross);
+  EXPECT_EQ(top_view_->cursor(), kCursorCross);
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  EXPECT_EQ(top_view_->cursor(), kCursorCross);
 
   // Similarly, destroying child_view1 should have no effect on the cursor,
   // but destroying child_view2 should change it.
   top_view_->GetCursorManager()->ViewBeingDestroyed(child_view1.get());
-  EXPECT_EQ(top_view_->cursor(), cursor_cross);
+  EXPECT_EQ(top_view_->cursor(), kCursorCross);
   top_view_->GetCursorManager()->ViewBeingDestroyed(child_view2.get());
-  EXPECT_EQ(top_view_->cursor(), cursor_hand);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+}
+
+TEST_F(CursorManagerTest,
+       CustomCursorDisallowedScope_CustomCursorsAreNotAllowed) {
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorCustom);
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+}
+
+TEST_F(CursorManagerTest,
+       CustomCursorDisallowedScope_OtherCursorsStillAllowed) {
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorHand);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+}
+
+TEST_F(CursorManagerTest,
+       CustomCursorDisallowedScope_CustomCursorSetDuringScope) {
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorHand);
+
+    top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorCustom);
+    EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+}
+
+TEST_F(CursorManagerTest,
+       CustomCursorDisallowedScope_CustomCursorRemovedDuringScope) {
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorCustom);
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+
+    top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+    EXPECT_EQ(top_view_->cursor(), kCursorHand);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+}
+
+TEST_F(CursorManagerTest, CustomCursorDisallowedScope_MultipleScopes) {
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorCustom);
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+
+  auto disallow_scope1 =
+      top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+  auto disallow_scope2 =
+      top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+  EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+
+  disallow_scope1.RunAndReset();
+  EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+
+  auto disallow_scope3 =
+      top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+  disallow_scope2.RunAndReset();
+  EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+
+  disallow_scope3.RunAndReset();
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+}
+
+TEST_F(CursorManagerTest, CustomCursorDisallowedScope_CustomCursorViewFocused) {
+  std::unique_ptr<RenderWidgetHostImpl> widget_host(MakeNewWidgetHost());
+  std::unique_ptr<MockRenderWidgetHostViewForCursors> child_view(
+      new MockRenderWidgetHostViewForCursors(widget_host.get(), false));
+
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  top_view_->GetCursorManager()->UpdateCursor(child_view.get(), kCursorCustom);
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorHand);
+
+    top_view_->GetCursorManager()->UpdateViewUnderCursor(child_view.get());
+    EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+}
+
+TEST_F(CursorManagerTest,
+       CustomCursorDisallowedScope_CustomCursorViewFocusRemoved) {
+  std::unique_ptr<RenderWidgetHostImpl> widget_host(MakeNewWidgetHost());
+  std::unique_ptr<MockRenderWidgetHostViewForCursors> child_view(
+      new MockRenderWidgetHostViewForCursors(widget_host.get(), false));
+
+  top_view_->GetCursorManager()->UpdateCursor(top_view_, kCursorHand);
+  top_view_->GetCursorManager()->UpdateCursor(child_view.get(), kCursorCustom);
+  top_view_->GetCursorManager()->UpdateViewUnderCursor(child_view.get());
+  EXPECT_EQ(top_view_->cursor(), kCursorCustom);
+
+  {
+    auto disallow_scope =
+        top_view_->GetCursorManager()->CreateDisallowCustomCursorScope();
+    EXPECT_EQ(top_view_->cursor(), kCursorPointer);
+
+    top_view_->GetCursorManager()->UpdateViewUnderCursor(top_view_);
+    EXPECT_EQ(top_view_->cursor(), kCursorHand);
+  }
+
+  EXPECT_EQ(top_view_->cursor(), kCursorHand);
 }
 
 }  // namespace content
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index b04b88882583c..46198a2d2ec77 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -80,6 +80,7 @@
 #include "content/browser/preloading/prerender/prerender_new_tab_handle.h"
 #include "content/browser/renderer_host/agent_scheduling_group_host.h"
 #include "content/browser/renderer_host/cross_process_frame_connector.h"
+#include "content/browser/renderer_host/cursor_manager.h"
 #include "content/browser/renderer_host/frame_token_message_queue.h"
 #include "content/browser/renderer_host/frame_tree_node.h"
 #include "content/browser/renderer_host/navigation_entry_impl.h"
@@ -2212,6 +2213,10 @@ void WebContentsImpl::SetHasPictureInPictureCommon(
     UpdateVisibilityAndNotifyPageAndView(visibility_);
 }
 
+void WebContentsImpl::DisallowCustomCursorScopeExpired() {
+  --disallow_custom_cursor_scope_count_;
+}
+
 void WebContentsImpl::SetHasPictureInPictureVideo(
     bool has_picture_in_picture_video) {
   OPTIONAL_TRACE_EVENT1("content",
@@ -9629,10 +9634,19 @@ void WebContentsImpl::AboutToBeDiscarded(WebContents* new_contents) {
                              new_contents);
 }
 
+base::ScopedClosureRunner WebContentsImpl::CreateDisallowCustomCursorScope() {
+  CursorManager* manager = GetPrimaryMainFrame()
+                               ->GetRenderWidgetHost()
+                               ->GetRenderWidgetHostViewBase()
+                               ->GetCursorManager();
+  return manager->CreateDisallowCustomCursorScope();
+}
+
 bool WebContentsImpl::CancelPrerendering(FrameTreeNode* frame_tree_node,
                                          PrerenderFinalStatus final_status) {
-  if (!frame_tree_node)
+  if (!frame_tree_node) {
     return false;
+  }
 
   DCHECK_EQ(this, FromFrameTreeNode(frame_tree_node));
 
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index d266b5b70d02e..4179436dd960f 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -583,6 +583,9 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
 
   void AboutToBeDiscarded(WebContents* new_contents) override;
 
+  [[nodiscard]] base::ScopedClosureRunner CreateDisallowCustomCursorScope()
+      override;
+
   // RenderFrameHostDelegate ---------------------------------------------------
   bool OnMessageReceived(RenderFrameHostImpl* render_frame_host,
                          const IPC::Message& message) override;
@@ -1893,6 +1896,9 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   // SetHasPictureInPictureDocument().
   void SetHasPictureInPictureCommon(bool has_picture_in_picture);
 
+  // A scope that disallows custom cursors has expired.
+  void DisallowCustomCursorScopeExpired();
+
   // Data for core operation ---------------------------------------------------
 
   // Delegate for notifying our owner about stuff. Not owned by us.
@@ -2365,6 +2371,10 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   // navigation commits in the primary main frame.
   bool last_navigation_was_prerender_activation_for_devtools_ = false;
 
+  // Counts the number of open scopes that disallow custom cursors in this web
+  // contents. Custom cursors are allowed if this is 0.
+  int disallow_custom_cursor_scope_count_ = 0;
+
   base::WeakPtrFactory<WebContentsImpl> loading_weak_factory_{this};
   base::WeakPtrFactory<WebContentsImpl> weak_factory_{this};
 };
diff --git a/content/public/browser/BUILD.gn b/content/public/browser/BUILD.gn
index 11da6d42e9ae7..62932eeb475bd 100644
--- a/content/public/browser/BUILD.gn
+++ b/content/public/browser/BUILD.gn
@@ -533,6 +533,7 @@ source_set("browser_sources") {
     "//ui/accessibility",
     "//ui/base",
     "//ui/base/clipboard",
+    "//ui/base/cursor/mojom:cursor_type_shared",
     "//ui/events",
     "//ui/gl",
     "//ui/shell_dialogs",
diff --git a/content/public/browser/web_contents.h b/content/public/browser/web_contents.h
index 5644b0efa9a3e..433f3fe22d422 100644
--- a/content/public/browser/web_contents.h
+++ b/content/public/browser/web_contents.h
@@ -46,6 +46,7 @@
 #include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/accessibility/ax_mode.h"
+#include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
 #include "ui/display/types/display_constants.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
@@ -1392,6 +1393,12 @@ class WebContents : public PageNavigator,
       absl::optional<base::RepeatingCallback<bool(const GURL&)>>
           url_match_predicate = absl::nullopt) = 0;
 
+  // Returns a scope object that needs to be owned by caller in order to
+  // disallow custom cursors. Custom cursors are diallowed in this web contents
+  // for as long as any of the returned |ScopedClosureRunner| objects is alive.
+  [[nodiscard]] virtual base::ScopedClosureRunner
+  CreateDisallowCustomCursorScope() = 0;
+
  private:
   // This interface should only be implemented inside content.
   friend class WebContentsImpl;
diff --git a/content/public/test/cursor_utils.cc b/content/public/test/cursor_utils.cc
new file mode 100644
index 0000000000000..1c2ad37b5d58c
--- /dev/null
+++ b/content/public/test/cursor_utils.cc
@@ -0,0 +1,26 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/public/test/cursor_utils.h"
+
+#include "content/browser/renderer_host/cursor_manager.h"
+#include "content/browser/renderer_host/render_widget_host_impl.h"
+#include "content/browser/renderer_host/render_widget_host_view_base.h"
+#include "content/browser/web_contents/web_contents_impl.h"
+
+namespace content {
+
+// static
+ui::mojom::CursorType CursorUtils::GetLastCursorForWebContents(
+    WebContents* web_contents) {
+  WebContentsImpl* web_contents_impl =
+      static_cast<WebContentsImpl*>(web_contents);
+  CursorManager* manager = web_contents_impl->GetPrimaryMainFrame()
+                               ->GetRenderWidgetHost()
+                               ->GetRenderWidgetHostViewBase()
+                               ->GetCursorManager();
+  return manager->GetLastSetCursorTypeForTesting();
+}
+
+}  // namespace content
diff --git a/content/public/test/cursor_utils.h b/content/public/test/cursor_utils.h
new file mode 100644
index 0000000000000..e6bfdef341928
--- /dev/null
+++ b/content/public/test/cursor_utils.h
@@ -0,0 +1,19 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_PUBLIC_TEST_CURSOR_UTILS_H_
+#define CONTENT_PUBLIC_TEST_CURSOR_UTILS_H_
+
+#include "content/public/browser/web_contents.h"
+#include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
+
+namespace content {
+class CursorUtils {
+ public:
+  static ui::mojom::CursorType GetLastCursorForWebContents(
+      WebContents* web_contents);
+};
+}  // namespace content
+
+#endif  // CONTENT_PUBLIC_TEST_CURSOR_UTILS_H_
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index a6abdae9ab241..8596f66a45744 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -167,6 +167,8 @@ static_library("test_support") {
     "../public/test/content_mock_cert_verifier.h",
     "../public/test/content_test_suite_base.cc",
     "../public/test/content_test_suite_base.h",
+    "../public/test/cursor_utils.cc",
+    "../public/test/cursor_utils.h",
     "../public/test/download_test_observer.cc",
     "../public/test/download_test_observer.h",
     "../public/test/embedded_worker_instance_test_harness.cc",
diff --git a/content/test/test_render_view_host.cc b/content/test/test_render_view_host.cc
index 35d93148e2dda..c883f34a9113f 100644
--- a/content/test/test_render_view_host.cc
+++ b/content/test/test_render_view_host.cc
@@ -50,7 +50,10 @@
 namespace content {
 
 TestRenderWidgetHostView::TestRenderWidgetHostView(RenderWidgetHost* rwh)
-    : RenderWidgetHostViewBase(rwh), is_showing_(false), is_occluded_(false) {
+    : RenderWidgetHostViewBase(rwh),
+      is_showing_(false),
+      is_occluded_(false),
+      cursor_manager_(this) {
 #if BUILDFLAG(IS_ANDROID)
   frame_sink_id_ = AllocateFrameSinkId();
   GetHostFrameSinkManager()->RegisterFrameSinkId(
@@ -324,6 +327,10 @@ ui::Compositor* TestRenderWidgetHostView::GetCompositor() {
   return compositor_;
 }
 
+CursorManager* TestRenderWidgetHostView::GetCursorManager() {
+  return &cursor_manager_;
+}
+
 TestRenderWidgetHostViewChildFrame::TestRenderWidgetHostViewChildFrame(
     RenderWidgetHost* rwh)
     : RenderWidgetHostViewChildFrame(
diff --git a/content/test/test_render_view_host.h b/content/test/test_render_view_host.h
index 73f06f09381c8..47401f74f6443 100644
--- a/content/test/test_render_view_host.h
+++ b/content/test/test_render_view_host.h
@@ -16,6 +16,7 @@
 #include "build/build_config.h"
 #include "components/viz/common/surfaces/frame_sink_id.h"
 #include "components/viz/host/host_frame_sink_client.h"
+#include "content/browser/renderer_host/cursor_manager.h"
 #include "content/browser/renderer_host/render_view_host_impl.h"
 #include "content/browser/renderer_host/render_widget_host_view_base.h"
 #include "content/browser/renderer_host/render_widget_host_view_child_frame.h"
@@ -127,6 +128,7 @@ class TestRenderWidgetHostView : public RenderWidgetHostViewBase,
   std::unique_ptr<SyntheticGestureTarget> CreateSyntheticGestureTarget()
       override;
   ui::Compositor* GetCompositor() override;
+  CursorManager* GetCursorManager() override;
 
   bool is_showing() const { return is_showing_; }
   bool is_occluded() const { return is_occluded_; }
@@ -189,6 +191,8 @@ class TestRenderWidgetHostView : public RenderWidgetHostViewBase,
   absl::optional<DisplayFeature> display_feature_;
 
   raw_ptr<ui::Compositor> compositor_ = nullptr;
+
+  CursorManager cursor_manager_;
 };
 
 // TestRenderWidgetHostViewChildFrame -----------------------------------------
