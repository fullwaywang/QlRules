commit 310887c96175af0e8fe3cabb7cb4ab286ddc6493	310887c96175af0e8fe3cabb7cb4ab286ddc6493
Author: Mitsuru Oshima <oshima@chromium.org>
Date:   Tue Mar 21 16:32:21 2023 +0000

    Check if EventTargeter was destroyed during event dispatch.
    
    New test cases are added that delete the targeter during dispatch and find target phase.
    
    Bug: 1350561
    Test: covered by unittests. passed asan.
    Change-Id: I314b7b76d5cd34ad6feae62686e442d734ebd6ee
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4342920
    Commit-Queue: Mitsuru Oshima <oshima@chromium.org>
    Reviewed-by: Scott Violet <sky@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1119984}

diff --git a/ui/events/BUILD.gn b/ui/events/BUILD.gn
index 47f588746306f..af2d65cac3a18 100644
--- a/ui/events/BUILD.gn
+++ b/ui/events/BUILD.gn
@@ -225,6 +225,7 @@ component("events") {
     "event_rewriter_continuation.h",
     "event_source.cc",
     "event_target.cc",
+    "event_targeter.cc",
     "event_utils.cc",
     "events_exports.cc",
     "events_stub.cc",
diff --git a/ui/events/event_processor.cc b/ui/events/event_processor.cc
index 2bf8068d56fba..a4f25f2450bd7 100644
--- a/ui/events/event_processor.cc
+++ b/ui/events/event_processor.cc
@@ -34,10 +34,13 @@ EventDispatchDetails EventProcessor::OnEventFromSource(Event* event) {
     EventTarget* root = GetRootForEvent(event_to_dispatch);
     DCHECK(root);
     EventTargeter* targeter = root->GetEventTargeter();
+    base::WeakPtr<EventTargeter> weak_targeter;
     if (targeter) {
+      weak_targeter = targeter->GetWeakPtr();
       target = targeter->FindTargetForEvent(root, event_to_dispatch);
     } else {
       targeter = GetDefaultEventTargeter();
+      weak_targeter = targeter->GetWeakPtr();
       if (event_to_dispatch->target())
         target = root;
       else
@@ -70,8 +73,10 @@ EventDispatchDetails EventProcessor::OnEventFromSource(Event* event) {
         return details;
       }
 
-      if (details.target_destroyed || event->handled() || !target)
+      if (details.target_destroyed || event->handled() || !target ||
+          !weak_targeter) {
         break;
+      }
 
       DCHECK(targeter);
       target = targeter->FindNextBestTarget(target, event_to_dispatch);
diff --git a/ui/events/event_processor_unittest.cc b/ui/events/event_processor_unittest.cc
index 347cfee04e3d9..0dad1d153fbf2 100644
--- a/ui/events/event_processor_unittest.cc
+++ b/ui/events/event_processor_unittest.cc
@@ -390,98 +390,147 @@ TEST_F(EventProcessorTest, HandlerSequence) {
 
 namespace {
 
-class SelfDestroyingEventProcessor : public TestEventProcessor {
+enum DestroyTarget { kProcessor, kTargeter };
+
+class DestroyDuringDispatchEventProcessor : public TestEventProcessor {
  public:
-  SelfDestroyingEventProcessor() = default;
-  SelfDestroyingEventProcessor(const SelfDestroyingEventProcessor&) = delete;
-  SelfDestroyingEventProcessor& operator=(const SelfDestroyingEventProcessor&) =
-      delete;
-  ~SelfDestroyingEventProcessor() override = default;
+  DestroyDuringDispatchEventProcessor() = default;
+  DestroyDuringDispatchEventProcessor(
+      const DestroyDuringDispatchEventProcessor&) = delete;
+  DestroyDuringDispatchEventProcessor& operator=(
+      const DestroyDuringDispatchEventProcessor&) = delete;
+  ~DestroyDuringDispatchEventProcessor() override = default;
 
  protected:
   EventDispatchDetails PostDispatchEvent(EventTarget* target,
                                          const Event& event) override;
 };
 
-class SelfDestroyingTestEventTarget : public TestEventTarget {
+class DestroyDuringDispatchEventTarget : public TestEventTarget {
  public:
-  SelfDestroyingTestEventTarget()
-      : processor_(std::make_unique<SelfDestroyingEventProcessor>()) {}
+  explicit DestroyDuringDispatchEventTarget(DestroyTarget target)
+      : destroy_target_(target),
+        processor_(std::make_unique<DestroyDuringDispatchEventProcessor>()) {}
 
-  SelfDestroyingTestEventTarget(const SelfDestroyingTestEventTarget&) = delete;
-  SelfDestroyingTestEventTarget& operator=(
-      const SelfDestroyingTestEventTarget&) = delete;
+  DestroyDuringDispatchEventTarget(const DestroyDuringDispatchEventTarget&) =
+      delete;
+  DestroyDuringDispatchEventTarget& operator=(
+      const DestroyDuringDispatchEventTarget&) = delete;
 
   TestEventProcessor* processor() { return processor_.get(); }
 
-  void DestroyProcessor() { processor_.reset(); }
+  void Destroy() {
+    switch (destroy_target_) {
+      case kProcessor:
+        processor_.reset();
+        break;
+      case kTargeter:
+        SetEventTargeter(nullptr);
+    }
+  }
 
  private:
-  std::unique_ptr<SelfDestroyingEventProcessor> processor_;
+  DestroyTarget destroy_target_;
+  std::unique_ptr<TestEventProcessor> processor_;
 };
 
-EventDispatchDetails SelfDestroyingEventProcessor::PostDispatchEvent(
+EventDispatchDetails DestroyDuringDispatchEventProcessor::PostDispatchEvent(
     EventTarget* target,
     const Event& event) {
-  static_cast<SelfDestroyingTestEventTarget*>(target)->DestroyProcessor();
+  static_cast<DestroyDuringDispatchEventTarget*>(target)->Destroy();
   return EventDispatchDetails();
 }
 
 }  // namespace
 
-TEST(EventProcessorCrashTest, Basic) {
-  auto root = std::make_unique<TestEventTarget>();
-  auto target = std::make_unique<SelfDestroyingTestEventTarget>();
-  root->SetEventTargeter(
-      std::make_unique<TestEventTargeter>(target.get(), false));
-  TestEventProcessor* processor = target->processor();
-  processor->SetRoot(std::move(root));
-
-  MouseEvent mouse(ET_MOUSE_MOVED, gfx::Point(10, 10), gfx::Point(10, 10),
-                   EventTimeForNow(), EF_NONE, EF_NONE);
-  EXPECT_TRUE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+TEST(EventProcessorCrashTest, DestroyDuringDispatch) {
+  for (auto destroy_target : {kProcessor, kTargeter}) {
+    SCOPED_TRACE(destroy_target == kProcessor ? "Processor" : "Targeter");
+    auto root = std::make_unique<TestEventTarget>();
+    auto target =
+        std::make_unique<DestroyDuringDispatchEventTarget>(destroy_target);
+    root->SetEventTargeter(
+        std::make_unique<TestEventTargeter>(target.get(), false));
+    TestEventProcessor* processor = target->processor();
+    auto* target_ptr = target.get();
+    processor->SetRoot(std::move(root));
+
+    MouseEvent mouse(ET_MOUSE_MOVED, gfx::Point(10, 10), gfx::Point(10, 10),
+                     EventTimeForNow(), EF_NONE, EF_NONE);
+
+    if (destroy_target == kProcessor) {
+      EXPECT_TRUE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+    } else {
+      EXPECT_FALSE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+      EXPECT_FALSE(target_ptr->GetEventTargeter());
+    }
+  }
 }
 
 namespace {
 
-class SelfDestroyingTestEventTargeter : public TestEventTargeter {
+class DestroyDuringFindTargetEventTargeter : public TestEventTargeter {
  public:
-  explicit SelfDestroyingTestEventTargeter(std::unique_ptr<EventTarget> root)
+  DestroyDuringFindTargetEventTargeter(std::unique_ptr<TestEventTarget> root,
+                                       DestroyTarget target)
       : TestEventTargeter(nullptr, false),
+        destroy_target_(target),
+        root_(root.get()),
         processor_(std::make_unique<TestEventProcessor>()) {
     processor_->SetRoot(std::move(root));
   }
-  SelfDestroyingTestEventTargeter(const SelfDestroyingTestEventTarget&) =
-      delete;
-  SelfDestroyingTestEventTargeter& operator=(
-      const SelfDestroyingTestEventTargeter&) = delete;
-  ~SelfDestroyingTestEventTargeter() override = default;
+  DestroyDuringFindTargetEventTargeter(
+      const DestroyDuringFindTargetEventTargeter&) = delete;
+  DestroyDuringFindTargetEventTargeter& operator=(
+      const DestroyDuringFindTargetEventTargeter&) = delete;
+  ~DestroyDuringFindTargetEventTargeter() override = default;
 
   // EventTargeter:
   EventTarget* FindTargetForEvent(EventTarget* root, Event* event) override {
-    processor_.reset();
+    switch (destroy_target_) {
+      case kProcessor:
+        processor_.reset();
+        break;
+      case kTargeter:
+        processor_.release();
+        DCHECK_EQ(this, root_->GetEventTargeter());
+        root_->SetEventTargeter(nullptr);
+    }
     return nullptr;
   }
 
   EventProcessor* processor() { return processor_.get(); }
 
  private:
+  DestroyTarget destroy_target_;
+  TestEventTarget* root_;
   std::unique_ptr<TestEventProcessor> processor_;
 };
 
 }  // namespace
 
 TEST(EventProcessorCrashTest, DestroyDuringFindTarget) {
-  auto root = std::make_unique<TestEventTarget>();
-  TestEventTarget* root_ptr = root.get();
-  auto event_targeter =
-      std::make_unique<SelfDestroyingTestEventTargeter>(std::move(root));
-  auto* processor = event_targeter->processor();
-  root_ptr->SetEventTargeter(std::move(event_targeter));
-
-  MouseEvent mouse(ET_MOUSE_MOVED, gfx::Point(10, 10), gfx::Point(10, 10),
-                   EventTimeForNow(), EF_NONE, EF_NONE);
-  EXPECT_TRUE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+  for (auto destroy_target : {kProcessor, kTargeter}) {
+    SCOPED_TRACE(destroy_target == kProcessor ? "Processor" : "Targeter");
+    auto root = std::make_unique<TestEventTarget>();
+    TestEventTarget* root_ptr = root.get();
+    auto event_targeter =
+        std::make_unique<DestroyDuringFindTargetEventTargeter>(std::move(root),
+                                                               destroy_target);
+    auto* processor = event_targeter->processor();
+    root_ptr->SetEventTargeter(std::move(event_targeter));
+
+    MouseEvent mouse(ET_MOUSE_MOVED, gfx::Point(10, 10), gfx::Point(10, 10),
+                     EventTimeForNow(), EF_NONE, EF_NONE);
+    if (destroy_target == kProcessor) {
+      EXPECT_TRUE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+    } else {
+      EXPECT_FALSE(processor->OnEventFromSource(&mouse).dispatcher_destroyed);
+      EXPECT_FALSE(root_ptr->GetEventTargeter());
+      // TestEventTargeter releases the processor when deleting the targeter.
+      delete processor;
+    }
+  }
 }
 
 }  // namespace test
diff --git a/ui/events/event_targeter.cc b/ui/events/event_targeter.cc
new file mode 100644
index 0000000000000..63254c9e36d3d
--- /dev/null
+++ b/ui/events/event_targeter.cc
@@ -0,0 +1,13 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/events/event_targeter.h"
+
+namespace ui {
+
+EventTargeter::EventTargeter() = default;
+
+EventTargeter::~EventTargeter() = default;
+
+}  // namespace ui
diff --git a/ui/events/event_targeter.h b/ui/events/event_targeter.h
index 45be128391e22..185bc145b2436 100644
--- a/ui/events/event_targeter.h
+++ b/ui/events/event_targeter.h
@@ -5,6 +5,7 @@
 #ifndef UI_EVENTS_EVENT_TARGETER_H_
 #define UI_EVENTS_EVENT_TARGETER_H_
 
+#include "base/memory/weak_ptr.h"
 #include "ui/events/events_export.h"
 
 namespace ui {
@@ -14,7 +15,10 @@ class EventTarget;
 
 class EVENTS_EXPORT EventTargeter {
  public:
-  virtual ~EventTargeter() {}
+  EventTargeter();
+  EventTargeter(const EventTargeter&) = delete;
+  EventTargeter& operator=(const EventTargeter&) = delete;
+  virtual ~EventTargeter();
 
   // Returns the target |event| should be dispatched to. If there is no such
   // target, return NULL. If |event| is a located event, the location of |event|
@@ -31,6 +35,15 @@ class EVENTS_EXPORT EventTargeter {
   // coordinate space).
   virtual EventTarget* FindNextBestTarget(EventTarget* previous_target,
                                           Event* event) = 0;
+
+ private:
+  friend class EventProcessor;
+
+  base::WeakPtr<EventTargeter> GetWeakPtr() {
+    return weak_ptr_factory_.GetWeakPtr();
+  }
+
+  base::WeakPtrFactory<EventTargeter> weak_ptr_factory_{this};
 };
 
 }  // namespace ui
