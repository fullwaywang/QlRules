commit f106eee10038c2ee5b6056aaf3f6d5229be6dcdd
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed May 26 14:44:11 2010 -0700

    pids: fix fork_idle() to setup ->pids correctly
    
    copy_process(pid => &init_struct_pid) doesn't do attach_pid/etc.
    
    It shouldn't, but this means that the idle threads run with the wrong
    pids copied from the caller's task_struct. In x86 case the caller is
    either kernel_init() thread or keventd.
    
    In particular, this means that after the series of cpu_up/cpu_down an
    idle thread (which never exits) can run with .pid pointing to nowhere.
    
    Change fork_idle() to initialize idle->pids[] correctly. We only set
    .pid = &init_struct_pid but do not add .node to list, INIT_TASK() does
    the same for the boot-cpu idle thread (swapper).
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Mathias Krause <Mathias.Krause@secunet.com>
    Acked-by: Roland McGrath <roland@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/fork.c b/kernel/fork.c
index d32410bd..bf9fef6 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1338,6 +1338,16 @@ noinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_re
 	return regs;
 }
 
+static inline void init_idle_pids(struct pid_link *links)
+{
+	enum pid_type type;
+
+	for (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {
+		INIT_HLIST_NODE(&links[type].node); /* not really needed */
+		links[type].pid = &init_struct_pid;
+	}
+}
+
 struct task_struct * __cpuinit fork_idle(int cpu)
 {
 	struct task_struct *task;
@@ -1345,8 +1355,10 @@ struct task_struct * __cpuinit fork_idle(int cpu)
 
 	task = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,
 			    &init_struct_pid, 0);
-	if (!IS_ERR(task))
+	if (!IS_ERR(task)) {
+		init_idle_pids(task->pids);
 		init_idle(task, cpu);
+	}
 
 	return task;
 }
