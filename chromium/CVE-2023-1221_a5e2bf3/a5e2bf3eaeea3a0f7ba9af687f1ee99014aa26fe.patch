commit a5e2bf3eaeea3a0f7ba9af687f1ee99014aa26fe	a5e2bf3eaeea3a0f7ba9af687f1ee99014aa26fe
Author: Tim Judkins <tjudkins@chromium.org>
Date:   Tue Jan 10 01:36:06 2023 +0000

    [Extensions] Reload extension on changing fileAccess even if disabled
    
    Changes to file access settings for an extension were not being applied
    correctly for extensions which were disabled while the setting was
    changed. This CL forces a reload of an extension when changing the file
    access setting even if it is disabled, to ensure it is reinitialized
    correctly. Also adds tests to better cover this case.
    
    Bug: 1385343
    Change-Id: I2de208b5e80b715515f613c55bf50b362913d1fa
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4123091
    Reviewed-by: Devlin Cronin <rdevlin.cronin@chromium.org>
    Commit-Queue: Tim <tjudkins@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1090642}

diff --git a/chrome/browser/extensions/extension_util.cc b/chrome/browser/extensions/extension_util.cc
index f734e82947f12..37bc052c636ae 100644
--- a/chrome/browser/extensions/extension_util.cc
+++ b/chrome/browser/extensions/extension_util.cc
@@ -56,15 +56,8 @@ namespace util {
 namespace {
 
 // Returns |extension_id|. See note below.
-std::string ReloadExtensionIfEnabled(const std::string& extension_id,
-                                     content::BrowserContext* context) {
-  ExtensionRegistry* registry = ExtensionRegistry::Get(context);
-  bool extension_is_enabled =
-      registry->enabled_extensions().Contains(extension_id);
-
-  if (!extension_is_enabled)
-    return extension_id;
-
+std::string ReloadExtension(const std::string& extension_id,
+                            content::BrowserContext* context) {
   // When we reload the extension the ID may be invalidated if we've passed it
   // by const ref everywhere. Make a copy to be safe. http://crbug.com/103762
   std::string id = extension_id;
@@ -75,6 +68,18 @@ std::string ReloadExtensionIfEnabled(const std::string& extension_id,
   return id;
 }
 
+std::string ReloadExtensionIfEnabled(const std::string& extension_id,
+                                     content::BrowserContext* context) {
+  ExtensionRegistry* registry = ExtensionRegistry::Get(context);
+  bool extension_is_enabled =
+      registry->enabled_extensions().Contains(extension_id);
+
+  if (!extension_is_enabled) {
+    return extension_id;
+  }
+  return ReloadExtension(extension_id, context);
+}
+
 }  // namespace
 
 bool HasIsolatedStorage(const std::string& extension_id,
@@ -166,14 +171,15 @@ bool AllowFileAccess(const std::string& extension_id,
 void SetAllowFileAccess(const std::string& extension_id,
                         content::BrowserContext* context,
                         bool allow) {
-  // Reload to update browser state. Only bother if the value changed and the
-  // extension is actually enabled, since there is no UI otherwise.
+  // Reload to update browser state if the value changed. We need to reload even
+  // if the extension is disabled, in order to make sure file access is
+  // reinitialized correctly.
   if (allow == AllowFileAccess(extension_id, context))
     return;
 
   ExtensionPrefs::Get(context)->SetAllowFileAccess(extension_id, allow);
 
-  ReloadExtensionIfEnabled(extension_id, context);
+  ReloadExtension(extension_id, context);
 }
 
 bool IsAppLaunchable(const std::string& extension_id,
diff --git a/chrome/browser/extensions/extension_util_unittest.cc b/chrome/browser/extensions/extension_util_unittest.cc
new file mode 100644
index 0000000000000..a06c97dd2014b
--- /dev/null
+++ b/chrome/browser/extensions/extension_util_unittest.cc
@@ -0,0 +1,148 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/extension_util.h"
+
+#include "base/memory/scoped_refptr.h"
+#include "chrome/browser/extensions/chrome_test_extension_loader.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/extension_service_test_base.h"
+#include "components/sessions/content/session_tab_helper.h"
+#include "content/public/test/web_contents_tester.h"
+#include "extensions/browser/test_extension_registry_observer.h"
+#include "extensions/common/permissions/permissions_data.h"
+#include "extensions/test/test_extension_dir.h"
+#include "url/gurl.h"
+
+namespace extensions {
+
+using ExtensionUtilUnittest = ExtensionServiceTestBase;
+
+TEST_F(ExtensionUtilUnittest, SetAllowFileAccess) {
+  InitializeEmptyExtensionService();
+  constexpr char kManifest[] =
+      R"({
+           "name": "foo",
+           "version": "1.0",
+           "manifest_version": 2,
+           "permissions": ["<all_urls>"]
+         })";
+
+  TestExtensionDir dir;
+  dir.WriteManifest(kManifest);
+
+  ChromeTestExtensionLoader loader(profile());
+  // An unpacked extension would get file access by default, so disabled it on
+  // the loader.
+  loader.set_allow_file_access(false);
+
+  scoped_refptr<const Extension> extension =
+      loader.LoadExtension(dir.UnpackedPath());
+  const std::string extension_id = extension->id();
+
+  GURL file_url("file://etc");
+  std::unique_ptr<content::WebContents> web_contents(
+      content::WebContentsTester::CreateTestWebContents(profile(), nullptr));
+  int tab_id = sessions::SessionTabHelper::IdForTab(web_contents.get()).id();
+
+  // Initially the file access pref will be false and the extension will not be
+  // able to capture a file URL page.
+  EXPECT_FALSE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+
+  // Calling SetAllowFileAccess should reload the extension with file access.
+  {
+    TestExtensionRegistryObserver observer(registry(), extension_id);
+    util::SetAllowFileAccess(extension_id, browser_context(), true);
+    extension = observer.WaitForExtensionInstalled();
+  }
+
+  EXPECT_TRUE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_TRUE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+
+  // Removing the file access should reload the extension again back to not
+  // having file access.
+  {
+    TestExtensionRegistryObserver observer(registry(), extension_id);
+    util::SetAllowFileAccess(extension_id, browser_context(), false);
+    extension = observer.WaitForExtensionInstalled();
+  }
+
+  EXPECT_FALSE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+}
+
+TEST_F(ExtensionUtilUnittest, SetAllowFileAccessWhileDisabled) {
+  InitializeEmptyExtensionService();
+  constexpr char kManifest[] =
+      R"({
+           "name": "foo",
+           "version": "1.0",
+           "manifest_version": 2,
+           "permissions": ["<all_urls>"]
+         })";
+
+  TestExtensionDir dir;
+  dir.WriteManifest(kManifest);
+
+  ChromeTestExtensionLoader loader(profile());
+  // An unpacked extension would get file access by default, so disabled it on
+  // the loader.
+  loader.set_allow_file_access(false);
+
+  scoped_refptr<const Extension> extension =
+      loader.LoadExtension(dir.UnpackedPath());
+  const std::string extension_id = extension->id();
+
+  GURL file_url("file://etc");
+  std::unique_ptr<content::WebContents> web_contents(
+      content::WebContentsTester::CreateTestWebContents(profile(), nullptr));
+  int tab_id = sessions::SessionTabHelper::IdForTab(web_contents.get()).id();
+
+  // Initially the file access pref will be false and the extension will not be
+  // able to capture a file URL page.
+  EXPECT_FALSE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+
+  // Disabling the extension then calling SetAllowFileAccess should reload the
+  // extension with file access.
+  service()->DisableExtension(extension_id,
+                              disable_reason::DISABLE_USER_ACTION);
+  {
+    TestExtensionRegistryObserver observer(registry(), extension_id);
+    util::SetAllowFileAccess(extension_id, browser_context(), true);
+    extension = observer.WaitForExtensionInstalled();
+  }
+  // The extension should still be disabled.
+  EXPECT_FALSE(service()->IsExtensionEnabled(extension_id));
+
+  service()->EnableExtension(extension_id);
+  EXPECT_TRUE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_TRUE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+
+  // Disabling the extension and then removing the file access should reload it
+  // again back to not having file access. Regression test for
+  // crbug.com/1385343.
+  service()->DisableExtension(extension_id,
+                              disable_reason::DISABLE_USER_ACTION);
+  {
+    TestExtensionRegistryObserver observer(registry(), extension_id);
+    util::SetAllowFileAccess(extension_id, browser_context(), false);
+    extension = observer.WaitForExtensionInstalled();
+  }
+  // The extension should still be disabled.
+  EXPECT_FALSE(service()->IsExtensionEnabled(extension_id));
+
+  service()->EnableExtension(extension_id);
+  EXPECT_FALSE(util::AllowFileAccess(extension_id, profile()));
+  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
+      file_url, tab_id, nullptr, CaptureRequirement::kActiveTabOrAllUrls));
+}
+
+}  // namespace extensions
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 4727db873428f..d0b26eb16c396 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -8023,6 +8023,7 @@ test("unit_tests") {
       "../browser/extensions/extension_tab_util_unittest.cc",
       "../browser/extensions/extension_test_message_listener_unittest.cc",
       "../browser/extensions/extension_user_script_loader_unittest.cc",
+      "../browser/extensions/extension_util_unittest.cc",
       "../browser/extensions/extension_web_ui_unittest.cc",
       "../browser/extensions/external_install_error_unittest.cc",
       "../browser/extensions/external_policy_loader_unittest.cc",
