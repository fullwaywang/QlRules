commit 983989b3e894c0082b8da024d1dae5bed5ca19d6	983989b3e894c0082b8da024d1dae5bed5ca19d6
Author: Haxatron Sec <haxatron1@gmail.com>
Date:   Fri Sep 29 21:42:56 2023 +0000

    [dPWA] Observe web contents visibility when installing
    
    This change:
    - Starts observation of the web contents immediately for install,
      instead of on command start.
    - Cancels the installation if the visibility changes and the currently
      active web contents do not match the installer web contents
    - Cancels the installation if the web contents is navigated.
    
    Bug: 1457704
    
    Change-Id: If563d04c990c657b5468c3f388a17a49881e2e02
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4899736
    Commit-Queue: Dibyajyoti Pal <dibyapal@chromium.org>
    Reviewed-by: Dibyajyoti Pal <dibyapal@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1203462}

diff --git a/chrome/browser/ui/web_applications/web_app_ui_manager_impl.cc b/chrome/browser/ui/web_applications/web_app_ui_manager_impl.cc
index 08074de1a007f..f42520704d189 100644
--- a/chrome/browser/ui/web_applications/web_app_ui_manager_impl.cc
+++ b/chrome/browser/ui/web_applications/web_app_ui_manager_impl.cc
@@ -395,6 +395,14 @@ content::WebContents* WebAppUiManagerImpl::CreateNewTab() {
   return handle->GetWebContents();
 }
 
+bool WebAppUiManagerImpl::IsWebContentsActiveTabInBrowser(
+    content::WebContents* web_contents) {
+  Browser* browser = chrome::FindBrowserWithWebContents(web_contents);
+  return browser &&
+         browser->tab_strip_model() &&
+         browser->tab_strip_model()->GetActiveWebContents() == web_contents;
+}
+
 void WebAppUiManagerImpl::TriggerInstallDialog(
     content::WebContents* web_contents) {
   web_app::CreateWebAppFromManifest(
diff --git a/chrome/browser/ui/web_applications/web_app_ui_manager_impl.h b/chrome/browser/ui/web_applications/web_app_ui_manager_impl.h
index 308a9297ec531..99c080c7f4cb2 100644
--- a/chrome/browser/ui/web_applications/web_app_ui_manager_impl.h
+++ b/chrome/browser/ui/web_applications/web_app_ui_manager_impl.h
@@ -115,6 +115,8 @@ class WebAppUiManagerImpl : public BrowserListObserver, public WebAppUiManager {
       base::WeakPtr<Profile> profile) override;
 #endif
   content::WebContents* CreateNewTab() override;
+  bool IsWebContentsActiveTabInBrowser(
+       content::WebContents* web_contents) override;
   void TriggerInstallDialog(content::WebContents* web_contents) override;
 
   void PresentUserUninstallDialog(
diff --git a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.cc b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.cc
index 585435acad8be..160551a690d2f 100644
--- a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.cc
+++ b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.cc
@@ -33,6 +33,7 @@
 #include "components/webapps/common/web_app_id.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/navigation_handle.h"
+#include "content/public/browser/visibility.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "url/origin.h"
@@ -147,6 +148,7 @@ FetchManifestAndInstallCommand::FetchManifestAndInstallCommand(
     WebAppInstallDialogCallback dialog_callback,
     OnceInstallCallback callback,
     bool use_fallback,
+    base::WeakPtr<WebAppUiManager> ui_manager,
     std::unique_ptr<WebAppDataRetriever> data_retriever)
     : WebAppCommandTemplate<NoopLock>("FetchManifestAndInstallCommand"),
       noop_lock_description_(std::make_unique<NoopLockDescription>()),
@@ -156,12 +158,16 @@ FetchManifestAndInstallCommand::FetchManifestAndInstallCommand(
       dialog_callback_(std::move(dialog_callback)),
       install_callback_(std::move(callback)),
       use_fallback_(use_fallback),
+      ui_manager_(ui_manager),
       data_retriever_(std::move(data_retriever)),
       install_error_log_entry_(/*background_installation=*/false,
                                install_surface_) {
+  Observe(web_contents_.get());
   debug_log_.Set("visible_url", web_contents_->GetVisibleURL().spec());
   debug_log_.Set("last_committed_url",
                  web_contents_->GetLastCommittedURL().spec());
+  debug_log_.Set("initial_visibility",
+                 static_cast<int>(web_contents()->GetVisibility()));
 }
 
 FetchManifestAndInstallCommand::~FetchManifestAndInstallCommand() = default;
@@ -184,7 +190,15 @@ void FetchManifestAndInstallCommand::StartWithLock(
     return;
   }
 
-  Observe(web_contents_.get());
+  if (web_contents()->GetVisibility() != content::Visibility::VISIBLE) {
+    Abort(webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
+    return;
+  }
+
+  if (did_navigation_occur_before_start_) {
+    Abort(webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
+    return;
+  }
 
   // This metric is recorded regardless of the installation result.
   if (webapps::InstallableMetrics::IsReportableInstallSource(
@@ -235,9 +249,43 @@ void FetchManifestAndInstallCommand::DidFinishNavigation(
     return;
   }
 
+  if (!IsStarted()) {
+    did_navigation_occur_before_start_ = true;
+    return;
+  }
+
   Abort(webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
 }
 
+void FetchManifestAndInstallCommand::OnVisibilityChanged(
+    content::Visibility visibility) {
+  if (visibility == content::Visibility::VISIBLE) {
+    return;
+  }
+
+  if (!IsStarted()) {
+    did_navigation_occur_before_start_ = true;
+    return;
+  }
+
+  // This prevents us from closing the dialog if the visibility of the window
+  // itself changes but the tab doesn't. A more thorough fix here is to listen
+  // to the tab strip changing (AKA a different tab being opened / changed to),
+  // but due to needing to use code in `ui`, this is a bit hard to do.
+  if (ui_manager_->IsWebContentsActiveTabInBrowser(web_contents())) {
+    return;
+  }
+
+  Abort(webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
+}
+
+void FetchManifestAndInstallCommand::WebContentsDestroyed() {
+  Observe(nullptr);
+  // No need to abort - web content destruction is handled in the beginning of
+  // each method. However, this needs to be here in case the web contents is
+  // destroyed before the command is started.
+}
+
 void FetchManifestAndInstallCommand::Abort(webapps::InstallResultCode code) {
   if (!install_callback_)
     return;
@@ -543,6 +591,9 @@ void FetchManifestAndInstallCommand::OnInstallFinalizedMaybeReparentTab(
     return;
   }
 
+  // Stop observing the web contents to prevent cancellation when reparenting.
+  Observe(nullptr);
+
   RecordWebAppInstallationTimestamp(
       Profile::FromBrowserContext(web_contents_->GetBrowserContext())
           ->GetPrefs(),
diff --git a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.h b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.h
index f7bf86ea8fdee..00fc70692b6cd 100644
--- a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.h
+++ b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command.h
@@ -16,10 +16,12 @@
 #include "chrome/browser/web_applications/web_app_install_manager.h"
 #include "chrome/browser/web_applications/web_app_install_params.h"
 #include "chrome/browser/web_applications/web_app_logging.h"
+#include "chrome/browser/web_applications/web_app_ui_manager.h"
 #include "components/webapps/browser/install_result_code.h"
 #include "components/webapps/browser/installable/installable_logging.h"
 #include "components/webapps/browser/installable/installable_metrics.h"
 #include "components/webapps/common/web_app_id.h"
+#include "content/public/browser/visibility.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "third_party/blink/public/mojom/manifest/manifest.mojom-forward.h"
 
@@ -55,6 +57,7 @@ class FetchManifestAndInstallCommand : public WebAppCommandTemplate<NoopLock>,
       WebAppInstallDialogCallback dialog_callback,
       OnceInstallCallback callback,
       bool use_fallback,
+      base::WeakPtr<WebAppUiManager> ui_manager,
       std::unique_ptr<WebAppDataRetriever> data_retriever);
 
   ~FetchManifestAndInstallCommand() override;
@@ -70,6 +73,8 @@ class FetchManifestAndInstallCommand : public WebAppCommandTemplate<NoopLock>,
   // content::WebContentsObserver:
   void DidFinishNavigation(
       content::NavigationHandle* navigation_handle) override;
+  void OnVisibilityChanged(content::Visibility visibility) override;
+  void WebContentsDestroyed() override;
 
   void Abort(webapps::InstallResultCode code);
   bool IsWebContentsDestroyed();
@@ -138,6 +143,9 @@ class FetchManifestAndInstallCommand : public WebAppCommandTemplate<NoopLock>,
   // Whether using fallback installation data from the document.
   bool use_fallback_ = false;
 
+  bool did_navigation_occur_before_start_ = false;
+
+  base::WeakPtr<WebAppUiManager> ui_manager_;
   std::unique_ptr<WebAppDataRetriever> data_retriever_;
 
   InstallErrorLogEntry install_error_log_entry_;
diff --git a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_browsertest.cc b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_browsertest.cc
index 01fe33730c57b..710fe2c55366d 100644
--- a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_browsertest.cc
+++ b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_browsertest.cc
@@ -73,7 +73,9 @@ IN_PROC_BROWSER_TEST_F(FetchManifestAndInstallCommandTest, MultipleInstalls) {
       "manifest_test_page.html");
   EXPECT_TRUE(NavigateAndAwaitInstallabilityCheck(browser(), test_url));
 
-  // Schedule two installs and both succeed.
+  // Schedule two installs. The second should fail because the first will cause
+  // a navigation (because reparenting somehow changes visiblity, which is
+  // wrong, but fine).
   base::RunLoop loop;
   provider().scheduler().FetchManifestAndInstall(
       webapps::WebappInstallSource::MENU_BROWSER_TAB,
@@ -91,13 +93,14 @@ IN_PROC_BROWSER_TEST_F(FetchManifestAndInstallCommandTest, MultipleInstalls) {
       webapps::WebappInstallSource::MENU_BROWSER_TAB,
       browser()->tab_strip_model()->GetActiveWebContents()->GetWeakPtr(),
       /*bypass_service_worker_check=*/false, CreateDialogCallback(),
-      base::BindLambdaForTesting(
-          [&](const webapps::AppId& app_id, webapps::InstallResultCode code) {
-            EXPECT_EQ(code, webapps::InstallResultCode::kSuccessNewInstall);
-            EXPECT_TRUE(
-                provider().registrar_unsafe().IsLocallyInstalled(app_id));
-            loop.Quit();
-          }),
+      base::BindLambdaForTesting([&](const webapps::AppId& app_id,
+                                     webapps::InstallResultCode code) {
+        EXPECT_EQ(
+            code,
+            webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
+        EXPECT_FALSE(provider().registrar_unsafe().IsLocallyInstalled(app_id));
+        loop.Quit();
+      }),
       /*use_fallback=*/false);
   loop.Run();
 }
diff --git a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_unittest.cc b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_unittest.cc
index e0868d8cee23b..a8695106a2e3d 100644
--- a/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_unittest.cc
+++ b/chrome/browser/web_applications/commands/fetch_manifest_and_install_command_unittest.cc
@@ -11,6 +11,7 @@
 #include "base/test/bind.h"
 #include "base/test/metrics/histogram_tester.h"
 #include "base/test/test_future.h"
+#include "chrome/browser/ui/web_applications/web_app_dialog_utils.h"
 #include "chrome/browser/web_applications/mojom/user_display_mode.mojom.h"
 #include "chrome/browser/web_applications/test/fake_web_app_provider.h"
 #include "chrome/browser/web_applications/test/fake_web_app_ui_manager.h"
@@ -692,6 +693,29 @@ TEST_F(FetchManifestAndInstallCommandTest, WriteDataToDiskFailed) {
   EXPECT_FALSE(file_utils().DirectoryExists(app_dir));
 }
 
+TEST_F(FetchManifestAndInstallCommandTest, WebContentsNavigates) {
+  SetupPageState();
+  base::test::TestFuture<const AppId&, webapps::InstallResultCode>
+      install_future;
+  provider()->scheduler().FetchManifestAndInstall(
+      webapps::WebappInstallSource::OMNIBOX_INSTALL_ICON,
+      web_contents()->GetWeakPtr(),
+      /*bypass_service_worker_check=*/false,
+      CreateDialogCallback(/*accept=*/true, mojom::UserDisplayMode::kStandalone),
+      install_future.GetCallback(), /*use_fallback=*/false);
+  // The command is always started asynchronously, so this immediate
+  // navigation should test that it correctly handles navigation before
+  // starting.
+  content::WebContentsTester* tester =
+      content::WebContentsTester::For(web_contents());
+  ASSERT_TRUE(tester);
+  tester->NavigateAndCommit(GURL("https://other_origin.com/path/index.html"));
+  ASSERT_TRUE(install_future.Wait());
+  EXPECT_EQ(install_future.Get<webapps::InstallResultCode>(),
+            webapps::InstallResultCode::kCancelledDueToMainFrameNavigation);
+  EXPECT_FALSE(provider()->registrar_unsafe().IsLocallyInstalled(kWebAppId));
+}
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 TEST_F(FetchManifestAndInstallCommandTest, IntentToPlayStore) {
   arc_test().app_instance()->set_is_installable(true);
diff --git a/chrome/browser/web_applications/test/fake_web_app_ui_manager.cc b/chrome/browser/web_applications/test/fake_web_app_ui_manager.cc
index 5ce0cc5ffe39c..285228b535f52 100644
--- a/chrome/browser/web_applications/test/fake_web_app_ui_manager.cc
+++ b/chrome/browser/web_applications/test/fake_web_app_ui_manager.cc
@@ -171,6 +171,11 @@ content::WebContents* FakeWebAppUiManager::CreateNewTab() {
   return nullptr;
 }
 
+bool FakeWebAppUiManager::IsWebContentsActiveTabInBrowser(
+     content::WebContents* web_contents) {
+  return true;
+}
+
 void FakeWebAppUiManager::TriggerInstallDialog(
     content::WebContents* web_contents) {}
 
diff --git a/chrome/browser/web_applications/test/fake_web_app_ui_manager.h b/chrome/browser/web_applications/test/fake_web_app_ui_manager.h
index f5ba6acd085a2..588c15b934102 100644
--- a/chrome/browser/web_applications/test/fake_web_app_ui_manager.h
+++ b/chrome/browser/web_applications/test/fake_web_app_ui_manager.h
@@ -89,6 +89,8 @@ class FakeWebAppUiManager : public WebAppUiManager {
       base::WeakPtr<Profile> profile) override;
 #endif
   content::WebContents* CreateNewTab() override;
+  bool IsWebContentsActiveTabInBrowser(
+       content::WebContents* web_contents) override;
   void TriggerInstallDialog(content::WebContents* web_contents) override;
 
   void PresentUserUninstallDialog(
diff --git a/chrome/browser/web_applications/web_app_command_scheduler.cc b/chrome/browser/web_applications/web_app_command_scheduler.cc
index 7becc0b0d2bde..a76d7ffee103e 100644
--- a/chrome/browser/web_applications/web_app_command_scheduler.cc
+++ b/chrome/browser/web_applications/web_app_command_scheduler.cc
@@ -121,6 +121,7 @@ void WebAppCommandScheduler::FetchManifestAndInstall(
       std::make_unique<FetchManifestAndInstallCommand>(
           install_surface, std::move(contents), bypass_service_worker_check,
           std::move(dialog_callback), std::move(callback), use_fallback,
+          provider_->ui_manager().GetWeakPtr(),
           provider_->web_contents_manager().CreateDataRetriever()),
       location);
 }
diff --git a/chrome/browser/web_applications/web_app_ui_manager.h b/chrome/browser/web_applications/web_app_ui_manager.h
index ae3dc366b9240..7c9d9ccb3309e 100644
--- a/chrome/browser/web_applications/web_app_ui_manager.h
+++ b/chrome/browser/web_applications/web_app_ui_manager.h
@@ -196,6 +196,10 @@ class WebAppUiManager {
   // if there isn't one that is already open.
   virtual content::WebContents* CreateNewTab() = 0;
 
+  // Check if a tab is the currently active tab in the browser.
+  virtual bool IsWebContentsActiveTabInBrowser(
+      content::WebContents* web_contents) = 0;
+
   // Triggers the web app install dialog on the specified |web_contents| if
   // there is an installable web app. This will show the dialog even if the app
   // is already installed.
