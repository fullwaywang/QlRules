commit 5ef1d8c1ddbf696e47b226e11888eaf8d9e8e807
Author: Sean Christopherson <seanjc@google.com>
Date:   Fri Feb 16 17:34:30 2024 -0800

    KVM: SVM: Flush pages under kvm->lock to fix UAF in svm_register_enc_region()
    
    Do the cache flush of converted pages in svm_register_enc_region() before
    dropping kvm->lock to fix use-after-free issues where region and/or its
    array of pages could be freed by a different task, e.g. if userspace has
    __unregister_enc_region_locked() already queued up for the region.
    
    Note, the "obvious" alternative of using local variables doesn't fully
    resolve the bug, as region->pages is also dynamically allocated.  I.e. the
    region structure itself would be fine, but region->pages could be freed.
    
    Flushing multiple pages under kvm->lock is unfortunate, but the entire
    flow is a rare slow path, and the manual flush is only needed on CPUs that
    lack coherency for encrypted memory.
    
    Fixes: 19a23da53932 ("Fix unsynchronized access to sev members through svm_register_enc_region")
    Reported-by: Gabe Kirkpatrick <gkirkpatrick@google.com>
    Cc: Josh Eads <josheads@google.com>
    Cc: Peter Gonda <pgonda@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sean Christopherson <seanjc@google.com>
    Message-Id: <20240217013430.2079561-1-seanjc@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c
index f760106c31f8..a132547fcfb5 100644
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@ -1975,20 +1975,22 @@ int sev_mem_enc_register_region(struct kvm *kvm,
 		goto e_free;
 	}
 
-	region->uaddr = range->addr;
-	region->size = range->size;
-
-	list_add_tail(&region->list, &sev->regions_list);
-	mutex_unlock(&kvm->lock);
-
 	/*
 	 * The guest may change the memory encryption attribute from C=0 -> C=1
 	 * or vice versa for this memory range. Lets make sure caches are
 	 * flushed to ensure that guest data gets written into memory with
-	 * correct C-bit.
+	 * correct C-bit.  Note, this must be done before dropping kvm->lock,
+	 * as region and its array of pages can be freed by a different task
+	 * once kvm->lock is released.
 	 */
 	sev_clflush_pages(region->pages, region->npages);
 
+	region->uaddr = range->addr;
+	region->size = range->size;
+
+	list_add_tail(&region->list, &sev->regions_list);
+	mutex_unlock(&kvm->lock);
+
 	return ret;
 
 e_free:
