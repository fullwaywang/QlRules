commit c5119cd03d4078afaa280d2398d7faf3157db980	c5119cd03d4078afaa280d2398d7faf3157db980
Author: Thomas Nguyen <tungnh@google.com>
Date:   Fri May 26 14:14:00 2023 +0000

    Ignore user input events shortly after moving overlay windows
    
    This is implementation of
    https://docs.google.com/document/d/1gyTYJGgXRMh_eYXmCD86I44-kQOqlVb4VUwnyc_qXhg/edit#
    
    Bug: 1406922
    Change-Id: If9e4f085d95cd8e2bb0eacc8d66e48f88886e9fb
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4476695
    Reviewed-by: Keren Zhu <kerenzhu@chromium.org>
    Commit-Queue: Thomas Nguyen <tungnh@chromium.org>
    Reviewed-by: Thomas Lukaszewicz <tluk@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1149704}

diff --git a/chrome/browser/ui/views/permissions/chip_controller.cc b/chrome/browser/ui/views/permissions/chip_controller.cc
index b615377c84d32..2004dab4d8c8d 100644
--- a/chrome/browser/ui/views/permissions/chip_controller.cc
+++ b/chrome/browser/ui/views/permissions/chip_controller.cc
@@ -198,7 +198,8 @@ void ChipController::OnWidgetActivationChanged(views::Widget* widget,
     // If the widget is active and the primary window wasn't active the last
     // time activation changed, we know that the window just came to the
     // foreground and trigger input protection.
-    GetPromptBubbleView()->AsDialogDelegate()->TriggerInputProtection();
+    GetPromptBubbleView()->AsDialogDelegate()->TriggerInputProtection(
+        /*force_early*/ true);
   }
   parent_was_visible_when_activation_changed_ =
       prompt_bubble_widget->GetPrimaryWindowWidget()->IsVisible();
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
index 05d1dccb295da..b4c2844e48abd 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
@@ -70,7 +70,8 @@ void PermissionPromptBubble::OnWidgetActivationChanged(views::Widget* widget,
     // If the widget is active and the primary window wasn't active the last
     // time activation changed, we know that the window just came to the
     // foreground and trigger input protection.
-    prompt_bubble_->AsDialogDelegate()->TriggerInputProtection();
+    prompt_bubble_->AsDialogDelegate()->TriggerInputProtection(
+        /*force_early=*/true);
   }
   parent_was_visible_when_activation_changed_ =
       prompt_bubble_->GetWidget()->GetPrimaryWindowWidget()->IsVisible();
diff --git a/components/ui_devtools/views/dom_agent_mac.h b/components/ui_devtools/views/dom_agent_mac.h
index ecb7da5261fdf..4a679d19c9f4b 100644
--- a/components/ui_devtools/views/dom_agent_mac.h
+++ b/components/ui_devtools/views/dom_agent_mac.h
@@ -5,6 +5,7 @@
 #ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_MAC_H_
 #define COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_MAC_H_
 
+#include "base/callback_list.h"
 #include "components/ui_devtools/views/dom_agent_views.h"
 #include "ui/views/widget/widget_observer.h"
 
@@ -43,6 +44,9 @@ class DOMAgentMac : public DOMAgentViews, public views::WidgetObserver {
   void InitializeRootsFromOpenWindows();
 
   std::vector<views::Widget*> roots_;
+
+  // Called whenever a |NativeWidgetMac| is created.
+  base::CallbackListSubscription init_native_widget_subscription_;
 };
 }  // namespace ui_devtools
 
diff --git a/components/ui_devtools/views/dom_agent_mac.mm b/components/ui_devtools/views/dom_agent_mac.mm
index f3e7f3000e81c..87e585fa6cfff 100644
--- a/components/ui_devtools/views/dom_agent_mac.mm
+++ b/components/ui_devtools/views/dom_agent_mac.mm
@@ -6,6 +6,7 @@
 
 #import <AppKit/AppKit.h>
 
+#include "base/functional/bind.h"
 #include "base/ranges/algorithm.h"
 #include "components/ui_devtools/views/widget_element.h"
 #include "ui/views/widget/native_widget_mac.h"
@@ -23,14 +24,15 @@ DOMAgentMac::~DOMAgentMac() {
 }
 
 protocol::Response DOMAgentMac::enable() {
-  views::NativeWidgetMac::SetInitNativeWidgetCallback(base::BindRepeating(
-      &DOMAgentMac::OnNativeWidgetAdded, base::Unretained(this)));
+  init_native_widget_subscription_ =
+      views::NativeWidgetMac::RegisterInitNativeWidgetCallback(
+          base::BindRepeating(&DOMAgentMac::OnNativeWidgetAdded,
+                              base::Unretained(this)));
   return DOMAgent::enable();
 }
 
 protocol::Response DOMAgentMac::disable() {
-  views::NativeWidgetMac::SetInitNativeWidgetCallback(
-      base::RepeatingCallback<void(views::NativeWidgetMac*)>());
+  init_native_widget_subscription_ = {};
   for (views::Widget* widget : roots_)
     widget->RemoveObserver(this);
   roots_.clear();
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 01bbf457bc079..882c89cce663b 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -296,6 +296,7 @@ component("views") {
     "window/window_button_order_provider.h",
     "window/window_resources.h",
     "window/window_shape.h",
+    "windows_stationarity_monitor.h",
     "word_lookup_client.h",
   ]
 
@@ -498,6 +499,7 @@ component("views") {
     "window/non_client_view.cc",
     "window/window_button_order_provider.cc",
     "window/window_shape.cc",
+    "windows_stationarity_monitor.cc",
   ]
 
   # Other targets in this file (e.g. tests) get access to the internal headers.
@@ -627,6 +629,7 @@ component("views") {
       "widget/native_widget_mac.h",
       "widget/widget_utils_mac.h",
       "window/native_frame_view_mac.h",
+      "windows_stationarity_monitor_mac.h",
     ]
     sources += [
       "accessibility/ax_virtual_view_mac.mm",
@@ -659,6 +662,7 @@ component("views") {
       "widget/native_widget_mac.mm",
       "widget/widget_utils_mac.mm",
       "window/native_frame_view_mac.mm",
+      "windows_stationarity_monitor_mac.mm",
     ]
     public_deps += [ "//components/remote_cocoa/common:mojo" ]
     deps += [
@@ -748,6 +752,7 @@ component("views") {
       "widget/tooltip_manager_aura.h",
       "widget/widget_aura_utils.h",
       "widget/window_reorderer.h",
+      "windows_stationarity_monitor_aura.h",
     ]
 
     sources += [
@@ -780,6 +785,7 @@ component("views") {
       "widget/native_widget_aura.cc",
       "widget/tooltip_manager_aura.cc",
       "widget/window_reorderer.cc",
+      "windows_stationarity_monitor_aura.cc",
     ]
     if (!is_chromeos_ash) {
       sources += [
diff --git a/ui/views/bubble/bubble_frame_view.cc b/ui/views/bubble/bubble_frame_view.cc
index 2c2554ab2893c..b1210ea8512d2 100644
--- a/ui/views/bubble/bubble_frame_view.cc
+++ b/ui/views/bubble/bubble_frame_view.cc
@@ -794,7 +794,7 @@ gfx::Rect BubbleFrameView::GetUpdatedWindowBounds(
 }
 
 void BubbleFrameView::UpdateInputProtectorTimeStamp() {
-  input_protector_.UpdateViewShownTimeStamp();
+  input_protector_.MaybeUpdateViewProtectedTimeStamp();
 }
 
 void BubbleFrameView::ResetViewShownTimeStampForTesting() {
diff --git a/ui/views/input_event_activation_protector.cc b/ui/views/input_event_activation_protector.cc
index 1e84272fb1dee..a2b99939120dd 100644
--- a/ui/views/input_event_activation_protector.cc
+++ b/ui/views/input_event_activation_protector.cc
@@ -11,17 +11,27 @@
 
 namespace views {
 
+InputEventActivationProtector::InputEventActivationProtector() {
+  WindowsStationarityMonitor::GetInstance()->AddObserver(this);
+}
+
+InputEventActivationProtector::~InputEventActivationProtector() {
+  WindowsStationarityMonitor::GetInstance()->RemoveObserver(this);
+}
+
 void InputEventActivationProtector::VisibilityChanged(bool is_visible) {
   if (is_visible)
-    view_shown_time_stamp_ = base::TimeTicks::Now();
+    view_protected_time_stamp_ = base::TimeTicks::Now();
 }
 
-void InputEventActivationProtector::UpdateViewShownTimeStamp() {
+void InputEventActivationProtector::MaybeUpdateViewProtectedTimeStamp(
+    bool force) {
   // The UI was never shown, ignore.
-  if (view_shown_time_stamp_ == base::TimeTicks())
+  if (!force && view_protected_time_stamp_ == base::TimeTicks()) {
     return;
+  }
 
-  view_shown_time_stamp_ = base::TimeTicks::Now();
+  view_protected_time_stamp_ = base::TimeTicks::Now();
 }
 
 bool InputEventActivationProtector::IsPossiblyUnintendedInteraction(
@@ -31,18 +41,20 @@ bool InputEventActivationProtector::IsPossiblyUnintendedInteraction(
     return false;
   }
 
-  if (view_shown_time_stamp_ == base::TimeTicks()) {
+  if (view_protected_time_stamp_ == base::TimeTicks()) {
     // The UI was never shown, ignore. This can happen in tests.
     return false;
   }
 
   // Don't let key repeats close the dialog, they might've been held when the
   // dialog pops up.
-  if (event.IsKeyEvent() && event.AsKeyEvent()->is_repeat())
+  if (event.IsKeyEvent() && event.AsKeyEvent()->is_repeat()) {
     return true;
+  }
 
-  if (!event.IsMouseEvent() && !event.IsTouchEvent())
+  if (!event.IsMouseEvent() && !event.IsTouchEvent()) {
     return false;
+  }
 
   const base::TimeDelta kShortInterval =
       base::Milliseconds(GetDoubleClickInterval());
@@ -57,12 +69,16 @@ bool InputEventActivationProtector::IsPossiblyUnintendedInteraction(
   }
   repeated_event_count_ = 0;
 
-  // Unintended if the user clicked right after the UI showed.
-  return event.time_stamp() < view_shown_time_stamp_ + kShortInterval;
+  // Unintended if the user clicked right after the view was protected.
+  return event.time_stamp() < view_protected_time_stamp_ + kShortInterval;
+}
+
+void InputEventActivationProtector::OnWindowStationaryStateChanged() {
+  MaybeUpdateViewProtectedTimeStamp();
 }
 
 void InputEventActivationProtector::ResetForTesting() {
-  view_shown_time_stamp_ = base::TimeTicks();
+  view_protected_time_stamp_ = base::TimeTicks();
   last_event_timestamp_ = base::TimeTicks();
   repeated_event_count_ = 0;
 }
diff --git a/ui/views/input_event_activation_protector.h b/ui/views/input_event_activation_protector.h
index 47b1b3549e7d9..1f5842de38994 100644
--- a/ui/views/input_event_activation_protector.h
+++ b/ui/views/input_event_activation_protector.h
@@ -7,6 +7,7 @@
 
 #include "base/time/time.h"
 #include "ui/views/views_export.h"
+#include "ui/views/windows_stationarity_monitor.h"
 
 namespace ui {
 class Event;
@@ -17,35 +18,47 @@ namespace views {
 // The goal of this class is to prevent potentially unintentional user
 // interaction with a UI element.
 // See switch kDisableInputEventActivationProtectionForTesting for disabling it.
-class VIEWS_EXPORT InputEventActivationProtector {
+class VIEWS_EXPORT InputEventActivationProtector
+    : WindowsStationarityMonitor::Observer {
  public:
-  InputEventActivationProtector() = default;
+  InputEventActivationProtector();
+  ~InputEventActivationProtector() override;
 
   InputEventActivationProtector(const InputEventActivationProtector&) = delete;
   InputEventActivationProtector& operator=(
       const InputEventActivationProtector&) = delete;
 
-  virtual ~InputEventActivationProtector() = default;
-
   // Updates the state of the protector based off of visibility changes. This
   // method must be called when the visibility of the view is changed.
   void VisibilityChanged(bool is_visible);
 
-  // Updates the |view_shown_time_stamp_| if needed. This function will be
-  // called when we want to reset back the input protector to "initial shown"
-  // state, basically under some certain view's proprieties changed events.
-  void UpdateViewShownTimeStamp();
+  // Updates the |view_protected_time_stamp_| if needed. This function will be
+  // called when we want to reset back the input protector to "initial
+  // protected" state, basically under some certain view's proprieties changed
+  // events.
+  //
+  // If |force| is true, force to update the |view_protected_time_stamp_| even
+  // earlier (shortly before the owner view is visible). It usually helps us to
+  // prevent unintentional clicks happening when "visibility changes" event
+  // coming later than click event (for example click event -> tab activation ->
+  // visibility change).
+  void MaybeUpdateViewProtectedTimeStamp(bool force = false);
 
   // Returns true if the event is a mouse, touch, or pointer event that took
-  // place within the double-click time interval after |view_shown_time_stamp_|.
+  // place within the double-click time interval after
+  // |view_protected_time_stamp_|.
   virtual bool IsPossiblyUnintendedInteraction(const ui::Event& event);
 
+  // Implements WindowsStationarityMonitor::Observer:
+  void OnWindowStationaryStateChanged() override;
+
   // Resets the state for click tracking.
   void ResetForTesting();
 
  private:
-  // Timestamp of when the view being tracked is first shown.
-  base::TimeTicks view_shown_time_stamp_;
+  // Timestamp of when the view was initially protected. Used to prevent
+  // unintentional user interaction event immediately from the timestamp.
+  base::TimeTicks view_protected_time_stamp_;
   // Timestamp of the last event.
   base::TimeTicks last_event_timestamp_;
   // Number of repeated UI events with short intervals.
diff --git a/ui/views/test/widget_test.h b/ui/views/test/widget_test.h
index 6438f227e99d5..8319064e2dedf 100644
--- a/ui/views/test/widget_test.h
+++ b/ui/views/test/widget_test.h
@@ -74,6 +74,10 @@ class WidgetTest : public ViewsTestBase {
   explicit WidgetTest(
       std::unique_ptr<base::test::TaskEnvironment> task_environment);
 
+  template <typename... TaskEnvironmentTraits>
+  explicit WidgetTest(TaskEnvironmentTraits&&... traits)
+      : ViewsTestBase(std::forward<TaskEnvironmentTraits>(traits)...) {}
+
   WidgetTest(const WidgetTest&) = delete;
   WidgetTest& operator=(const WidgetTest&) = delete;
 
diff --git a/ui/views/widget/native_widget_mac.h b/ui/views/widget/native_widget_mac.h
index e24ce9de4fa20..3baa01788d82a 100644
--- a/ui/views/widget/native_widget_mac.h
+++ b/ui/views/widget/native_widget_mac.h
@@ -8,6 +8,7 @@
 #include <memory>
 #include <string>
 
+#include "base/callback_list.h"
 #include "base/memory/raw_ptr.h"
 #include "ui/base/ime/ime_key_event_dispatcher.h"
 #include "ui/base/window_open_disposition.h"
@@ -211,8 +212,8 @@ class VIEWS_EXPORT NativeWidgetMac : public internal::NativeWidgetPrivate,
 
   // Calls |callback| with the newly created NativeWidget whenever a
   // NativeWidget is created.
-  static void SetInitNativeWidgetCallback(
-      base::RepeatingCallback<void(NativeWidgetMac*)> callback);
+  static base::CallbackListSubscription RegisterInitNativeWidgetCallback(
+      const base::RepeatingCallback<void(NativeWidgetMac*)>& callback);
 
  protected:
   // The argument to SetBounds is sometimes in screen coordinates and sometimes
diff --git a/ui/views/widget/native_widget_mac.mm b/ui/views/widget/native_widget_mac.mm
index a49c80b38755d..b680f85737b16 100644
--- a/ui/views/widget/native_widget_mac.mm
+++ b/ui/views/widget/native_widget_mac.mm
@@ -9,9 +9,11 @@
 #include <CoreFoundation/CoreFoundation.h>
 
 #include <utility>
+#include <vector>
 
 #include "base/base64.h"
 #include "base/functional/callback.h"
+#include "base/lazy_instance.h"
 #include "base/mac/scoped_nsobject.h"
 #include "base/no_destructor.h"
 #include "base/strings/sys_string_conversions.h"
@@ -51,8 +53,8 @@ namespace views {
 
 namespace {
 
-static base::RepeatingCallback<void(NativeWidgetMac*)>*
-    g_init_native_widget_callback = nullptr;
+base::LazyInstance<base::RepeatingCallbackList<void(NativeWidgetMac*)>>::
+    DestructorAtExit g_init_native_widget_callbacks = LAZY_INSTANCE_INITIALIZER;
 
 uint64_t StyleMaskForParams(const Widget::InitParams& params) {
   // If the Widget is modal, it will be displayed as a sheet. This works best if
@@ -270,8 +272,7 @@ void NativeWidgetMac::InitNativeWidget(Widget::InitParams params) {
   }
   ns_window_host_->CreateCompositor(params);
 
-  if (g_init_native_widget_callback)
-    g_init_native_widget_callback->Run(this);
+  g_init_native_widget_callbacks.Get().Notify(this);
 }
 
 void NativeWidgetMac::OnWidgetInitDone() {
@@ -900,18 +901,11 @@ base::WeakPtr<internal::NativeWidgetPrivate> NativeWidgetMac::GetWeakPtr() {
 }
 
 // static
-void NativeWidgetMac::SetInitNativeWidgetCallback(
-    base::RepeatingCallback<void(NativeWidgetMac*)> callback) {
-  DCHECK(!g_init_native_widget_callback || callback.is_null());
-  if (callback.is_null()) {
-    if (g_init_native_widget_callback) {
-      delete g_init_native_widget_callback;
-      g_init_native_widget_callback = nullptr;
-    }
-    return;
-  }
-  g_init_native_widget_callback =
-      new base::RepeatingCallback<void(NativeWidgetMac*)>(std::move(callback));
+base::CallbackListSubscription
+NativeWidgetMac::RegisterInitNativeWidgetCallback(
+    const base::RepeatingCallback<void(NativeWidgetMac*)>& callback) {
+  DCHECK(!callback.is_null());
+  return g_init_native_widget_callbacks.Get().Add(callback);
 }
 
 NativeWidgetMacNSWindow* NativeWidgetMac::CreateNSWindow(
diff --git a/ui/views/widget/native_widget_mac_unittest.mm b/ui/views/widget/native_widget_mac_unittest.mm
index 9db8cfe9c4de6..72534fb45058e 100644
--- a/ui/views/widget/native_widget_mac_unittest.mm
+++ b/ui/views/widget/native_widget_mac_unittest.mm
@@ -2425,16 +2425,15 @@ TEST_F(NativeWidgetMacTest, InitCallback) {
         *observed = native_widget;
       },
       &observed_native_widget);
-  NativeWidgetMac::SetInitNativeWidgetCallback(callback);
+  auto subscription =
+      NativeWidgetMac::RegisterInitNativeWidgetCallback(callback);
 
   Widget* widget_a = CreateTopLevelPlatformWidget();
   EXPECT_EQ(observed_native_widget, widget_a->native_widget());
   Widget* widget_b = CreateTopLevelPlatformWidget();
   EXPECT_EQ(observed_native_widget, widget_b->native_widget());
 
-  auto empty = base::RepeatingCallback<void(NativeWidgetMac*)>();
-  DCHECK(empty.is_null());
-  NativeWidgetMac::SetInitNativeWidgetCallback(empty);
+  subscription = {};
   observed_native_widget = nullptr;
   Widget* widget_c = CreateTopLevelPlatformWidget();
   // The original callback from above should no longer be firing.
diff --git a/ui/views/window/dialog_client_view.cc b/ui/views/window/dialog_client_view.cc
index 676ebe0cdc5bd..be864e6661ad0 100644
--- a/ui/views/window/dialog_client_view.cc
+++ b/ui/views/window/dialog_client_view.cc
@@ -244,7 +244,7 @@ void DialogClientView::OnThemeChanged() {
 }
 
 void DialogClientView::UpdateInputProtectorTimeStamp() {
-  input_protector_->UpdateViewShownTimeStamp();
+  input_protector_->MaybeUpdateViewProtectedTimeStamp();
 }
 
 void DialogClientView::ResetViewShownTimeStampForTesting() {
@@ -262,8 +262,8 @@ void DialogClientView::ChildVisibilityChanged(View* child) {
   InvalidateLayout();
 }
 
-void DialogClientView::TriggerInputProtection() {
-  input_protector_->UpdateViewShownTimeStamp();
+void DialogClientView::TriggerInputProtection(bool force_early) {
+  input_protector_->MaybeUpdateViewProtectedTimeStamp(force_early);
 }
 
 void DialogClientView::OnDialogChanged() {
diff --git a/ui/views/window/dialog_client_view.h b/ui/views/window/dialog_client_view.h
index 4a546b7032cfc..220cb2cf39083 100644
--- a/ui/views/window/dialog_client_view.h
+++ b/ui/views/window/dialog_client_view.h
@@ -72,8 +72,10 @@ class VIEWS_EXPORT DialogClientView : public ClientView, public DialogObserver {
   // Essentially it prevents clicks that happen within a user's double click
   // interval from when the protection is started as well as any following
   // clicks that happen in shorter succession than the user's double click
-  // interval. Refer to InputEventActivationProtector for more information.
-  void TriggerInputProtection();
+  // interval. Refer to InputEventActivationProtector for more information. If
+  // |force_early| is true, force to trigger even earlier (shortly before the
+  // this view is visible).
+  void TriggerInputProtection(bool force_early = false);
 
   void Layout() override;
   bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
diff --git a/ui/views/window/dialog_client_view_unittest.cc b/ui/views/window/dialog_client_view_unittest.cc
index 3a81467e7d332..d0525cb1a9314 100644
--- a/ui/views/window/dialog_client_view_unittest.cc
+++ b/ui/views/window/dialog_client_view_unittest.cc
@@ -11,6 +11,7 @@
 #include <utility>
 
 #include "base/memory/raw_ptr.h"
+#include "base/test/task_environment.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
 #include "ui/base/ui_base_types.h"
@@ -36,7 +37,8 @@ namespace views {
 // TestDialogClientView.
 class DialogClientViewTest : public test::WidgetTest {
  public:
-  DialogClientViewTest() = default;
+  DialogClientViewTest()
+      : test::WidgetTest(base::test::TaskEnvironment::TimeSource::MOCK_TIME) {}
 
   DialogClientViewTest(const DialogClientViewTest&) = delete;
   DialogClientViewTest& operator=(const DialogClientViewTest&) = delete;
@@ -554,6 +556,75 @@ TEST_F(DialogClientViewTest, IgnorePossiblyUnintendedClicks_ClickAfterShown) {
   EXPECT_TRUE(widget()->IsClosed());
 }
 
+// TODO(https://crbug.com/1449221): investigate the tests on ChromeOS and
+// fuchsia
+#if !BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_FUCHSIA)
+class DesktopDialogClientViewTest : public DialogClientViewTest {
+ public:
+  void SetUp() override {
+    set_native_widget_type(NativeWidgetType::kDesktop);
+    DialogClientViewTest::SetUp();
+  }
+};
+
+// Ensures that unintended clicks are protected properly when a root window's
+// bound has been changed.
+TEST_F(DesktopDialogClientViewTest,
+       IgnorePossiblyUnintendedClicks_TopLevelWindowBoundsChanged) {
+  SetDialogButtons(ui::DIALOG_BUTTON_CANCEL | ui::DIALOG_BUTTON_OK);
+  SizeAndLayoutWidget();
+  widget()->Show();
+  task_environment()->FastForwardBy(
+      base::Milliseconds(GetDoubleClickInterval() * 2));
+
+  // Create another widget on top, change window's bounds, click event to the
+  // old widget should be ignored.
+  auto* widget1 = CreateTopLevelNativeWidget();
+  widget1->SetBounds(gfx::Rect(50, 50, 100, 100));
+  ui::MouseEvent mouse_event(ui::ET_MOUSE_PRESSED, gfx::Point(), gfx::Point(),
+                             ui::EventTimeForNow(), ui::EF_NONE, ui::EF_NONE);
+  test::ButtonTestApi(client_view()->ok_button()).NotifyClick(mouse_event);
+  test::ButtonTestApi cancel_button(client_view()->cancel_button());
+  cancel_button.NotifyClick(mouse_event);
+  EXPECT_FALSE(widget()->IsClosed());
+
+  cancel_button.NotifyClick(ui::MouseEvent(
+      ui::ET_MOUSE_PRESSED, gfx::Point(), gfx::Point(),
+      ui::EventTimeForNow() + base::Milliseconds(GetDoubleClickInterval()),
+      ui::EF_NONE, ui::EF_NONE));
+  EXPECT_TRUE(widget()->IsClosed());
+  widget1->CloseNow();
+}
+
+// Ensures that unintended clicks are protected properly when a root window has
+// been closed.
+TEST_F(DesktopDialogClientViewTest,
+       IgnorePossiblyUnintendedClicks_CloseRootWindow) {
+  SetDialogButtons(ui::DIALOG_BUTTON_CANCEL | ui::DIALOG_BUTTON_OK);
+  SizeAndLayoutWidget();
+  widget()->Show();
+  task_environment()->FastForwardBy(
+      base::Milliseconds(GetDoubleClickInterval() * 2));
+
+  // Create another widget on top, close the top window, click event to the old
+  // widget should be ignored.
+  auto* widget1 = CreateTopLevelNativeWidget();
+  widget1->CloseNow();
+  ui::MouseEvent mouse_event(ui::ET_MOUSE_PRESSED, gfx::Point(), gfx::Point(),
+                             ui::EventTimeForNow(), ui::EF_NONE, ui::EF_NONE);
+  test::ButtonTestApi(client_view()->ok_button()).NotifyClick(mouse_event);
+  test::ButtonTestApi cancel_button(client_view()->cancel_button());
+  cancel_button.NotifyClick(mouse_event);
+  EXPECT_FALSE(widget()->IsClosed());
+
+  cancel_button.NotifyClick(ui::MouseEvent(
+      ui::ET_MOUSE_PRESSED, gfx::Point(), gfx::Point(),
+      ui::EventTimeForNow() + base::Milliseconds(GetDoubleClickInterval()),
+      ui::EF_NONE, ui::EF_NONE));
+  EXPECT_TRUE(widget()->IsClosed());
+}
+#endif  // !BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_FUCHSIA)
+
 // Ensures that repeated clicks with short intervals after view has been shown
 // are also ignored.
 TEST_F(DialogClientViewTest, IgnorePossiblyUnintendedClicks_RepeatedClicks) {
diff --git a/ui/views/window/dialog_delegate.cc b/ui/views/window/dialog_delegate.cc
index 938e6ab7ca8ee..f8534ef8ee922 100644
--- a/ui/views/window/dialog_delegate.cc
+++ b/ui/views/window/dialog_delegate.cc
@@ -339,8 +339,8 @@ void DialogDelegate::DialogModelChanged() {
     observer.OnDialogChanged();
 }
 
-void DialogDelegate::TriggerInputProtection() {
-  GetDialogClientView()->TriggerInputProtection();
+void DialogDelegate::TriggerInputProtection(bool force_early) {
+  GetDialogClientView()->TriggerInputProtection(force_early);
 }
 
 void DialogDelegate::SetDefaultButton(int button) {
diff --git a/ui/views/window/dialog_delegate.h b/ui/views/window/dialog_delegate.h
index fca669a962357..ca8ef29878e8e 100644
--- a/ui/views/window/dialog_delegate.h
+++ b/ui/views/window/dialog_delegate.h
@@ -228,7 +228,7 @@ class VIEWS_EXPORT DialogDelegate : public WidgetDelegate {
   // interval from when the protection is started as well as any following
   // clicks that happen in shorter succession than the user's double click
   // interval. Refer to InputEventActivationProtector for more information.
-  void TriggerInputProtection();
+  void TriggerInputProtection(bool force_early = false);
 
   void set_use_round_corners(bool round) { params_.round_corners = round; }
   void set_corner_radius(int corner_radius) {
diff --git a/ui/views/windows_stationarity_monitor.cc b/ui/views/windows_stationarity_monitor.cc
new file mode 100644
index 0000000000000..f28f2aff2627b
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor.cc
@@ -0,0 +1,27 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/windows_stationarity_monitor.h"
+
+namespace views {
+
+WindowsStationarityMonitor::WindowsStationarityMonitor() = default;
+
+WindowsStationarityMonitor::~WindowsStationarityMonitor() = default;
+
+void WindowsStationarityMonitor::AddObserver(Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void WindowsStationarityMonitor::RemoveObserver(Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+void WindowsStationarityMonitor::NotifyWindowStationaryStateChanged() {
+  for (auto& observer : observers_) {
+    observer.OnWindowStationaryStateChanged();
+  }
+}
+
+}  // namespace views
diff --git a/ui/views/windows_stationarity_monitor.h b/ui/views/windows_stationarity_monitor.h
new file mode 100644
index 0000000000000..db7731677792b
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor.h
@@ -0,0 +1,56 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_H_
+#define UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_H_
+
+#include "base/observer_list.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+// A singleton class used to track the stationary state of a list Windows and
+// notify registered `InputEventActivationProtector` whenever a tracked window
+// has changed its bound or has been closed. Consequently, the input event
+// protector should block user input events for a proper delay from that
+// timestamp. The tracked list contains native windows which are encapsulated in
+// a window host implementation for specific platforms (WindowTreeHost on aura)
+// or NativeWidgetMac on Mac. When a window is destroyed, it is removed from the
+// tracked list.
+class VIEWS_EXPORT WindowsStationarityMonitor {
+ public:
+  class Observer {
+   public:
+    // Called before a tracked window is destroyed or changed bounds.
+    virtual void OnWindowStationaryStateChanged() {}
+
+   protected:
+    virtual ~Observer() = default;
+  };
+
+  WindowsStationarityMonitor(const WindowsStationarityMonitor&) = delete;
+  WindowsStationarityMonitor& operator=(const WindowsStationarityMonitor&) =
+      delete;
+
+  virtual ~WindowsStationarityMonitor();
+
+  // Adds/Removes an observer that will care about whenever the tracked windows
+  // have been changed (e.g. a window closed or bounds changed)
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+
+  static WindowsStationarityMonitor* GetInstance();
+
+ protected:
+  WindowsStationarityMonitor();
+
+  void NotifyWindowStationaryStateChanged();
+
+ private:
+  base::ObserverList<Observer>::Unchecked observers_;
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_H_
diff --git a/ui/views/windows_stationarity_monitor_aura.cc b/ui/views/windows_stationarity_monitor_aura.cc
new file mode 100644
index 0000000000000..52cb7cd4205ac
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor_aura.cc
@@ -0,0 +1,65 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/windows_stationarity_monitor_aura.h"
+
+#include "base/containers/cxx20_erase.h"
+#include "base/no_destructor.h"
+#include "base/ranges/algorithm.h"
+#include "ui/aura/env.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace views {
+
+WindowsStationarityMonitorAura::WindowsStationarityMonitorAura() {
+  aura::Env::GetInstance()->AddObserver(this);
+  for (auto* window_tree_host : aura::Env::GetInstance()->window_tree_hosts()) {
+    OnHostInitialized(window_tree_host);
+  }
+}
+
+WindowsStationarityMonitorAura::~WindowsStationarityMonitorAura() {
+  for (auto* window : tracked_windows_) {
+    window->RemoveObserver(this);
+  }
+  aura::Env::GetInstance()->RemoveObserver(this);
+  tracked_windows_.clear();
+}
+
+// static
+WindowsStationarityMonitorAura* WindowsStationarityMonitorAura::GetInstance() {
+  static base::NoDestructor<WindowsStationarityMonitorAura> instance;
+  return instance.get();
+}
+
+void WindowsStationarityMonitorAura::OnHostInitialized(
+    aura::WindowTreeHost* host) {
+  tracked_windows_.push_back(host->window());
+  host->window()->AddObserver(this);
+}
+
+void WindowsStationarityMonitorAura::OnWindowDestroying(aura::Window* window) {
+  base::Erase(tracked_windows_, window);
+  NotifyWindowStationaryStateChanged();
+}
+
+void WindowsStationarityMonitorAura::OnWindowBoundsChanged(
+    aura::Window* window,
+    const gfx::Rect& old_bounds,
+    const gfx::Rect& new_bounds,
+    ui::PropertyChangeReason reason) {
+  // We will consider from-animation reason the same as not-from-animation
+  // reason. The main consumer |InputEventActivationProtector| will block input
+  // event even when the window bounds change due to animation.
+  NotifyWindowStationaryStateChanged();
+}
+
+// static
+WindowsStationarityMonitor* WindowsStationarityMonitor::GetInstance() {
+  return WindowsStationarityMonitorAura::GetInstance();
+}
+
+}  // namespace views
diff --git a/ui/views/windows_stationarity_monitor_aura.h b/ui/views/windows_stationarity_monitor_aura.h
new file mode 100644
index 0000000000000..94d8d33f2f160
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor_aura.h
@@ -0,0 +1,57 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_AURA_H_
+#define UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_AURA_H_
+
+#include <vector>
+
+#include "ui/aura/env_observer.h"
+#include "ui/aura/window_observer.h"
+#include "ui/compositor/property_change_reason.h"
+#include "ui/views/windows_stationarity_monitor.h"
+
+namespace aura {
+class Window;
+class WindowTreeHost;
+}  // namespace aura
+
+namespace gfx {
+class Rect;
+}  // namespace gfx
+
+namespace views {
+
+class WindowsStationarityMonitorAura : public WindowsStationarityMonitor,
+                                       public aura::EnvObserver,
+                                       public aura::WindowObserver {
+ public:
+  WindowsStationarityMonitorAura();
+
+  WindowsStationarityMonitorAura(const WindowsStationarityMonitorAura&) =
+      delete;
+  WindowsStationarityMonitorAura& operator=(
+      const WindowsStationarityMonitorAura&) = delete;
+
+  static WindowsStationarityMonitorAura* GetInstance();
+
+  // aura::EnvObserver:
+  void OnHostInitialized(aura::WindowTreeHost* host) override;
+
+  // aura::WindowObserver:
+  void OnWindowDestroying(aura::Window* window) override;
+  void OnWindowBoundsChanged(aura::Window* window,
+                             const gfx::Rect& old_bounds,
+                             const gfx::Rect& new_bounds,
+                             ui::PropertyChangeReason reason) override;
+
+ private:
+  ~WindowsStationarityMonitorAura() override;
+
+  std::vector<aura::Window*> tracked_windows_;
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_AURA_H_
diff --git a/ui/views/windows_stationarity_monitor_mac.h b/ui/views/windows_stationarity_monitor_mac.h
new file mode 100644
index 0000000000000..4678d45645f89
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor_mac.h
@@ -0,0 +1,48 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_MAC_H_
+#define UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_MAC_H_
+
+#include <vector>
+
+#include "base/callback_list.h"
+#include "ui/views/widget/widget_observer.h"
+#include "ui/views/windows_stationarity_monitor.h"
+
+namespace views {
+
+class NativeWidgetMac;
+class Widget;
+
+class WindowsStationarityMonitorMac : public WindowsStationarityMonitor,
+                                      WidgetObserver {
+ public:
+  WindowsStationarityMonitorMac();
+
+  WindowsStationarityMonitorMac(const WindowsStationarityMonitorMac&) = delete;
+  WindowsStationarityMonitorMac& operator=(
+      const WindowsStationarityMonitorMac&) = delete;
+
+  static WindowsStationarityMonitorMac* GetInstance();
+
+  // views::WidgetObserver
+  void OnWidgetDestroying(Widget* widget) override;
+  void OnWidgetBoundsChanged(Widget* widget,
+                             const gfx::Rect& new_bounds) override;
+
+ private:
+  ~WindowsStationarityMonitorMac() override;
+
+  void OnNativeWidgetAdded(NativeWidgetMac* native_widget);
+
+  std::vector<Widget*> tracked_windows_;
+
+  // Callback to run whenever a |NativeWidgetMac| is created.
+  base::CallbackListSubscription init_native_widget_subscription_;
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WINDOWS_STATIONARITY_MONITOR_MAC_H_
diff --git a/ui/views/windows_stationarity_monitor_mac.mm b/ui/views/windows_stationarity_monitor_mac.mm
new file mode 100644
index 0000000000000..5102f70afd1b4
--- /dev/null
+++ b/ui/views/windows_stationarity_monitor_mac.mm
@@ -0,0 +1,71 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/windows_stationarity_monitor_mac.h"
+
+#import <AppKit/AppKit.h>
+
+#include "base/containers/cxx20_erase.h"
+#include "base/functional/bind.h"
+#include "base/no_destructor.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/views/widget/native_widget_mac.h"
+#include "ui/views/widget/widget.h"
+
+namespace views {
+
+WindowsStationarityMonitorMac::WindowsStationarityMonitorMac()
+    : init_native_widget_subscription_(
+          views::NativeWidgetMac::RegisterInitNativeWidgetCallback(
+              base::BindRepeating(
+                  &WindowsStationarityMonitorMac::OnNativeWidgetAdded,
+                  base::Unretained(this)))) {
+  for (NSWindow* window : [NSApp windows]) {
+    if (auto* widget = Widget::GetWidgetForNativeWindow(window)) {
+      widget->AddObserver(this);
+      tracked_windows_.push_back(widget);
+    }
+  }
+}
+
+WindowsStationarityMonitorMac::~WindowsStationarityMonitorMac() {
+  for (auto* widget : tracked_windows_) {
+    widget->RemoveObserver(this);
+  }
+  tracked_windows_.clear();
+  init_native_widget_subscription_ = {};
+}
+
+// static
+WindowsStationarityMonitorMac* WindowsStationarityMonitorMac::GetInstance() {
+  static base::NoDestructor<WindowsStationarityMonitorMac> instance;
+  return instance.get();
+}
+
+void WindowsStationarityMonitorMac::OnWidgetDestroying(Widget* widget) {
+  widget->RemoveObserver(this);
+  base::Erase(tracked_windows_, widget);
+  NotifyWindowStationaryStateChanged();
+}
+
+void WindowsStationarityMonitorMac::OnWidgetBoundsChanged(
+    Widget* widget,
+    const gfx::Rect& new_bounds) {
+  NotifyWindowStationaryStateChanged();
+}
+
+void WindowsStationarityMonitorMac::OnNativeWidgetAdded(
+    NativeWidgetMac* native_widget) {
+  auto* widget = native_widget->GetWidget();
+  DCHECK(widget);
+  tracked_windows_.push_back(widget);
+  widget->AddObserver(this);
+}
+
+// static
+WindowsStationarityMonitor* WindowsStationarityMonitor::GetInstance() {
+  return WindowsStationarityMonitorMac::GetInstance();
+}
+
+}  // namespace views
