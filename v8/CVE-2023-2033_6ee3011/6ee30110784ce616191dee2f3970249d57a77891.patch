commit 6ee30110784ce616191dee2f3970249d57a77891	6ee30110784ce616191dee2f3970249d57a77891
Author: Samuel Groß <saelo@chromium.org>
Date:   Fri Apr 14 11:05:11 2023 +0000

    Reland "[sandbox] Sandboxify WasmIndirectFunctionTable"
    
    This is a reland of commit b2a94c9023da70c99223640bf99c203425b42dda
    
    WasmIndirectFunctionTable::New now makes sure to initialize all fields
    before a GC can occur.
    
    Original change's description:
    > [sandbox] Sandboxify WasmIndirectFunctionTable
    >
    > The WasmIndirectFunctionTable object used to contain a number of raw
    > pointers to buffers allocated via malloc: the sig_ids and targets
    > fields. As these were raw pointers, they could be abused by an attacker
    > to access memory outside of the sandbox, and thereby break out of it.
    >
    > This CL now simply turns these two buffers into on-heap ByteArrays.
    >
    > In the future, we'll also need to prevent an attacker from manipulating
    > the contents of these arrays (at least of the targets array, which
    > contains function entrypoints), but we'll need additional sandbox
    > infrastructure before we can do so.
    >
    > Bug: v8:10391, chromium:1432210
    > Change-Id: Ide63b241761d97fc110bc7369032e30bc946f295
    > Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4418966
    > Reviewed-by: Clemens Backes <clemensb@chromium.org>
    > Commit-Queue: Samuel Groß <saelo@chromium.org>
    > Cr-Commit-Position: refs/heads/main@{#87084}
    
    Bug: v8:10391, chromium:1432210
    Change-Id: I655614b2a09d98e8557f17d71ea6c06507aa9b3c
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4421304
    Reviewed-by: Clemens Backes <clemensb@chromium.org>
    Commit-Queue: Samuel Groß <saelo@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#87090}

diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index e95f9c1230b..433ee367909 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -2845,9 +2845,9 @@ void WasmGraphBuilder::LoadIndirectFunctionTable(uint32_t table_index,
                                               MachineType::Uint32());
     }
     *ift_sig_ids = LOAD_MUTABLE_INSTANCE_FIELD(IndirectFunctionTableSigIds,
-                                               MachineType::Pointer());
+                                               MachineType::TaggedPointer());
     *ift_targets = LOAD_MUTABLE_INSTANCE_FIELD(IndirectFunctionTableTargets,
-                                               MachineType::Pointer());
+                                               MachineType::TaggedPointer());
     *ift_instances = LOAD_MUTABLE_INSTANCE_FIELD(IndirectFunctionTableRefs,
                                                  MachineType::TaggedPointer());
     return;
@@ -2864,11 +2864,11 @@ void WasmGraphBuilder::LoadIndirectFunctionTable(uint32_t table_index,
   }
 
   *ift_sig_ids = gasm_->LoadFromObject(
-      MachineType::Pointer(), ift_table,
+      MachineType::TaggedPointer(), ift_table,
       wasm::ObjectAccess::ToTagged(WasmIndirectFunctionTable::kSigIdsOffset));
 
   *ift_targets = gasm_->LoadFromObject(
-      MachineType::Pointer(), ift_table,
+      MachineType::TaggedPointer(), ift_table,
       wasm::ObjectAccess::ToTagged(WasmIndirectFunctionTable::kTargetsOffset));
 
   *ift_instances = gasm_->LoadFromObject(
@@ -2894,6 +2894,7 @@ Node* WasmGraphBuilder::BuildIndirectCall(uint32_t table_index,
                             &ift_instances);
 
   Node* key = args[0];
+  Node* key_intptr = gasm_->BuildChangeUint32ToUintPtr(key);
 
   // Bounds check against the table size.
   Node* in_bounds = gasm_->Uint32LessThan(key, ift_size);
@@ -2914,10 +2915,8 @@ Node* WasmGraphBuilder::BuildIndirectCall(uint32_t table_index,
         MachineType::Uint32(), isorecursive_canonical_types,
         gasm_->IntPtrConstant(sig_index * kInt32Size));
 
-    Node* int32_scaled_key = gasm_->BuildChangeUint32ToUintPtr(
-        gasm_->Word32Shl(key, Int32Constant(2)));
-    Node* loaded_sig = gasm_->LoadFromObject(MachineType::Int32(), ift_sig_ids,
-                                             int32_scaled_key);
+    Node* loaded_sig = gasm_->LoadByteArrayElement(ift_sig_ids, key_intptr,
+                                                   MachineType::Int32());
     Node* sig_match = gasm_->Word32Equal(loaded_sig, expected_sig_id);
 
     if (enabled_features_.has_gc() &&
@@ -2978,24 +2977,17 @@ Node* WasmGraphBuilder::BuildIndirectCall(uint32_t table_index,
       TrapIfFalse(wasm::kTrapFuncSigMismatch, sig_match, position);
     }
   } else if (needs_null_check) {
-    Node* int32_scaled_key = gasm_->BuildChangeUint32ToUintPtr(
-        gasm_->Word32Shl(key, Int32Constant(2)));
-    Node* loaded_sig = gasm_->LoadFromObject(MachineType::Int32(), ift_sig_ids,
-                                             int32_scaled_key);
+    Node* loaded_sig = gasm_->LoadByteArrayElement(ift_sig_ids, key_intptr,
+                                                   MachineType::Int32());
     TrapIfTrue(wasm::kTrapFuncSigMismatch,
                gasm_->Word32Equal(loaded_sig, Int32Constant(-1)), position);
   }
 
-  Node* key_intptr = gasm_->BuildChangeUint32ToUintPtr(key);
-
   Node* target_instance = gasm_->LoadFixedArrayElement(
       ift_instances, key_intptr, MachineType::TaggedPointer());
 
-  Node* intptr_scaled_key =
-      gasm_->IntMul(key_intptr, gasm_->IntPtrConstant(kSystemPointerSize));
-
-  Node* target = gasm_->LoadFromObject(MachineType::Pointer(), ift_targets,
-                                       intptr_scaled_key);
+  Node* target = gasm_->LoadByteArrayElement(ift_targets, key_intptr,
+                                             MachineType::Pointer());
 
   args[0] = target;
 
diff --git a/src/compiler/wasm-graph-assembler.cc b/src/compiler/wasm-graph-assembler.cc
index e51bc001f5e..a635b430540 100644
--- a/src/compiler/wasm-graph-assembler.cc
+++ b/src/compiler/wasm-graph-assembler.cc
@@ -257,6 +257,7 @@ Node* WasmGraphAssembler::LoadFixedArrayLengthAsSmi(Node* fixed_array) {
 Node* WasmGraphAssembler::LoadFixedArrayElement(Node* fixed_array,
                                                 Node* index_intptr,
                                                 MachineType type) {
+  DCHECK(IsSubtype(type.representation(), MachineRepresentation::kTagged));
   Node* offset = IntAdd(
       IntMul(index_intptr, IntPtrConstant(kTaggedSize)),
       IntPtrConstant(wasm::ObjectAccess::ToTagged(FixedArray::kHeaderSize)));
@@ -287,6 +288,16 @@ Node* WasmGraphAssembler::LoadFixedArrayElement(Node* array, int index,
       type, array, wasm::ObjectAccess::ElementOffsetInTaggedFixedArray(index));
 }
 
+Node* WasmGraphAssembler::LoadByteArrayElement(Node* byte_array,
+                                               Node* index_intptr,
+                                               MachineType type) {
+  int element_size = ElementSizeInBytes(type.representation());
+  Node* offset = IntAdd(
+      IntMul(index_intptr, IntPtrConstant(element_size)),
+      IntPtrConstant(wasm::ObjectAccess::ToTagged(ByteArray::kHeaderSize)));
+  return LoadFromObject(type, byte_array, offset);
+}
+
 Node* WasmGraphAssembler::StoreFixedArrayElement(Node* array, int index,
                                                  Node* value,
                                                  ObjectAccess access) {
diff --git a/src/compiler/wasm-graph-assembler.h b/src/compiler/wasm-graph-assembler.h
index b05569390fd..709618eabef 100644
--- a/src/compiler/wasm-graph-assembler.h
+++ b/src/compiler/wasm-graph-assembler.h
@@ -200,6 +200,9 @@ class WasmGraphAssembler : public GraphAssembler {
     return LoadFixedArrayElement(array, index, MachineType::AnyTagged());
   }
 
+  Node* LoadByteArrayElement(Node* byte_array, Node* index_intptr,
+                             MachineType type);
+
   Node* StoreFixedArrayElement(Node* array, int index, Node* value,
                                ObjectAccess access);
 
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index 2e2899f47e3..da8b5f1b42f 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -2192,8 +2192,8 @@ void WasmInstanceObject::WasmInstanceObjectPrint(std::ostream& os) {
   PRINT_WASM_INSTANCE_FIELD(globals_start, to_void_ptr);
   PRINT_WASM_INSTANCE_FIELD(imported_mutable_globals, Brief);
   PRINT_WASM_INSTANCE_FIELD(indirect_function_table_size, +);
-  PRINT_WASM_INSTANCE_FIELD(indirect_function_table_sig_ids, to_void_ptr);
-  PRINT_WASM_INSTANCE_FIELD(indirect_function_table_targets, to_void_ptr);
+  PRINT_WASM_INSTANCE_FIELD(indirect_function_table_sig_ids, Brief);
+  PRINT_WASM_INSTANCE_FIELD(indirect_function_table_targets, Brief);
   PRINT_WASM_INSTANCE_FIELD(isorecursive_canonical_types,
                             reinterpret_cast<const uint32_t*>);
   PRINT_WASM_INSTANCE_FIELD(jump_table_start, to_void_ptr);
@@ -2302,12 +2302,8 @@ void WasmIndirectFunctionTable::WasmIndirectFunctionTablePrint(
     std::ostream& os) {
   PrintHeader(os, "WasmIndirectFunctionTable");
   os << "\n - size: " << size();
-  os << "\n - sig_ids: " << static_cast<void*>(sig_ids());
-  os << "\n - targets: " << static_cast<void*>(targets());
-  if (has_managed_native_allocations()) {
-    os << "\n - managed_native_allocations: "
-       << Brief(managed_native_allocations());
-  }
+  os << "\n - sig_ids: " << Brief(sig_ids());
+  os << "\n - targets: " << Brief(targets());
   os << "\n - refs: " << Brief(refs());
   os << "\n";
 }
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 7d8bcc6adf0..e58aeedf43a 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -7598,16 +7598,19 @@ class LiftoffCompiler {
 
       // Load the signature from {instance->ift_sig_ids[key]}
       if (imm.table_imm.index == 0) {
-        LOAD_INSTANCE_FIELD(real_sig_id, IndirectFunctionTableSigIds,
-                            kSystemPointerSize, pinned);
+        LOAD_TAGGED_PTR_INSTANCE_FIELD(real_sig_id, IndirectFunctionTableSigIds,
+                                       pinned);
       } else {
-        __ Load(LiftoffRegister(real_sig_id), indirect_function_table, no_reg,
-                wasm::ObjectAccess::ToTagged(
-                    WasmIndirectFunctionTable::kSigIdsOffset),
-                kPointerLoadType);
+        __ LoadTaggedPointer(real_sig_id, indirect_function_table, no_reg,
+                             wasm::ObjectAccess::ToTagged(
+                                 WasmIndirectFunctionTable::kSigIdsOffset));
       }
-      static_assert((1 << 2) == kInt32Size);
-      __ Load(LiftoffRegister(real_sig_id), real_sig_id, index, 0,
+      // Here and below, the FixedUint32Array holding the sig ids is really
+      // just a ByteArray interpreted as uint32s, so the offset to the start of
+      // the elements is the ByteArray header size.
+      // TODO(saelo) maybe make the names of these arrays less confusing?
+      int buffer_offset = wasm::ObjectAccess::ToTagged(ByteArray::kHeaderSize);
+      __ Load(LiftoffRegister(real_sig_id), real_sig_id, index, buffer_offset,
               LoadType::kI32Load, nullptr, false, false, true);
 
       // Compare against expected signature.
@@ -7690,16 +7693,15 @@ class LiftoffCompiler {
 
       // Load the signature from {instance->ift_sig_ids[key]}
       if (imm.table_imm.index == 0) {
-        LOAD_INSTANCE_FIELD(real_sig_id, IndirectFunctionTableSigIds,
-                            kSystemPointerSize, pinned);
+        LOAD_TAGGED_PTR_INSTANCE_FIELD(real_sig_id, IndirectFunctionTableSigIds,
+                                       pinned);
       } else {
-        __ Load(LiftoffRegister(real_sig_id), indirect_function_table, no_reg,
-                wasm::ObjectAccess::ToTagged(
-                    WasmIndirectFunctionTable::kSigIdsOffset),
-                kPointerLoadType);
+        __ LoadTaggedPointer(real_sig_id, indirect_function_table, no_reg,
+                             wasm::ObjectAccess::ToTagged(
+                                 WasmIndirectFunctionTable::kSigIdsOffset));
       }
-      static_assert((1 << 2) == kInt32Size);
-      __ Load(LiftoffRegister(real_sig_id), real_sig_id, index, 0,
+      int buffer_offset = wasm::ObjectAccess::ToTagged(ByteArray::kHeaderSize);
+      __ Load(LiftoffRegister(real_sig_id), real_sig_id, index, buffer_offset,
               LoadType::kI32Load, nullptr, false, false, true);
 
       Label* sig_mismatch_label =
@@ -7733,17 +7735,16 @@ class LiftoffCompiler {
 
       // Load the target from {instance->ift_targets[key]}
       if (imm.table_imm.index == 0) {
-        LOAD_INSTANCE_FIELD(function_target, IndirectFunctionTableTargets,
-                            kSystemPointerSize, pinned);
+        LOAD_TAGGED_PTR_INSTANCE_FIELD(function_target,
+                                       IndirectFunctionTableTargets, pinned);
       } else {
-        __ Load(LiftoffRegister(function_target), indirect_function_table,
-                no_reg,
-                wasm::ObjectAccess::ToTagged(
-                    WasmIndirectFunctionTable::kTargetsOffset),
-                kPointerLoadType);
+        __ LoadTaggedPointer(function_target, indirect_function_table, no_reg,
+                             wasm::ObjectAccess::ToTagged(
+                                 WasmIndirectFunctionTable::kTargetsOffset));
       }
-      __ Load(LiftoffRegister(function_target), function_target, index, 0,
-              kPointerLoadType, nullptr, false, false, true);
+      int buffer_offset = wasm::ObjectAccess::ToTagged(ByteArray::kHeaderSize);
+      __ Load(LiftoffRegister(function_target), function_target, index,
+              buffer_offset, kPointerLoadType, nullptr, false, false, true);
 
       auto call_descriptor = compiler::GetWasmCallDescriptor(zone_, imm.sig);
       call_descriptor = GetLoweredCallDescriptor(zone_, call_descriptor);
diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index 5d1f10642b8..2e8c0ad0651 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -203,10 +203,10 @@ ACCESSORS(WasmInstanceObject, imported_function_targets, FixedAddressArray,
           kImportedFunctionTargetsOffset)
 PRIMITIVE_ACCESSORS(WasmInstanceObject, indirect_function_table_size, uint32_t,
                     kIndirectFunctionTableSizeOffset)
-PRIMITIVE_ACCESSORS(WasmInstanceObject, indirect_function_table_sig_ids,
-                    uint32_t*, kIndirectFunctionTableSigIdsOffset)
-PRIMITIVE_ACCESSORS(WasmInstanceObject, indirect_function_table_targets,
-                    Address*, kIndirectFunctionTableTargetsOffset)
+ACCESSORS(WasmInstanceObject, indirect_function_table_sig_ids, FixedUInt32Array,
+          kIndirectFunctionTableSigIdsOffset)
+ACCESSORS(WasmInstanceObject, indirect_function_table_targets,
+          FixedAddressArray, kIndirectFunctionTableTargetsOffset)
 PRIMITIVE_ACCESSORS(WasmInstanceObject, jump_table_start, Address,
                     kJumpTableStartOffset)
 PRIMITIVE_ACCESSORS(WasmInstanceObject, hook_on_function_call_address, Address,
@@ -308,12 +308,8 @@ CAST_ACCESSOR(WasmExternalFunction)
 
 // WasmIndirectFunctionTable
 TQ_OBJECT_CONSTRUCTORS_IMPL(WasmIndirectFunctionTable)
-PRIMITIVE_ACCESSORS(WasmIndirectFunctionTable, sig_ids, uint32_t*,
-                    kSigIdsOffset)
-PRIMITIVE_ACCESSORS(WasmIndirectFunctionTable, targets, Address*,
-                    kTargetsOffset)
-OPTIONAL_ACCESSORS(WasmIndirectFunctionTable, managed_native_allocations,
-                   Foreign, kManagedNativeAllocationsOffset)
+ACCESSORS(WasmIndirectFunctionTable, sig_ids, FixedUInt32Array, kSigIdsOffset)
+ACCESSORS(WasmIndirectFunctionTable, targets, FixedAddressArray, kTargetsOffset)
 
 // WasmTypeInfo
 EXTERNAL_POINTER_ACCESSORS(WasmTypeInfo, native_type, Address,
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 05d7905806f..1d3847d6988 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -626,61 +626,39 @@ void WasmTableObject::GetFunctionTableEntry(
   *is_valid = false;
 }
 
-namespace {
-class IftNativeAllocations {
- public:
-  IftNativeAllocations(Handle<WasmIndirectFunctionTable> table, uint32_t size)
-      : sig_ids_(size), targets_(size) {
-    table->set_sig_ids(sig_ids_.data());
-    table->set_targets(targets_.data());
-  }
-
-  static size_t SizeInMemory(uint32_t size) {
-    return size * (sizeof(Address) + sizeof(uint32_t));
-  }
-
-  void resize(Handle<WasmIndirectFunctionTable> table, uint32_t new_size) {
-    DCHECK_GE(new_size, sig_ids_.size());
-    DCHECK_EQ(this, Managed<IftNativeAllocations>::cast(
-                        table->managed_native_allocations())
-                        .raw());
-    sig_ids_.resize(new_size);
-    targets_.resize(new_size);
-    table->set_sig_ids(sig_ids_.data());
-    table->set_targets(targets_.data());
-  }
-
- private:
-  std::vector<uint32_t> sig_ids_;
-  std::vector<Address> targets_;
-};
-}  // namespace
-
 Handle<WasmIndirectFunctionTable> WasmIndirectFunctionTable::New(
     Isolate* isolate, uint32_t size) {
   auto refs = isolate->factory()->NewFixedArray(static_cast<int>(size));
+  auto sig_ids = FixedUInt32Array::New(isolate, size);
+  auto targets = FixedAddressArray::New(isolate, size);
+
   auto table = Handle<WasmIndirectFunctionTable>::cast(
       isolate->factory()->NewStruct(WASM_INDIRECT_FUNCTION_TABLE_TYPE));
+
+  // Disallow GC until all fields have acceptable types.
+  DisallowGarbageCollection no_gc;
+
   table->set_size(size);
   table->set_refs(*refs);
-  auto native_allocations = Managed<IftNativeAllocations>::Allocate(
-      isolate, IftNativeAllocations::SizeInMemory(size), table, size);
-  table->set_managed_native_allocations(*native_allocations);
+  table->set_sig_ids(*sig_ids);
+  table->set_targets(*targets);
   for (uint32_t i = 0; i < size; ++i) {
     table->Clear(i);
   }
+
   return table;
 }
+
 void WasmIndirectFunctionTable::Set(uint32_t index, int sig_id,
                                     Address call_target, Object ref) {
-  sig_ids()[index] = sig_id;
-  targets()[index] = call_target;
+  sig_ids().set(index, sig_id);
+  targets().set(index, call_target);
   refs().set(index, ref);
 }
 
 void WasmIndirectFunctionTable::Clear(uint32_t index) {
-  sig_ids()[index] = -1;
-  targets()[index] = 0;
+  sig_ids().set(index, -1);
+  targets().set(index, 0);
   refs().set(
       index,
       ReadOnlyRoots(GetIsolateFromWritableObject(*this)).undefined_value());
@@ -697,6 +675,9 @@ void WasmIndirectFunctionTable::Resize(Isolate* isolate,
   // Grow table exponentially to guarantee amortized constant allocation and gc
   // time.
   Handle<FixedArray> old_refs(table->refs(), isolate);
+  Handle<FixedUInt32Array> old_sig_ids(table->sig_ids(), isolate);
+  Handle<FixedAddressArray> old_targets(table->targets(), isolate);
+
   // Since we might have overallocated, {old_capacity} might be different than
   // {old_size}.
   uint32_t old_capacity = old_refs->length();
@@ -704,13 +685,22 @@ void WasmIndirectFunctionTable::Resize(Isolate* isolate,
   if (new_size <= old_capacity) return;
   uint32_t new_capacity = std::max(2 * old_capacity, new_size);
 
-  Managed<IftNativeAllocations>::cast(table->managed_native_allocations())
-      .raw()
-      ->resize(table, new_capacity);
+  Handle<FixedUInt32Array> new_sig_ids =
+      FixedUInt32Array::New(isolate, new_capacity);
+  new_sig_ids->copy_in(0, old_sig_ids->GetDataStartAddress(),
+                       old_capacity * kUInt32Size);
+  table->set_sig_ids(*new_sig_ids);
+
+  Handle<FixedAddressArray> new_targets =
+      FixedAddressArray::New(isolate, new_capacity);
+  new_targets->copy_in(0, old_targets->GetDataStartAddress(),
+                       old_capacity * kSystemPointerSize);
+  table->set_targets(*new_targets);
 
   Handle<FixedArray> new_refs = isolate->factory()->CopyFixedArrayAndGrow(
       old_refs, static_cast<int>(new_capacity - old_capacity));
   table->set_refs(*new_refs);
+
   for (uint32_t i = old_capacity; i < new_capacity; ++i) {
     table->Clear(i);
   }
@@ -1180,8 +1170,10 @@ Handle<WasmInstanceObject> WasmInstanceObject::New(
   instance->set_indirect_function_table_size(0);
   instance->set_indirect_function_table_refs(
       ReadOnlyRoots(isolate).empty_fixed_array());
-  instance->set_indirect_function_table_sig_ids(nullptr);
-  instance->set_indirect_function_table_targets(nullptr);
+  instance->set_indirect_function_table_sig_ids(
+      FixedUInt32Array::cast(ReadOnlyRoots(isolate).empty_byte_array()));
+  instance->set_indirect_function_table_targets(
+      FixedAddressArray::cast(ReadOnlyRoots(isolate).empty_byte_array()));
   instance->set_native_context(*isolate->native_context());
   instance->set_module_object(*module_object);
   instance->set_jump_table_start(
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index d7f29fde841..d110199eb32 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -342,6 +342,8 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   DECL_ACCESSORS(imported_mutable_globals, ByteArray)
   DECL_ACCESSORS(imported_function_targets, FixedAddressArray)
   DECL_OPTIONAL_ACCESSORS(indirect_function_table_refs, FixedArray)
+  DECL_ACCESSORS(indirect_function_table_sig_ids, FixedUInt32Array)
+  DECL_ACCESSORS(indirect_function_table_targets, FixedAddressArray)
   DECL_OPTIONAL_ACCESSORS(tags_table, FixedArray)
   DECL_ACCESSORS(wasm_internal_functions, FixedArray)
   DECL_ACCESSORS(managed_object_maps, FixedArray)
@@ -357,8 +359,6 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   DECL_PRIMITIVE_ACCESSORS(isorecursive_canonical_types, const uint32_t*)
   DECL_SANDBOXED_POINTER_ACCESSORS(globals_start, byte*)
   DECL_PRIMITIVE_ACCESSORS(indirect_function_table_size, uint32_t)
-  DECL_PRIMITIVE_ACCESSORS(indirect_function_table_sig_ids, uint32_t*)
-  DECL_PRIMITIVE_ACCESSORS(indirect_function_table_targets, Address*)
   DECL_PRIMITIVE_ACCESSORS(jump_table_start, Address)
   DECL_PRIMITIVE_ACCESSORS(hook_on_function_call_address, Address)
   DECL_PRIMITIVE_ACCESSORS(tiering_budget_array, uint32_t*)
@@ -381,6 +381,8 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   /* Less than system pointer sized fields come first. */                 \
   V(kImportedFunctionRefsOffset, kTaggedSize)                             \
   V(kIndirectFunctionTableRefsOffset, kTaggedSize)                        \
+  V(kIndirectFunctionTableSigIdsOffset, kTaggedSize)                      \
+  V(kIndirectFunctionTableTargetsOffset, kTaggedSize)                     \
   V(kImportedMutableGlobalsOffset, kTaggedSize)                           \
   V(kImportedFunctionTargetsOffset, kTaggedSize)                          \
   V(kIndirectFunctionTableSizeOffset, kUInt32Size)                        \
@@ -390,8 +392,6 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   V(kMemorySizeOffset, kSizetSize)                                        \
   V(kStackLimitAddressOffset, kSystemPointerSize)                         \
   V(kIsorecursiveCanonicalTypesOffset, kSystemPointerSize)                \
-  V(kIndirectFunctionTableTargetsOffset, kSystemPointerSize)              \
-  V(kIndirectFunctionTableSigIdsOffset, kSystemPointerSize)               \
   V(kGlobalsStartOffset, kSystemPointerSize)                              \
   V(kJumpTableStartOffset, kSystemPointerSize)                            \
   /* End of often-accessed fields. */                                     \
@@ -443,6 +443,8 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   static constexpr uint16_t kTaggedFieldOffsets[] = {
       kImportedFunctionRefsOffset,
       kIndirectFunctionTableRefsOffset,
+      kIndirectFunctionTableTargetsOffset,
+      kIndirectFunctionTableSigIdsOffset,
       kModuleObjectOffset,
       kExportsObjectOffset,
       kNativeContextOffset,
@@ -686,9 +688,11 @@ class WasmIndirectFunctionTable
     : public TorqueGeneratedWasmIndirectFunctionTable<WasmIndirectFunctionTable,
                                                       Struct> {
  public:
-  DECL_PRIMITIVE_ACCESSORS(sig_ids, uint32_t*)
-  DECL_PRIMITIVE_ACCESSORS(targets, Address*)
-  DECL_OPTIONAL_ACCESSORS(managed_native_allocations, Foreign)
+  // TODO(saelo): holding raw addresses isn't sandbox-compatible, so we should
+  // probably turn these into indices into some pointer table instead (or make
+  // this entire class a pointer table).
+  DECL_ACCESSORS(sig_ids, FixedUInt32Array)
+  DECL_ACCESSORS(targets, FixedAddressArray)
 
   V8_EXPORT_PRIVATE static Handle<WasmIndirectFunctionTable> New(
       Isolate* isolate, uint32_t size);
@@ -700,8 +704,9 @@ class WasmIndirectFunctionTable
 
   DECL_PRINTER(WasmIndirectFunctionTable)
 
-  static_assert(kStartOfStrongFieldsOffset == kManagedNativeAllocationsOffset);
-  using BodyDescriptor = FlexibleBodyDescriptor<kStartOfStrongFieldsOffset>;
+  using BodyDescriptor =
+      FixedBodyDescriptor<kStartOfStrongFieldsOffset, kEndOfStrongFieldsOffset,
+                          kHeaderSize>;
 
   TQ_OBJECT_CONSTRUCTORS(WasmIndirectFunctionTable)
 };
diff --git a/src/wasm/wasm-objects.tq b/src/wasm/wasm-objects.tq
index f54974d346c..5d2afe313d0 100644
--- a/src/wasm/wasm-objects.tq
+++ b/src/wasm/wasm-objects.tq
@@ -90,13 +90,12 @@ extern class WasmResumeData extends HeapObject {
 }
 
 extern class WasmIndirectFunctionTable extends Struct {
+  sig_ids: ByteArray;
+  targets: ByteArray;
+  refs: FixedArray;
   size: uint32;
   @if(TAGGED_SIZE_8_BYTES) optional_padding: uint32;
   @ifnot(TAGGED_SIZE_8_BYTES) optional_padding: void;
-  sig_ids: RawPtr;
-  targets: RawPtr;
-  managed_native_allocations: Foreign|Undefined;
-  refs: FixedArray;
 }
 
 extern class WasmContinuationObject extends HeapObject {
diff --git a/test/common/wasm/wasm-interpreter.cc b/test/common/wasm/wasm-interpreter.cc
index 085355c88f9..53ec1f1d7e9 100644
--- a/test/common/wasm/wasm-interpreter.cc
+++ b/test/common/wasm/wasm-interpreter.cc
@@ -4083,7 +4083,7 @@ class WasmInterpreterInternals {
     if (entry_index >= table->size()) return {CallResult::INVALID_FUNC};
 
     // Signature check.
-    if (table->sig_ids()[entry_index] != expected_sig_id) {
+    if (table->sig_ids().get(entry_index) != expected_sig_id) {
       return {CallResult::SIGNATURE_MISMATCH};
     }
 
@@ -4099,13 +4099,13 @@ class WasmInterpreterInternals {
     {
       WasmCodeRefScope code_ref_scope;
       WasmCode* wasm_code =
-          native_module->Lookup(table->targets()[entry_index]);
+          native_module->Lookup(table->targets().get(entry_index));
       DCHECK_EQ(native_module, wasm_code->native_module());
       DCHECK_EQ(WasmCode::kJumpTable, wasm_code->kind());
     }
 #endif
     uint32_t func_index = native_module->GetFunctionIndexFromJumpTableSlot(
-        table->targets()[entry_index]);
+        table->targets().get(entry_index));
 
     return {CallResult::INTERNAL, codemap_.GetCode(func_index)};
   }
