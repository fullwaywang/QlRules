commit 0d2f7d8d41ac2bc092cd21174236cfa4be96f0ae	0d2f7d8d41ac2bc092cd21174236cfa4be96f0ae
Author: Jack Hsieh <chengweih@chromium.org>
Date:   Fri Mar 3 00:35:32 2023 +0000

    Reject Web Serial requests with an opaque origin
    
    The Web Serial API tracks permissions using the origin of the top-level
    document in the frame tree. If this document has an opaque origin then
    there is no way to format the origin for display to the user in
    permission prompts or to write their decision in the preferences file.
    
    Access to the Web Serial API from such contexts should therefore be
    blocked.
    
    Bug: 1375133
    Change-Id: I4552ae74d480aa8df9ff93527fc85618bc03b947
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4112689
    Reviewed-by: Reilly Grant <reillyg@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1112561}

diff --git a/third_party/blink/renderer/modules/serial/serial.cc b/third_party/blink/renderer/modules/serial/serial.cc
index 380c34fa3df71..f61f91c756129 100644
--- a/third_party/blink/renderer/modules/serial/serial.cc
+++ b/third_party/blink/renderer/modules/serial/serial.cc
@@ -21,6 +21,7 @@
 #include "third_party/blink/renderer/core/execution_context/navigator_base.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
 #include "third_party/blink/renderer/core/frame/local_frame.h"
+#include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 #include "third_party/blink/renderer/modules/event_target_modules_names.h"
 #include "third_party/blink/renderer/modules/serial/serial_port.h"
 #include "third_party/blink/renderer/platform/heap/garbage_collected.h"
@@ -41,6 +42,48 @@ String TokenToString(const base::UnguessableToken& token) {
                         token.GetLowForSerialization());
 }
 
+// Carries out basic checks for the web-exposed APIs, to make sure the minimum
+// requirements for them to be served are met. Returns true if any conditions
+// fail to be met, generating an appropriate exception as well. Otherwise,
+// returns false to indicate the call should be allowed.
+bool ShouldBlockSerialServiceCall(LocalDOMWindow* window,
+                                  ExecutionContext* context,
+                                  ExceptionState& exception_state) {
+  if (!context) {
+    exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
+                                      kContextGone);
+    return true;
+  }
+
+  // Rejects if the top-level frame has an opaque origin.
+  const SecurityOrigin* security_origin = nullptr;
+  if (context->IsWindow()) {
+    security_origin =
+        window->GetFrame()->Top()->GetSecurityContext()->GetSecurityOrigin();
+  } else if (context->IsDedicatedWorkerGlobalScope()) {
+    security_origin = static_cast<WorkerGlobalScope*>(context)
+                          ->top_level_frame_security_origin();
+  } else {
+    NOTREACHED_NORETURN();
+  }
+
+  if (security_origin->IsOpaque()) {
+    exception_state.ThrowSecurityError(
+        "Access to the Web Serial API is denied from contexts where the "
+        "top-level document has an opaque origin.");
+    return true;
+  }
+
+  if (!context->IsFeatureEnabled(
+          mojom::blink::PermissionsPolicyFeature::kSerial,
+          ReportOptions::kReportOnFailure)) {
+    exception_state.ThrowSecurityError(kFeaturePolicyBlocked);
+    return true;
+  }
+
+  return false;
+}
+
 }  // namespace
 
 const char Serial::kSupplementName[] = "Serial";
@@ -85,17 +128,8 @@ void Serial::OnPortRemoved(mojom::blink::SerialPortInfoPtr port_info) {
 
 ScriptPromise Serial::getPorts(ScriptState* script_state,
                                ExceptionState& exception_state) {
-  auto* context = GetExecutionContext();
-  if (!context) {
-    exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
-    return ScriptPromise();
-  }
-
-  if (!context->IsFeatureEnabled(
-          mojom::blink::PermissionsPolicyFeature::kSerial,
-          ReportOptions::kReportOnFailure)) {
-    exception_state.ThrowSecurityError(kFeaturePolicyBlocked);
+  if (ShouldBlockSerialServiceCall(GetSupplementable()->DomWindow(),
+                                   GetExecutionContext(), exception_state)) {
     return ScriptPromise();
   }
 
@@ -112,16 +146,8 @@ ScriptPromise Serial::getPorts(ScriptState* script_state,
 ScriptPromise Serial::requestPort(ScriptState* script_state,
                                   const SerialPortRequestOptions* options,
                                   ExceptionState& exception_state) {
-  if (!DomWindow()) {
-    exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
-    return ScriptPromise();
-  }
-
-  if (!GetExecutionContext()->IsFeatureEnabled(
-          mojom::blink::PermissionsPolicyFeature::kSerial,
-          ReportOptions::kReportOnFailure)) {
-    exception_state.ThrowSecurityError(kFeaturePolicyBlocked);
+  if (ShouldBlockSerialServiceCall(GetSupplementable()->DomWindow(),
+                                   GetExecutionContext(), exception_state)) {
     return ScriptPromise();
   }
 
diff --git a/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html b/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html
new file mode 100644
index 0000000000000..b2f630a3197de
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script>
+  'use strict';
+
+  promise_test(async (t) => {
+    await promise_rejects_dom(
+        t, 'SecurityError', navigator.serial.getPorts(),
+        'getPorts() should throw a SecurityError DOMException when called ' +
+        'from a context where the top-level document has an opaque origin.');
+  }, 'Calls to Serial APIs from an origin with opaque top origin get blocked.');
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html.headers b/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html.headers
new file mode 100644
index 0000000000000..1efcf8c226fac
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/getPorts/reject_opaque_origin.https.html.headers
@@ -0,0 +1 @@
+Content-Security-Policy: sandbox allow-scripts
diff --git a/third_party/blink/web_tests/external/wpt/serial/getPorts/sandboxed_iframe.https.window.js b/third_party/blink/web_tests/external/wpt/serial/getPorts/sandboxed_iframe.https.window.js
new file mode 100644
index 0000000000000..8fae11ccfe53a
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/getPorts/sandboxed_iframe.https.window.js
@@ -0,0 +1,22 @@
+'use strict';
+
+let iframe = document.createElement('iframe');
+
+promise_test(async () => {
+  await new Promise(resolve => {
+    iframe.src = '../resources/open-in-iframe.html';
+    iframe.sandbox.add('allow-scripts');
+    iframe.allow = 'serial';
+    document.body.appendChild(iframe);
+    iframe.addEventListener('load', resolve);
+  });
+
+  await new Promise(resolve => {
+    iframe.contentWindow.postMessage({type: 'GetPorts'}, '*');
+
+    window.addEventListener('message', (messageEvent) => {
+      assert_equals('Success', messageEvent.data);
+      resolve();
+    });
+  });
+}, 'GetPorts from a sandboxed iframe is valid.');
diff --git a/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html b/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html
new file mode 100644
index 0000000000000..ade8ae7392ecc
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script>
+  'use strict';
+
+  promise_test(async (t) => {
+    await promise_rejects_dom(
+        t, 'SecurityError', navigator.serial.requestPort(),
+        'requestPort() should throw a SecurityError DOMException when called ' +
+        'from a context where the top-level document has an opaque origin.');
+  }, 'Calls to Serial APIs from an origin with opaque top origin get blocked.');
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html.headers b/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html.headers
new file mode 100644
index 0000000000000..1efcf8c226fac
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/requestPort/reject_opaque_origin.https.html.headers
@@ -0,0 +1 @@
+Content-Security-Policy: sandbox allow-scripts
diff --git a/third_party/blink/web_tests/external/wpt/serial/requestPort/sandboxed_iframe.https.window.js b/third_party/blink/web_tests/external/wpt/serial/requestPort/sandboxed_iframe.https.window.js
new file mode 100644
index 0000000000000..6e169510a0bd0
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/requestPort/sandboxed_iframe.https.window.js
@@ -0,0 +1,26 @@
+'use strict';
+
+let iframe = document.createElement('iframe');
+
+promise_test(async () => {
+  await new Promise(resolve => {
+    iframe.src = '../resources/open-in-iframe.html';
+    iframe.sandbox.add('allow-scripts');
+    iframe.allow = 'serial';
+    document.body.appendChild(iframe);
+    iframe.addEventListener('load', resolve);
+  });
+
+  await new Promise(resolve => {
+    iframe.contentWindow.postMessage({type: 'RequestPort'}, '*');
+
+    window.addEventListener('message', (messageEvent) => {
+      // The failure message of no device chosen is expected. The point here is
+      // to validate not failing because of a sandboxed iframe.
+      assert_equals(
+          'FAIL: NotFoundError: Failed to execute \'requestPort\' on \'Serial\': No port selected by the user.',
+          messageEvent.data);
+      resolve();
+    });
+  });
+}, 'RequestPort from a sandboxed iframe is valid.');
diff --git a/third_party/blink/web_tests/external/wpt/serial/resources/open-in-iframe.html b/third_party/blink/web_tests/external/wpt/serial/resources/open-in-iframe.html
new file mode 100644
index 0000000000000..9bf8beb66aa1c
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/serial/resources/open-in-iframe.html
@@ -0,0 +1,33 @@
+<!DOCTYPE html>
+
+<script src="/resources/testdriver.js"></script>
+<script src="/resources/testdriver-vendor.js"></script>
+
+<body>
+  <button>Fake user gesture</button>
+</body>
+
+<script>
+  'use strict';
+
+  test_driver.set_test_context(parent);
+
+  window.onmessage = messageEvent => {
+    switch (messageEvent.data.type) {
+      case 'GetPorts':
+        navigator.serial.getPorts()
+            .then(ports => parent.postMessage('Success', '*'))
+            .catch(err => parent.postMessage(`FAIL: ${err}`, '*'));
+        break;
+      case 'RequestPort':
+        test_driver.click(document.getElementsByTagName('button')[0])
+            .then(() => navigator.serial.requestPort({filters: []}))
+            .then(port => parent.postMessage('Success', '*'))
+            .catch(err => parent.postMessage(`FAIL: ${err}`, '*'));
+        break;
+      default:
+        parent.postMessage(
+            `FAIL: Bad message type: ${messageEvent.data}`, '*');
+    };
+  };
+</script>
