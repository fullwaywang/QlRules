commit 6e3fe13366e47d7baddbca167c5cdeb87eb063f3	6e3fe13366e47d7baddbca167c5cdeb87eb063f3
Author: Florian Jacky <fjacky@chromium.org>
Date:   Wed Dec 21 20:49:47 2022 +0000

    Reland "Enable input protection for window changes"
    
    This is a reland of commit b491e7324d790f854c8c80f17b21ddf8348a0a1f
    
    The original CL made the erroneous assumption that bubble widgets
    are always prompt bubble widgets. An undefined static cast of a
    bubble widget thus led to a failure on a UBSan builder.
    
    Original change's description:
    > Enable input protection for window changes
    >
    > Refer to issue description for more details
    >
    > Bug: 1160485
    > Change-Id: I4e92aac004c66821553280e1e81cc49a3d9c082b
    > Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4051581
    > Commit-Queue: Florian Jacky <fjacky@chromium.org>
    > Reviewed-by: Keren Zhu <kerenzhu@chromium.org>
    > Reviewed-by: Peter Kasting <pkasting@chromium.org>
    > Cr-Commit-Position: refs/heads/main@{#1085116}
    
    Bug: 1160485
    Change-Id: I3b023d3d994c1ffdd6b73fb7bda8179c9a842eb8
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4116798
    Auto-Submit: Florian Jacky <fjacky@chromium.org>
    Reviewed-by: Peter Kasting <pkasting@chromium.org>
    Reviewed-by: Keren Zhu <kerenzhu@chromium.org>
    Commit-Queue: Florian Jacky <fjacky@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1086065}

diff --git a/chrome/browser/ui/views/permissions/chip_controller.cc b/chrome/browser/ui/views/permissions/chip_controller.cc
index f2fcb5f909b84..7db7f4871dbae 100644
--- a/chrome/browser/ui/views/permissions/chip_controller.cc
+++ b/chrome/browser/ui/views/permissions/chip_controller.cc
@@ -167,9 +167,24 @@ void ChipController::OnWidgetDestroying(views::Widget* widget) {
   }
 
   widget->RemoveObserver(this);
+
   CollapsePrompt(/*allow_restart=*/false);
 }
 
+void ChipController::OnWidgetActivationChanged(views::Widget* widget,
+                                               bool active) {
+  // This logic prevents clickjacking. See https://crbug.com/1160485
+  auto* prompt_bubble_widget = GetBubbleWidget();
+  if (active && !parent_was_visible_when_activation_changed_) {
+    // If the widget is active and the primary window wasn't active the last
+    // time activation changed, we know that the window just came to the
+    // foreground and trigger input protection.
+    GetPromptBubbleView()->AsDialogDelegate()->TriggerInputProtection();
+  }
+  parent_was_visible_when_activation_changed_ =
+      prompt_bubble_widget->GetPrimaryWindowWidget()->IsVisible();
+}
+
 bool ChipController::ShouldWaitForConfirmationToComplete() {
   return is_confirmation_showing_ && collapse_timer_.IsRunning();
 }
@@ -487,7 +502,7 @@ void ChipController::OpenPermissionPromptBubble() {
   // It is possible that a Chip got reset while the permission prompt bubble was
   // displayed.
   if (permission_prompt_model_ && IsBubbleShowing()) {
-    GetBubbleWidget()->AddObserver(this);
+    ObservePromptBubble();
     permission_prompt_model_->GetDelegate().value()->SetPromptShown();
   }
 }
@@ -504,9 +519,11 @@ void ChipController::RecordRequestChipButtonPressed(const char* recordKey) {
 }
 
 void ChipController::ObservePromptBubble() {
-  views::Widget* promptBubbleWidget = GetBubbleWidget();
-  if (promptBubbleWidget) {
-    promptBubbleWidget->AddObserver(this);
+  views::Widget* prompt_bubble_widget = GetBubbleWidget();
+  if (prompt_bubble_widget) {
+    parent_was_visible_when_activation_changed_ =
+        prompt_bubble_widget->GetPrimaryWindowWidget()->IsVisible();
+    prompt_bubble_widget->AddObserver(this);
   }
 }
 
@@ -626,5 +643,16 @@ LocationBarView* ChipController::GetLocationBarView() {
 }
 
 views::Widget* ChipController::GetBubbleWidget() {
+  // We can't call GetPromptBubbleView() here, because the bubble_tracker may
+  // hold objects that aren't of typ `PermissionPromptBubbleView`.
   return bubble_tracker_.view() ? bubble_tracker_.view()->GetWidget() : nullptr;
 }
+
+PermissionPromptBubbleView* ChipController::GetPromptBubbleView() {
+  // The tracked bubble view is a `PermissionPromptBubbleView` only when `kChip`
+  // is used.
+  CHECK_EQ(permission_prompt_model_->GetPromptStyle(),
+           PermissionPromptStyle::kChip);
+  auto* view = bubble_tracker_.view();
+  return view ? static_cast<PermissionPromptBubbleView*>(view) : nullptr;
+}
diff --git a/chrome/browser/ui/views/permissions/chip_controller.h b/chrome/browser/ui/views/permissions/chip_controller.h
index 8ea34f4d34d1c..aff2667efb574 100644
--- a/chrome/browser/ui/views/permissions/chip_controller.h
+++ b/chrome/browser/ui/views/permissions/chip_controller.h
@@ -64,6 +64,7 @@ class ChipController : public permissions::PermissionRequestManager::Observer,
 
   // WidgetObserver:
   void OnWidgetDestroying(views::Widget* widget) override;
+  void OnWidgetActivationChanged(views::Widget* widget, bool active) override;
 
   // Initializes the permission prompt model as well as the permission request
   // manager and observes the prompt bubble.
@@ -95,6 +96,8 @@ class ChipController : public permissions::PermissionRequestManager::Observer,
 
   views::Widget* GetBubbleWidget();
 
+  PermissionPromptBubbleView* GetPromptBubbleView();
+
   bool should_expand_for_testing();
 
   bool is_collapse_timer_running_for_testing() {
@@ -206,6 +209,8 @@ class ChipController : public permissions::PermissionRequestManager::Observer,
   // displayed.
   base::OneShotTimer delay_prompt_timer_;
 
+  bool parent_was_visible_when_activation_changed_ = false;
+
   // The model of a permission prompt if one is present.
   std::unique_ptr<PermissionPromptChipModel> permission_prompt_model_;
 
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
index 611da80c32f04..7a94fbe1acb6f 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble.cc
@@ -40,6 +40,8 @@ void PermissionPromptBubble::ShowBubble() {
       PermissionPromptStyle::kBubbleOnly);
   prompt_bubble_->Show();
   prompt_bubble_->GetWidget()->AddObserver(this);
+  parent_was_visible_when_activation_changed_ =
+      prompt_bubble_->GetWidget()->GetPrimaryWindowWidget()->IsVisible();
 }
 
 void PermissionPromptBubble::CleanUpPromptBubble() {
@@ -56,6 +58,19 @@ void PermissionPromptBubble::OnWidgetDestroying(views::Widget* widget) {
   prompt_bubble_ = nullptr;
 }
 
+void PermissionPromptBubble::OnWidgetActivationChanged(views::Widget* widget,
+                                                       bool active) {
+  // This logic prevents clickjacking. See https://crbug.com/1160485
+  if (active && !parent_was_visible_when_activation_changed_) {
+    // If the widget is active and the primary window wasn't active the last
+    // time activation changed, we know that the window just came to the
+    // foreground and trigger input protection.
+    prompt_bubble_->AsDialogDelegate()->TriggerInputProtection();
+  }
+  parent_was_visible_when_activation_changed_ =
+      prompt_bubble_->GetWidget()->GetPrimaryWindowWidget()->IsVisible();
+}
+
 bool PermissionPromptBubble::UpdateAnchor() {
   bool was_browser_changed = UpdateBrowser();
   // TODO(crbug.com/1175231): Investigate why prompt_bubble_ can be null
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble.h b/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
index ba9cc05d4bab9..e6f656a7a0d0e 100644
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble.h
@@ -8,6 +8,7 @@
 #include "chip_controller.h"
 #include "chrome/browser/ui/views/permissions/permission_prompt_bubble_view.h"
 #include "chrome/browser/ui/views/permissions/permission_prompt_desktop.h"
+#include "content/public/browser/web_contents_observer.h"
 
 class Browser;
 
@@ -30,6 +31,7 @@ class PermissionPromptBubble : public PermissionPromptDesktop,
 
   // views::WidgetObserver:
   void OnWidgetDestroying(views::Widget* widget) override;
+  void OnWidgetActivationChanged(views::Widget* widget, bool active) override;
 
   // permissions::PermissionPrompt:
   bool UpdateAnchor() override;
@@ -45,6 +47,8 @@ class PermissionPromptBubble : public PermissionPromptDesktop,
 
   base::TimeTicks permission_requested_time_;
 
+  bool parent_was_visible_when_activation_changed_;
+
   base::WeakPtrFactory<PermissionPromptBubble> weak_factory_{this};
 };
 
diff --git a/ui/views/window/dialog_client_view.cc b/ui/views/window/dialog_client_view.cc
index 4f0c6a4618523..9092e5c409e14 100644
--- a/ui/views/window/dialog_client_view.cc
+++ b/ui/views/window/dialog_client_view.cc
@@ -245,6 +245,10 @@ void DialogClientView::ChildVisibilityChanged(View* child) {
   InvalidateLayout();
 }
 
+void DialogClientView::TriggerInputProtection() {
+  input_protector_.UpdateViewShownTimeStamp();
+}
+
 void DialogClientView::OnDialogChanged() {
   UpdateDialogButtons();
 }
diff --git a/ui/views/window/dialog_client_view.h b/ui/views/window/dialog_client_view.h
index f94b64bc1ce52..ac01e4e701cd7 100644
--- a/ui/views/window/dialog_client_view.h
+++ b/ui/views/window/dialog_client_view.h
@@ -57,6 +57,16 @@ class VIEWS_EXPORT DialogClientView : public ClientView, public DialogObserver {
   gfx::Size GetMaximumSize() const override;
   void VisibilityChanged(View* starting_from, bool is_visible) override;
 
+  // Input protection is triggered upon prompt creation and updated on
+  // visibility changes. Other situations such as top window changes in certain
+  // situations should trigger the input protection manually by calling this
+  // method. Input protection protects against certain kinds of clickjacking.
+  // Essentially it prevents clicks that happen within a user's double click
+  // interval from when the protection is started as well as any following
+  // clicks that happen in shorter succession than the user's double click
+  // interval. Refer to InputEventActivationProtector for more information.
+  void TriggerInputProtection();
+
   void Layout() override;
   bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
   void ViewHierarchyChanged(
diff --git a/ui/views/window/dialog_delegate.cc b/ui/views/window/dialog_delegate.cc
index 54cd17c85983d..de5517f4b063f 100644
--- a/ui/views/window/dialog_delegate.cc
+++ b/ui/views/window/dialog_delegate.cc
@@ -334,6 +334,10 @@ void DialogDelegate::DialogModelChanged() {
     observer.OnDialogChanged();
 }
 
+void DialogDelegate::TriggerInputProtection() {
+  GetDialogClientView()->TriggerInputProtection();
+}
+
 void DialogDelegate::SetDefaultButton(int button) {
   if (params_.default_button == button)
     return;
diff --git a/ui/views/window/dialog_delegate.h b/ui/views/window/dialog_delegate.h
index b0923fe17e355..4010df91b2c3a 100644
--- a/ui/views/window/dialog_delegate.h
+++ b/ui/views/window/dialog_delegate.h
@@ -206,6 +206,16 @@ class VIEWS_EXPORT DialogDelegate : public WidgetDelegate {
   // TODO(https://crbug.com/1011446): Make this private.
   void DialogModelChanged();
 
+  // Input protection is triggered upon prompt creation and updated on
+  // visibility changes. Other situations such as top window changes in certain
+  // situations should trigger the input protection manually by calling this
+  // method. Input protection protects against certain kinds of clickjacking.
+  // Essentially it prevents clicks that happen within a user's double click
+  // interval from when the protection is started as well as any following
+  // clicks that happen in shorter succession than the user's double click
+  // interval. Refer to InputEventActivationProtector for more information.
+  void TriggerInputProtection();
+
   void set_use_round_corners(bool round) { params_.round_corners = round; }
   void set_corner_radius(int corner_radius) {
     params_.corner_radius = corner_radius;
