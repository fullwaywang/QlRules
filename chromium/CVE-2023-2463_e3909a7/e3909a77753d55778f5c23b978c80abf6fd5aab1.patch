commit e3909a77753d55778f5c23b978c80abf6fd5aab1	e3909a77753d55778f5c23b978c80abf6fd5aab1
Author: Jinsuk Kim <jinsukkim@chromium.org>
Date:   Thu Mar 2 19:55:08 2023 +0000

    Fullscreen notification uses Android Toast
    
    This CL switches fullscreen notification from using a custom view back
    to using Android toast widget. The custom view-based implementation
    caused lots of conflict cases with other views within Chrome. With
    limit-rating capability/priority mechanism installed, Android toast
    can hopefully avoid them.
    
    The change is behind a feature flag android-widget-fullscreen-toast,
    and enabled by default.
    
    Bug: 1406120
    Change-Id: I20107ce9ad23df63fd185680022c06a792b9c6e1
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4263951
    Reviewed-by: Theresa Sullivan <twellington@chromium.org>
    Commit-Queue: Jinsuk Kim <jinsukkim@chromium.org>
    Code-Coverage: Findit <findit-for-me@appspot.gserviceaccount.com>
    Cr-Commit-Position: refs/heads/main@{#1112382}

diff --git a/chrome/android/chrome_java_sources.gni b/chrome/android/chrome_java_sources.gni
index 045bbb90a7055..6225e292cd62b 100644
--- a/chrome/android/chrome_java_sources.gni
+++ b/chrome/android/chrome_java_sources.gni
@@ -624,6 +624,7 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/fullscreen/BrowserControlsManager.java",
   "java/src/org/chromium/chrome/browser/fullscreen/BrowserControlsManagerSupplier.java",
   "java/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandler.java",
+  "java/src/org/chromium/chrome/browser/fullscreen/FullscreenToast.java",
   "java/src/org/chromium/chrome/browser/gcore/ChromeGoogleApiClient.java",
   "java/src/org/chromium/chrome/browser/gcore/ChromeGoogleApiClientImpl.java",
   "java/src/org/chromium/chrome/browser/gcore/ConnectedTask.java",
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandler.java b/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandler.java
index 8f4a7d57def11..12e86506e737a 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandler.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandler.java
@@ -11,15 +11,10 @@ import static android.view.View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
 import static android.view.View.SYSTEM_UI_FLAG_LOW_PROFILE;
 
 import android.app.Activity;
-import android.graphics.Rect;
 import android.os.Handler;
 import android.os.Message;
-import android.view.LayoutInflater;
 import android.view.View;
 import android.view.View.OnLayoutChangeListener;
-import android.view.ViewGroup;
-import android.view.ViewPropertyAnimator;
-import android.view.ViewTreeObserver.OnGlobalLayoutListener;
 import android.view.Window;
 import android.view.WindowManager;
 
@@ -36,9 +31,10 @@ import org.chromium.base.ObserverList;
 import org.chromium.base.supplier.ObservableSupplier;
 import org.chromium.base.supplier.ObservableSupplierImpl;
 import org.chromium.cc.input.BrowserControlsState;
-import org.chromium.chrome.R;
 import org.chromium.chrome.browser.ActivityTabProvider;
 import org.chromium.chrome.browser.ActivityTabProvider.ActivityTabTabObserver;
+import org.chromium.chrome.browser.flags.ChromeFeatureList;
+import org.chromium.chrome.browser.fullscreen.FullscreenToast.CustomViewToast;
 import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;
 import org.chromium.chrome.browser.tab.Tab;
 import org.chromium.chrome.browser.tab.TabAttributeKeys;
@@ -78,10 +74,6 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     // Delay to allow a frame to render between getting the fullscreen layout update and clearing
     // the SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN flag.
     private static final long CLEAR_LAYOUT_FULLSCREEN_DELAY_MS = 20;
-    // Fade in/out animation duration for fullscreen notification toast.
-    private static final int TOAST_FADE_MS = 500;
-    // Time that the notification toast remains on-screen before starting to fade out.
-    private static final int TOAST_SHOW_DURATION_MS = 5000;
 
     private final Activity mActivity;
     private final Handler mHandler;
@@ -102,34 +94,7 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     @Nullable
     private FullscreenOptions mFullscreenOptions;
 
-    // Toast at the top of the screen that is shown when user enters fullscreen for the
-    // first time.
-    //
-    // This is whether we believe that we need to show the user a notification toast.  It's false if
-    // we're not in full screen, or if we are in full screen but have already shown the toast for
-    // enough time for the user to read it.  The toast might or might not actually be on-screen
-    // right now; we remove it in some cases like when we lose window focus.  However, as long as
-    // we'll be in full screen, we still keep the toast pending until we successfully show it.
-    private boolean mIsNotificationToastPending;
-
-    // Sometimes, the toast must be removed temporarily, such as when we lose focus or if we
-    // transition to picture-in-picture.  In those cases, the toast is removed from the view
-    // hierarchy, and these fields are cleared.  The toast will be re-created from scratch when it's
-    // appropriate to show it again.  `mIsNotificationToastPending` won't be reset in those cases,
-    // though, since we'll still want to show the toast when it's possible to do so.
-    //
-    // If `mNotificationToast` exists, then it's attached to the view hierarchy, though it might be
-    // animating to or from alpha=0.  Any time the toast exists, we also have an animation for it,
-    // to allow us to fade it in, and eventually back out.  The animation is not cleared when it
-    // completes; it's only cleared when we also detach the toast and clear `mNotificationToast`.
-    //
-    // Importantly, it's possible that `mNotificationToast` is not null while no toast is pending.
-    // This can happen when the toast has been on-screen long enough, and is fading out.
-    private View mNotificationToast;
-    private ViewPropertyAnimator mToastFadeAnimation;
-
-    // Runnable that will complete the current toast and fade it out.
-    private final Runnable mFadeOutNotificationToastRunnable;
+    private FullscreenToast mToast;
 
     private OnLayoutChangeListener mFullscreenOnLayoutChangeListener;
 
@@ -144,26 +109,6 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     // in the current Tab.
     private ContentView mContentView;
 
-    private DimensionCompat mDimensionCompat;
-    private int mNavbarHeight;
-
-    // Monitors the window layout change while the fullscreen toast is on.
-    private OnGlobalLayoutListener mWindowLayoutListener = new OnGlobalLayoutListener() {
-        @Override
-        public void onGlobalLayout() {
-            if (mContentViewInFullscreen == null || mNotificationToast == null) return;
-            Rect bounds = new Rect();
-            mContentViewInFullscreen.getWindowVisibleDisplayFrame(bounds);
-            var lp = (ViewGroup.MarginLayoutParams) mNotificationToast.getLayoutParams();
-            int bottomMargin = mContentViewInFullscreen.getHeight() - bounds.height();
-            // If positioned at the bottom of the display, shift it up to avoid overlapping
-            // with the bottom nav bar when it appears by user gestures.
-            if (bottomMargin == 0) bottomMargin = mNavbarHeight;
-            lp.setMargins(0, 0, 0, bottomMargin);
-            mNotificationToast.requestLayout();
-        }
-    };
-
     // This static inner class holds a WeakReference to the outer object, to avoid triggering the
     // lint HandlerLeak warning.
     private static class FullscreenHandler extends Handler {
@@ -272,8 +217,6 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
         mPersistentModeSupplier = new ObservableSupplierImpl<>();
         mPersistentModeSupplier.set(false);
         mExitFullscreenOnStop = exitFullscreenOnStop;
-        mFadeOutNotificationToastRunnable = this::fadeOutNotificationToast;
-        mDimensionCompat = DimensionCompat.create(mActivity, () -> {});
     }
 
     /**
@@ -351,6 +294,20 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
         }
     }
 
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    private FullscreenToast getToast() {
+        if (mToast == null) {
+            if (ChromeFeatureList.isEnabled(ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST)) {
+                mToast = new FullscreenToast.AndroidToast(
+                        mActivity, this::getPersistentFullscreenMode);
+            } else {
+                mToast = new FullscreenToast.CustomViewToast(mActivity, mHandler,
+                        () -> mTab, () -> mContentViewInFullscreen, () -> mTabInFullscreen);
+            }
+        }
+        return mToast;
+    }
+
     @Override
     public void onEnterFullscreen(Tab tab, FullscreenOptions options) {
         if (shouldSkipEnterFullscreenRequest(options)) return;
@@ -468,7 +425,7 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     @Override
     public void exitPersistentFullscreenMode() {
         if (getPersistentFullscreenMode()) {
-            cancelNotificationToast();
+            getToast().onExitPersistentFullscreen();
             mPersistentModeSupplier.set(false);
 
             if (mWebContentsInFullscreen != null && mTabInFullscreen != null) {
@@ -504,7 +461,7 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     }
 
     private void exitFullscreen(WebContents webContents, View contentView, Tab tab) {
-        cancelNotificationToast();
+        getToast().onExitFullscreen();
         mHandler.removeMessages(MSG_ID_SET_FULLSCREEN_SYSTEM_UI_FLAGS);
         mHandler.removeMessages(MSG_ID_CLEAR_LAYOUT_FULLSCREEN_FLAG);
 
@@ -630,7 +587,7 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
                     return;
                 }
 
-                beginNotificationToast();
+                getToast().onFullscreenLayout();
                 contentView.removeOnLayoutChangeListener(this);
             }
         };
@@ -646,167 +603,7 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
         mWebContentsInFullscreen = webContents;
         mContentViewInFullscreen = contentView;
         mTabInFullscreen = tab;
-
-        // Cache the navigation bar height before entering fullscreen mode in which the dimension
-        // is zero.
-        mNavbarHeight = mDimensionCompat.getNavbarHeight();
-        mActivity.getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(
-                mWindowLayoutListener);
-    }
-
-    /**
-     * Whether we show a toast message when entering fullscreen.
-     */
-    private boolean shouldShowToast() {
-        // If there's no notification toast pending, such as when we're not in full screen or after
-        // we've already displayed it for longe enough, then we don't need to show the toast now.
-        if (!mIsNotificationToastPending) return false;
-
-        if (mTabInFullscreen == null) return false;
-
-        if (mTab == null) return false;
-
-        final ViewGroup parent = mTab.getContentView();
-        if (parent == null) return false;
-
-        // The window must have the focus, so that it is not obscured while the notification is
-        // showing.  This also covers the case of picture in picture video, but any case of an
-        // unfocused window should prevent the toast.
-        if (!parent.hasWindowFocus()) return false;
-
-        return true;
-    }
-
-    /**
-     * Create and show the fullscreen notification toast, if it's not already visible and if it
-     * should be visible.  It's okay to call this when it should not be; we'll do nothing.  This
-     * will fade the toast in if needed.  It will also schedule a timer to fade it back out, if it's
-     * not hidden or cancelled before then.
-     */
-    private void createAndShowNotificationToast() {
-        // If it's already visible, then that's fine.  That includes if it's currently fading out;
-        // that's part of it.
-        if (mNotificationToast != null) return;
-
-        // If the toast should not be visible, then do nothing.
-        if (!shouldShowToast()) return;
-
-        assert mTab != null && mTab.getContentView() != null;
-
-        // Create a new toast and fade it in, or re-use one we've created before.
-        mNotificationToast = mActivity.getWindow().findViewById(R.id.fullscreen_notification);
-        boolean addView = false;
-        if (mNotificationToast == null) {
-            mNotificationToast =
-                    LayoutInflater.from(mActivity).inflate(R.layout.fullscreen_notification, null);
-            addView = true;
-        }
-        mNotificationToast.setAlpha(0);
-        mToastFadeAnimation = mNotificationToast.animate();
-        if (addView) {
-            mActivity.addContentView(mNotificationToast,
-                    new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-                            ViewGroup.LayoutParams.MATCH_PARENT));
-            // Ensure the toast is visible on bottom sheet CCT which is elevated for shadow effect.
-            // Does no harm on other embedders.
-            mNotificationToast.setElevation(mActivity.getResources().getDimensionPixelSize(
-                    R.dimen.fullscreen_toast_elevation));
-        } else {
-            mNotificationToast.setVisibility(View.VISIBLE);
-        }
-
-        mToastFadeAnimation.alpha(1).setDuration(TOAST_FADE_MS).start();
-        mHandler.postDelayed(mFadeOutNotificationToastRunnable, TOAST_SHOW_DURATION_MS);
-    }
-
-    /**
-     * Pause the notification toast, which hides it and stops all the timers.  It's okay if there is
-     * not currently a toast; we don't change any state in that case.  This will abruptly hide the
-     * toast, rather than fade it out.  This does not change `mIsNotificationToastPending`; the
-     * toast hasn't been shown long enough.
-     */
-    private void hideImmediatelyNotificationToast() {
-        if (mNotificationToast == null) return;
-
-        // Stop the fade-out timer.
-        mHandler.removeCallbacks(mFadeOutNotificationToastRunnable);
-
-        // Remove it immediately, without fading out.
-        assert mToastFadeAnimation != null;
-        mToastFadeAnimation.cancel();
-        mToastFadeAnimation = null;
-
-        mActivity.getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(
-                mWindowLayoutListener);
-
-        // We can't actually remove it, so this will do.
-        mNotificationToast.setVisibility(View.GONE);
-        mNotificationToast = null;
-    }
-
-    /**
-     * Begin a new instance of the notification toast.  If the toast should not be shown right now,
-     * we'll start showing it when we can.
-     */
-    private void beginNotificationToast() {
-        // It would be nice if we could determine that we're not starting a new toast while a
-        // previous one is fading out.  We can't ask the animation for its current target value.  We
-        // could almost check that there's not a notification pending and also that there's no
-        // current toast.  When a notification is pending, the previous toast hasn't completed yet,
-        // so nobody should be starting a new one.  When `mNotificationToast` is not null, but
-        // pending is false, then the fade-out animation has started but not completed.  Only when
-        // they're both false is it in the steady-state of "no notification" that would let us start
-        // a new one.
-        //
-        // The problem with that is that there are cases when we double-enter fullscreen.  In
-        // particular, changing the visibility of the navigation bar and/or status bar can cause us
-        // to think that we're entering fullscreen without an intervening exit.  In this case, the
-        // right thing to do is to continue with the toast from the previous full screen, if it's
-        // still on-screen.  If it's fading out now, just let it continue to fade out.  The user has
-        // already seen it for the full duration, and we've not actually exited fullscreen.
-        if (mNotificationToast != null) {
-            // Don't reset the pending flag here -- either it's on the screen or fading out, and
-            // either way is correct.  We have not actually exited fullscreen, so we shouldn't
-            // re-display the notification.
-            return;
-        }
-
-        mIsNotificationToastPending = true;
-        createAndShowNotificationToast();
-    }
-
-    /**
-     * Cancel a toast immediately, without fading out.  For example, if we leave fullscreen, then
-     * the toast isn't needed anymore.
-     */
-    private void cancelNotificationToast() {
-        hideImmediatelyNotificationToast();
-        // Don't restart it either.
-        mIsNotificationToastPending = false;
-    }
-
-    /**
-     * Called when the notification toast should not be shown any more, because it's been on-screen
-     * long enough for the user to read it.  To re-show it, one must call `beginNotificationToast()`
-     * again.  Show / hide of the toast will no-op until then.
-     */
-    private void fadeOutNotificationToast() {
-        if (mNotificationToast == null) return;
-
-        // Clear this first, so that we know that the toast timer has expired already.
-        mIsNotificationToastPending = false;
-
-        // Cancel any timer that will start the fade-out animation, in case it's running.  It might
-        // not be, especially if we're called by it.
-        mHandler.removeCallbacks(mFadeOutNotificationToastRunnable);
-
-        // Start the fade-out animation.
-        assert mToastFadeAnimation != null;
-        mToastFadeAnimation.cancel();
-        mToastFadeAnimation.alpha(0)
-                .setDuration(TOAST_FADE_MS)
-                .withEndAction(this::hideImmediatelyNotificationToast)
-                .start();
+        getToast().onEnterFullscreen();
     }
 
     // ActivityStateListener
@@ -839,20 +636,9 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
     public void onWindowFocusChanged(Activity activity, boolean hasWindowFocus) {
         if (mActivity != activity) return;
 
-        // Try to show / hide the toast, if we need to.  Note that these won't do anything if the
-        // toast should not be visible, such as if we re-gain the window focus after having
-        // completed the most recently started notification toast.
-        //
-        // Also note that this handles picture-in-picture.  We definitely do not want the toast to
-        // be visible then; it's not relevant and also takes up almost all of the window.  We could
-        // also do this on ActivityStateChanged => PAUSED if Activity.isInPictureInPictureMode(),
-        // but it doesn't seem to be needed.
-        if (hasWindowFocus) {
-            createAndShowNotificationToast();
-        } else {
-            // While we don't have the focus, hide any ongoing notification.
-            hideImmediatelyNotificationToast();
-        }
+        // Window focus events can occur before the fullscreen toast is ready. It may skip and
+        // wait till fullscreen is entered, by which time the toast object will be ready.
+        if (mToast != null) mToast.onWindowFocusChanged(hasWindowFocus);
 
         mHandler.removeMessages(MSG_ID_SET_FULLSCREEN_SYSTEM_UI_FLAGS);
         mHandler.removeMessages(MSG_ID_CLEAR_LAYOUT_FULLSCREEN_FLAG);
@@ -948,24 +734,23 @@ public class FullscreenHtmlApiHandler implements ActivityStateListener, WindowFo
         return mObservers;
     }
 
+    FullscreenOptions getPendingFullscreenOptionsForTesting() {
+        return mPendingFullscreenOptions;
+    }
+
     boolean isToastVisibleForTesting() {
-        return mNotificationToast != null;
+        return getToast().isVisible();
     }
 
     int getToastBottomMarginForTesting() {
-        var lp = (ViewGroup.MarginLayoutParams) mNotificationToast.getLayoutParams();
-        return lp.bottomMargin;
+        return ((CustomViewToast) getToast()).getToastBottomMarginForTesting();
     }
 
     void setVersionCompatForTesting(DimensionCompat compat) {
-        mDimensionCompat = compat;
-    }
-
-    FullscreenOptions getPendingFullscreenOptionsForTesting() {
-        return mPendingFullscreenOptions;
+        ((CustomViewToast) getToast()).setDimensionCompatForTesting(compat);
     }
 
     void triggerWindowLayoutChangeForTesting() {
-        mWindowLayoutListener.onGlobalLayout();
+        ((CustomViewToast) getToast()).triggerWindowLayoutForTesting();
     }
 }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenToast.java b/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenToast.java
new file mode 100644
index 0000000000000..4574f348f37f7
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/fullscreen/FullscreenToast.java
@@ -0,0 +1,411 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.fullscreen;
+
+import android.app.Activity;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewPropertyAnimator;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+
+import org.chromium.base.supplier.Supplier;
+import org.chromium.chrome.R;
+import org.chromium.chrome.browser.tab.Tab;
+import org.chromium.components.browser_ui.util.DimensionCompat;
+import org.chromium.ui.widget.Toast;
+import org.chromium.ui.widget.Toast.ToastPriority;
+
+import java.util.function.BooleanSupplier;
+
+/**
+ * Interface for fullscreen notification toast that allows experimenting different
+ * implementations, based on Android Toast widget and a custom view.
+ */
+interface FullscreenToast {
+    // Fullscreen is entered. System UI starts being hidden. Actual fullscreen layout is
+    // completed at |onFullscreenLayout|.
+    void onEnterFullscreen();
+
+    // Fullscreen layout is completed after system UI is hidden.
+    void onFullscreenLayout();
+
+    // Browser controls start being restored as a part of fullscreen exit process.
+    void onExitPersistentFullscreen();
+
+    // Fullscreen is exited.
+    void onExitFullscreen();
+
+    // Window focus is either gained or lost.
+    void onWindowFocusChanged(boolean hasWindowFocus);
+
+    // Whether the toast is currently visible. Test only.
+    boolean isVisible();
+
+    // Android widget-based fullscreen toast.
+    static class AndroidToast implements FullscreenToast {
+        private final Activity mActivity;
+        private final BooleanSupplier mIsPersistentFullscreenMode;
+
+        private Toast mNotificationToast;
+
+        AndroidToast(Activity activity, BooleanSupplier isPersistentFullscreenMode) {
+            mActivity = activity;
+            mIsPersistentFullscreenMode = isPersistentFullscreenMode;
+        }
+
+        @Override
+        public void onExitPersistentFullscreen() {
+            // We do not want to hide the notification toast here. Doing it in |exitFullscreen()| is
+            // sufficient.
+        }
+
+        @Override
+        public void onEnterFullscreen() {}
+
+        @Override
+        public void onFullscreenLayout() {
+            showNotificationToast();
+        }
+
+        @Override
+        public void onExitFullscreen() {
+            hideNotificationToast();
+        }
+
+        @Override
+        public void onWindowFocusChanged(boolean hasWindowFocus) {
+            if (hasWindowFocus && mIsPersistentFullscreenMode.getAsBoolean()) {
+                showNotificationToast();
+            } else {
+                hideNotificationToast();
+            }
+        }
+
+        @Override
+        public boolean isVisible() {
+            return mNotificationToast != null;
+        }
+
+        private void showNotificationToast() {
+            hideNotificationToast();
+
+            int resId = R.string.immersive_fullscreen_api_notification;
+            mNotificationToast = Toast.makeTextWithPriority(
+                    mActivity, resId, Toast.LENGTH_LONG, ToastPriority.HIGH);
+            mNotificationToast.setGravity(Gravity.BOTTOM | Gravity.CENTER, 0, 0);
+            mNotificationToast.show();
+        }
+
+        private void hideNotificationToast() {
+            if (mNotificationToast != null) {
+                mNotificationToast.cancel();
+                mNotificationToast = null;
+            }
+        }
+    }
+
+    // Custom view-based fullscreen toast.
+    class CustomViewToast implements FullscreenToast {
+        // Fade in/out animation duration for fullscreen notification toast.
+        private static final int TOAST_FADE_MS = 500;
+
+        // Time that the notification toast remains on-screen before starting to fade out.
+        private static final int TOAST_SHOW_DURATION_MS = 5000;
+
+        private final Activity mActivity;
+        private final Handler mHandler;
+        private final Supplier<Tab> mTab;
+        private final Supplier<Tab> mTabInFullscreen;
+        private final Supplier<View> mContentViewInFullscreen;
+
+        // Runnable that will complete the current toast and fade it out.
+        private final Runnable mFadeOutNotificationToastRunnable;
+
+        // Toast at the top of the screen that is shown when user enters fullscreen for the
+        // first time.
+        //
+        // This is whether we believe that we need to show the user a notification toast.  It's
+        // false if we're not in full screen, or if we are in full screen but have already shown the
+        // toast for enough time for the user to read it.  The toast might or might not actually be
+        // on-screen right now; we remove it in some cases like when we lose window focus.  However,
+        // as long as we'll be in full screen, we still keep the toast pending until we successfully
+        // show it.
+        private boolean mIsNotificationToastPending;
+
+        // Sometimes, the toast must be removed temporarily, such as when we lose focus or if we
+        // transition to picture-in-picture.  In those cases, the toast is removed from the view
+        // hierarchy, and these fields are cleared.  The toast will be re-created from scratch when
+        // it's appropriate to show it again.  `mIsNotificationToastPending` won't be reset in those
+        // cases, though, since we'll still want to show the toast when it's possible to do so.
+        //
+        // If `mNotificationToast` exists, then it's attached to the view hierarchy, though it might
+        // be animating to or from alpha=0.  Any time the toast exists, we also have an animation
+        // for it, to allow us to fade it in, and eventually back out.  The animation is not cleared
+        // when it completes; it's only cleared when we also detach the toast and clear
+        // `mNotificationToast`.
+        //
+        // Importantly, it's possible that `mNotificationToast` is not null while no toast is
+        // pending. This can happen when the toast has been on-screen long enough, and is fading
+        // out.
+        private View mNotificationToast;
+        private ViewPropertyAnimator mToastFadeAnimation;
+
+        private DimensionCompat mDimensionCompat;
+        private int mNavbarHeight;
+
+        // Monitors the window layout change while the fullscreen toast is on.
+        private OnGlobalLayoutListener mWindowLayoutListener = new OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (mContentViewInFullscreen.get() == null || mNotificationToast == null) return;
+                Rect bounds = new Rect();
+                mContentViewInFullscreen.get().getWindowVisibleDisplayFrame(bounds);
+                var lp = (ViewGroup.MarginLayoutParams) mNotificationToast.getLayoutParams();
+                int bottomMargin = mContentViewInFullscreen.get().getHeight() - bounds.height();
+                // If positioned at the bottom of the display, shift it up to avoid overlapping
+                // with the bottom nav bar when it appears by user gestures.
+                if (bottomMargin == 0) bottomMargin = mNavbarHeight;
+                lp.setMargins(0, 0, 0, bottomMargin);
+                mNotificationToast.requestLayout();
+            }
+        };
+
+        CustomViewToast(Activity activity, Handler handler, Supplier<Tab> tab,
+                Supplier<View> contentViewInFullscreen, Supplier<Tab> tabInFullscreen) {
+            mActivity = activity;
+            mHandler = handler;
+            mTab = tab;
+            mContentViewInFullscreen = contentViewInFullscreen;
+            mTabInFullscreen = tabInFullscreen;
+            mFadeOutNotificationToastRunnable = this::fadeOutNotificationToast;
+            mDimensionCompat = DimensionCompat.create(mActivity, () -> {});
+        }
+
+        @Override
+        public void onEnterFullscreen() {
+            // Cache the navigation bar height before entering fullscreen mode in which
+            // the dimension is zero.
+            mNavbarHeight = mDimensionCompat.getNavbarHeight();
+            mActivity.getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(
+                    mWindowLayoutListener);
+        }
+
+        @Override
+        public void onFullscreenLayout() {
+            beginNotificationToast();
+        }
+
+        @Override
+        public void onExitPersistentFullscreen() {
+            cancelNotificationToast();
+        }
+
+        @Override
+        public void onExitFullscreen() {
+            cancelNotificationToast();
+        }
+
+        /**
+         * Whether we show a toast message when entering fullscreen.
+         */
+        private boolean shouldShowToast() {
+            // If there's no notification toast pending, such as when we're not in full screen or
+            // after we've already displayed it for longe enough, then we don't need to show the
+            // toast now.
+            if (!mIsNotificationToastPending) return false;
+
+            if (mTabInFullscreen.get() == null) return false;
+
+            if (mTab.get() == null) return false;
+
+            final ViewGroup parent = mTab.get().getContentView();
+            if (parent == null) return false;
+
+            // The window must have the focus, so that it is not obscured while the notification is
+            // showing.  This also covers the case of picture in picture video, but any case of an
+            // unfocused window should prevent the toast.
+            if (!parent.hasWindowFocus()) return false;
+
+            return true;
+        }
+
+        /**
+         * Create and show the fullscreen notification toast, if it's not already visible and if it
+         * should be visible.  It's okay to call this when it should not be; we'll do nothing.  This
+         * will fade the toast in if needed.  It will also schedule a timer to fade it back out, if
+         * it's not hidden or cancelled before then.
+         */
+        private void createAndShowNotificationToast() {
+            // If it's already visible, then that's fine.  That includes if it's currently fading
+            // out; that's part of it.
+            if (mNotificationToast != null) return;
+
+            // If the toast should not be visible, then do nothing.
+            if (!shouldShowToast()) return;
+
+            assert mTab.get() != null && mTab.get().getContentView() != null;
+
+            // Create a new toast and fade it in, or re-use one we've created before.
+            mNotificationToast = mActivity.getWindow().findViewById(R.id.fullscreen_notification);
+            boolean addView = false;
+            if (mNotificationToast == null) {
+                mNotificationToast = LayoutInflater.from(mActivity).inflate(
+                        R.layout.fullscreen_notification, null);
+                addView = true;
+            }
+            mNotificationToast.setAlpha(0);
+            mToastFadeAnimation = mNotificationToast.animate();
+            if (addView) {
+                mActivity.addContentView(mNotificationToast,
+                        new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                                ViewGroup.LayoutParams.MATCH_PARENT));
+                // Ensure the toast is visible on bottom sheet CCT which is elevated for shadow
+                // effect. Does no harm on other embedders.
+                mNotificationToast.setElevation(mActivity.getResources().getDimensionPixelSize(
+                        R.dimen.fullscreen_toast_elevation));
+            } else {
+                mNotificationToast.setVisibility(View.VISIBLE);
+            }
+
+            mToastFadeAnimation.alpha(1).setDuration(TOAST_FADE_MS).start();
+            mHandler.postDelayed(mFadeOutNotificationToastRunnable, TOAST_SHOW_DURATION_MS);
+        }
+
+        /**
+         * Pause the notification toast, which hides it and stops all the timers.  It's okay if
+         * there is not currently a toast; we don't change any state in that case.  This will
+         * abruptly hide the toast, rather than fade it out.  This does not change
+         * `mIsNotificationToastPending`; the toast hasn't been shown long enough.
+         */
+        private void hideImmediatelyNotificationToast() {
+            if (mNotificationToast == null) return;
+
+            // Stop the fade-out timer.
+            mHandler.removeCallbacks(mFadeOutNotificationToastRunnable);
+
+            // Remove it immediately, without fading out.
+            assert mToastFadeAnimation != null;
+            mToastFadeAnimation.cancel();
+            mToastFadeAnimation = null;
+
+            mActivity.getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(
+                    mWindowLayoutListener);
+
+            // We can't actually remove it, so this will do.
+            mNotificationToast.setVisibility(View.GONE);
+            mNotificationToast = null;
+        }
+
+        /**
+         * Begin a new instance of the notification toast.  If the toast should not be shown right
+         * now, we'll start showing it when we can.
+         */
+        private void beginNotificationToast() {
+            // It would be nice if we could determine that we're not starting a new toast while a
+            // previous one is fading out.  We can't ask the animation for its current target value.
+            // We could almost check that there's not a notification pending and also that there's
+            // no current toast.  When a notification is pending, the previous toast hasn't
+            // completed yet, so nobody should be starting a new one.  When `mNotificationToast` is
+            // not null, but pending is false, then the fade-out animation has started but not
+            // completed.  Only when they're both false is it in the steady-state of "no
+            // notification" that would let us start a new one.
+            //
+            // The problem with that is that there are cases when we double-enter fullscreen.  In
+            // particular, changing the visibility of the navigation bar and/or status bar can cause
+            // us to think that we're entering fullscreen without an intervening exit.  In this
+            // case, the right thing to do is to continue with the toast from the previous full
+            // screen, if it's still on-screen.  If it's fading out now, just let it continue to
+            // fade out.  The user has already seen it for the full duration, and we've not actually
+            // exited fullscreen.
+            if (mNotificationToast != null) {
+                // Don't reset the pending flag here -- either it's on the screen or fading out, and
+                // either way is correct.  We have not actually exited fullscreen, so we shouldn't
+                // re-display the notification.
+                return;
+            }
+
+            mIsNotificationToastPending = true;
+            createAndShowNotificationToast();
+        }
+
+        /**
+         * Cancel a toast immediately, without fading out.  For example, if we leave fullscreen,
+         * then the toast isn't needed anymore.
+         */
+        private void cancelNotificationToast() {
+            hideImmediatelyNotificationToast();
+            // Don't restart it either.
+            mIsNotificationToastPending = false;
+        }
+
+        /**
+         * Called when the notification toast should not be shown any more, because it's been
+         * on-screen long enough for the user to read it.  To re-show it, one must call
+         * `beginNotificationToast()` again.  Show / hide of the toast will no-op until then.
+         */
+        private void fadeOutNotificationToast() {
+            if (mNotificationToast == null) return;
+
+            // Clear this first, so that we know that the toast timer has expired already.
+            mIsNotificationToastPending = false;
+
+            // Cancel any timer that will start the fade-out animation, in case it's running.  It
+            // might not be, especially if we're called by it.
+            mHandler.removeCallbacks(mFadeOutNotificationToastRunnable);
+
+            // Start the fade-out animation.
+            assert mToastFadeAnimation != null;
+            mToastFadeAnimation.cancel();
+            mToastFadeAnimation.alpha(0)
+                    .setDuration(TOAST_FADE_MS)
+                    .withEndAction(this::hideImmediatelyNotificationToast)
+                    .start();
+        }
+
+        @Override
+        public void onWindowFocusChanged(boolean hasWindowFocus) {
+            // Try to show / hide the toast, if we need to.  Note that these won't do anything if
+            // the toast should not be visible, such as if we re-gain the window focus after having
+            // completed the most recently started notification toast.
+            //
+            // Also note that this handles picture-in-picture.  We definitely do not want the toast
+            // to be visible then; it's not relevant and also takes up almost all of the window.  We
+            // could also do this on ActivityStateChanged => PAUSED if
+            // Activity.isInPictureInPictureMode(), but it doesn't seem to be needed.
+            if (hasWindowFocus) {
+                createAndShowNotificationToast();
+            } else {
+                // While we don't have the focus, hide any ongoing notification.
+                hideImmediatelyNotificationToast();
+            }
+        }
+
+        @Override
+        public boolean isVisible() {
+            return mNotificationToast != null;
+        }
+
+        boolean isVisibleForTesting() {
+            return mNotificationToast != null;
+        }
+
+        int getToastBottomMarginForTesting() {
+            var lp = (ViewGroup.MarginLayoutParams) mNotificationToast.getLayoutParams();
+            return lp.bottomMargin;
+        }
+
+        void setDimensionCompatForTesting(DimensionCompat compat) {
+            mDimensionCompat = compat;
+        }
+
+        void triggerWindowLayoutForTesting() {
+            mWindowLayoutListener.onGlobalLayout();
+        }
+    }
+}
diff --git a/chrome/android/junit/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandlerUnitTest.java b/chrome/android/junit/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandlerUnitTest.java
index 90230cc433d8a..969ed423d411e 100644
--- a/chrome/android/junit/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandlerUnitTest.java
+++ b/chrome/android/junit/src/org/chromium/chrome/browser/fullscreen/FullscreenHtmlApiHandlerUnitTest.java
@@ -35,11 +35,14 @@ import org.chromium.base.supplier.ObservableSupplierImpl;
 import org.chromium.base.test.BaseRobolectricTestRunner;
 import org.chromium.cc.input.BrowserControlsState;
 import org.chromium.chrome.browser.ActivityTabProvider;
+import org.chromium.chrome.browser.flags.ChromeFeatureList;
 import org.chromium.chrome.browser.tab.Tab;
 import org.chromium.chrome.browser.tab.TabAttributes;
 import org.chromium.chrome.browser.tab.TabBrowserControlsConstraintsHelper;
 import org.chromium.chrome.browser.tabmodel.TabModelSelector;
 import org.chromium.chrome.test.util.browser.Features;
+import org.chromium.chrome.test.util.browser.Features.DisableFeatures;
+import org.chromium.chrome.test.util.browser.Features.EnableFeatures;
 import org.chromium.components.browser_ui.util.DimensionCompat;
 import org.chromium.components.embedder_support.view.ContentView;
 import org.chromium.content_public.browser.WebContents;
@@ -48,6 +51,7 @@ import org.chromium.content_public.browser.WebContents;
  * Unit tests for {@link FullscreenHtmlApiHandler}.
  */
 @RunWith(BaseRobolectricTestRunner.class)
+@EnableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
 public class FullscreenHtmlApiHandlerUnitTest {
     private static final int DEVICE_WIDTH = 900;
     private static final int DEVICE_HEIGHT = 1600;
@@ -254,7 +258,18 @@ public class FullscreenHtmlApiHandlerUnitTest {
     }
 
     @Test
-    public void testToastIsShownInFullscreenButNotPictureInPicture() {
+    @EnableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
+    public void testToastIsShownInFullscreenButNotPictureInPicture_AndroidWidgetToast() {
+        testToastIsShownInFullscreenButNotPictureInPicture();
+    }
+
+    @Test
+    @DisableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
+    public void testToastIsShownInFullscreenButNotPictureInPicture_CustomViewToast() {
+        testToastIsShownInFullscreenButNotPictureInPicture();
+    }
+
+    private void testToastIsShownInFullscreenButNotPictureInPicture() {
         doReturn(mWebContents).when(mTab).getWebContents();
         doReturn(mContentView).when(mTab).getContentView();
         doReturn(true).when(mTab).isUserInteractable();
@@ -306,7 +321,18 @@ public class FullscreenHtmlApiHandlerUnitTest {
     }
 
     @Test
-    public void testToastIsShownAtLayoutChangeWithRotation() {
+    @EnableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
+    public void testToastIsShownAtLayoutChangeWithRotation_AndroidWidgetToast() {
+        testToastIsShownAtLayoutChangeWithRotation();
+    }
+
+    @Test
+    @DisableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
+    public void testToastIsShownAtLayoutChangeWithRotation_CustomViewToast() {
+        testToastIsShownAtLayoutChangeWithRotation();
+    }
+
+    private void testToastIsShownAtLayoutChangeWithRotation() {
         doReturn(mWebContents).when(mTab).getWebContents();
         doReturn(mContentView).when(mTab).getContentView();
         doReturn(true).when(mTab).isUserInteractable();
@@ -333,6 +359,7 @@ public class FullscreenHtmlApiHandlerUnitTest {
     }
 
     @Test
+    @DisableFeatures({ChromeFeatureList.ANDROID_WIDGET_FULLSCREEN_TOAST})
     public void testToastRepositionsUponWindowLayoutChange() {
         doReturn(mWebContents).when(mTab).getWebContents();
         doReturn(mContentView).when(mTab).getContentView();
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 1d562e5ce0337..bc451ba04feb0 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -6891,6 +6891,10 @@ const FeatureEntry kFeatureEntries[] = {
     {"use-toast-manager", flag_descriptions::kUseToastManagerName,
      flag_descriptions::kUseToastManagerDescription, kOsAndroid,
      FEATURE_VALUE_TYPE(::features::kUseToastManager)},
+    {"android-widget-fullscreen-toast",
+     flag_descriptions::kAndroidWidgetFullscreenToastName,
+     flag_descriptions::kAndroidWidgetFullscreenToastDescription, kOsAndroid,
+     FEATURE_VALUE_TYPE(chrome::android::kAndroidWidgetFullscreenToast)},
 #endif  // BUILDFLAG(IS_ANDROID)
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index c2361797d7ad6..23a464286b3db 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -156,6 +156,11 @@
     "owners": [ "finnur@google.com", "beverloo@google.com" ],
     "expiry_milestone": 140
   },
+  {
+    "name": "android-widget-fullscreen-toast",
+    "owners": [ "jinsukkim", "twellington" ],
+    "expiry_milestone": 118
+  },
   {
     "name": "animated-image-drag-shadow",
     "owners": [ "shuyng@google.com", "wenyufu", "clank-app-team@google.com" ],
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index fa307d218f930..74cbbf9af808d 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -3474,6 +3474,11 @@ const char kAndroidSurfaceControlDescription[] =
     " DisplayCompositor on Android. This feature is only available on "
     " android Q+ devices";
 
+const char kAndroidWidgetFullscreenToastName[] =
+    "Android widget fullscreen toast";
+const char kAndroidWidgetFullscreenToastDescription[] =
+    "Use Android Toast widget for fullscreen notifcation UI.";
+
 const char kAndroidImprovedBookmarksName[] = "Android Visual Bookmark Manager";
 const char kAndroidImprovedBookmarksDescription[] =
     "More visual changes to the bookmarks surfaces, with more thumbnails and a "
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 05a26ec551b2f..8665835b3f67b 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1999,6 +1999,9 @@ extern const char kAndroidMediaPickerSupportDescription[];
 extern const char kAndroidSurfaceControlName[];
 extern const char kAndroidSurfaceControlDescription[];
 
+extern const char kAndroidWidgetFullscreenToastName[];
+extern const char kAndroidWidgetFullscreenToastDescription[];
+
 extern const char kAnimatedImageDragShadowName[];
 extern const char kAnimatedImageDragShadowDescription[];
 extern const char kAndroidImprovedBookmarksName[];
diff --git a/chrome/browser/flags/android/chrome_feature_list.cc b/chrome/browser/flags/android/chrome_feature_list.cc
index 55334ce44f141..f527384fc898c 100644
--- a/chrome/browser/flags/android/chrome_feature_list.cc
+++ b/chrome/browser/flags/android/chrome_feature_list.cc
@@ -163,6 +163,7 @@ const base::Feature* const kFeaturesExposedToJava[] = {
     &kAllowNewIncognitoTabIntents,
     &kAndroidScrollOptimizations,
     &kAndroidSearchEngineChoiceNotification,
+    &kAndroidWidgetFullscreenToast,
     &kAndroidImprovedBookmarks,
     &kAnimatedImageDragShadow,
     &kAssistantIntentExperimentId,
@@ -456,6 +457,10 @@ BASE_FEATURE(kAndroidImprovedBookmarks,
              "AndroidImprovedBookmarks",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kAndroidWidgetFullscreenToast,
+             "AndroidWidgetFullscreenToast",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
 BASE_FEATURE(kAnimatedImageDragShadow,
              "AnimatedImageDragShadow",
              base::FEATURE_DISABLED_BY_DEFAULT);
diff --git a/chrome/browser/flags/android/chrome_feature_list.h b/chrome/browser/flags/android/chrome_feature_list.h
index 86015ee610838..a43ab336cfdd5 100644
--- a/chrome/browser/flags/android/chrome_feature_list.h
+++ b/chrome/browser/flags/android/chrome_feature_list.h
@@ -19,6 +19,7 @@ BASE_DECLARE_FEATURE(kAddEduAccountFromAccountSettingsForSupervisedUsers);
 BASE_DECLARE_FEATURE(kAddToHomescreenIPH);
 BASE_DECLARE_FEATURE(kAllowNewIncognitoTabIntents);
 BASE_DECLARE_FEATURE(kAndroidScrollOptimizations);
+BASE_DECLARE_FEATURE(kAndroidWidgetFullscreenToast);
 BASE_DECLARE_FEATURE(kAndroidSearchEngineChoiceNotification);
 BASE_DECLARE_FEATURE(kAndroidImprovedBookmarks);
 BASE_DECLARE_FEATURE(kAnimatedImageDragShadow);
diff --git a/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java b/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java
index 4f675a9d25020..3f007b9bfa75d 100644
--- a/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java
+++ b/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java
@@ -173,6 +173,7 @@ public abstract class ChromeFeatureList {
     public static final String ANDROID_SEARCH_ENGINE_CHOICE_NOTIFICATION =
             "AndroidSearchEngineChoiceNotification";
     public static final String ANDROID_IMPROVED_BOOKMARKS = "AndroidImprovedBookmarks";
+    public static final String ANDROID_WIDGET_FULLSCREEN_TOAST = "AndroidWidgetFullscreenToast";
     public static final String ANIMATED_IMAGE_DRAG_SHADOW = "AnimatedImageDragShadow";
     public static final String APP_LANGUAGE_PROMPT = "AppLanguagePrompt";
     public static final String APP_LANGUAGE_PROMPT_ULP = "AppLanguagePromptULP";
diff --git a/tools/metrics/histograms/enums.xml b/tools/metrics/histograms/enums.xml
index 615554317c627..592e80b455c76 100644
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -59117,6 +59117,7 @@ from previous Chrome versions.
   <int value="-1525129540"
       label="OmniboxUIExperimentRevealSteadyStateUrlPathQueryAndRefOnHover:disabled"/>
   <int value="-1524323669" label="InstalledAppsInCbd:enabled"/>
+  <int value="-1522389453" label="AndroidWidgetFullscreenToast:enabled"/>
   <int value="-1521544926" label="OmniboxPreserveLongerShortcutsText:disabled"/>
   <int value="-1521339691" label="UseGles2ForOopR:disabled"/>
   <int value="-1521160841" label="DismissNtpPromos:enabled"/>
@@ -62871,6 +62872,7 @@ from previous Chrome versions.
   <int value="581355159" label="ContentSuggestionsCategoryRanker:disabled"/>
   <int value="582187448" label="DontPrefetchLibraries:enabled"/>
   <int value="583059655" label="TerminalAlternativeEmulator:enabled"/>
+  <int value="583648374" label="AndroidWidgetFullscreenToast:disabled"/>
   <int value="584509342" label="TerminalTmuxIntegration:enabled"/>
   <int value="584541349" label="ContextualSearchSingleActions:disabled"/>
   <int value="584661108"
