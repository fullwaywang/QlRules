commit b45c6e76bc2c72f6426c14bed64fdcbc9bf37cb0
Author: Andi Kleen <andi@firstfloor.org>
Date:   Fri Jan 8 14:42:52 2010 -0800

    kernel/signal.c: fix kernel information leak with print-fatal-signals=1
    
    When print-fatal-signals is enabled it's possible to dump any memory
    reachable by the kernel to the log by simply jumping to that address from
    user space.
    
    Or crash the system if there's some hardware with read side effects.
    
    The fatal signals handler will dump 16 bytes at the execution address,
    which is fully controlled by ring 3.
    
    In addition when something jumps to a unmapped address there will be up to
    16 additional useless page faults, which might be potentially slow (and at
    least is not very efficient)
    
    Fortunately this option is off by default and only there on i386.
    
    But fix it by checking for kernel addresses and also stopping when there's
    a page fault.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/signal.c b/kernel/signal.c
index d09692b..934ae5e 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -979,7 +979,8 @@ static void print_fatal_signal(struct pt_regs *regs, int signr)
 		for (i = 0; i < 16; i++) {
 			unsigned char insn;
 
-			__get_user(insn, (unsigned char *)(regs->ip + i));
+			if (get_user(insn, (unsigned char *)(regs->ip + i)))
+				break;
 			printk("%02x ", insn);
 		}
 	}
