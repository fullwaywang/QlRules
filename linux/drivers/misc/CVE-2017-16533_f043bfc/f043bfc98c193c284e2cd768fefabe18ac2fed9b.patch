commit f043bfc98c193c284e2cd768fefabe18ac2fed9b
Author: Jaejoong Kim <climbbb.kim@gmail.com>
Date:   Thu Sep 28 19:16:30 2017 +0900

    HID: usbhid: fix out-of-bounds bug
    
    The hid descriptor identifies the length and type of subordinate
    descriptors for a device. If the received hid descriptor is smaller than
    the size of the struct hid_descriptor, it is possible to cause
    out-of-bounds.
    
    In addition, if bNumDescriptors of the hid descriptor have an incorrect
    value, this can also cause out-of-bounds while approaching hdesc->desc[n].
    
    So check the size of hid descriptor and bNumDescriptors.
    
    	BUG: KASAN: slab-out-of-bounds in usbhid_parse+0x9b1/0xa20
    	Read of size 1 at addr ffff88006c5f8edf by task kworker/1:2/1261
    
    	CPU: 1 PID: 1261 Comm: kworker/1:2 Not tainted
    	4.14.0-rc1-42251-gebb2c2437d80 #169
    	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    	Workqueue: usb_hub_wq hub_event
    	Call Trace:
    	__dump_stack lib/dump_stack.c:16
    	dump_stack+0x292/0x395 lib/dump_stack.c:52
    	print_address_description+0x78/0x280 mm/kasan/report.c:252
    	kasan_report_error mm/kasan/report.c:351
    	kasan_report+0x22f/0x340 mm/kasan/report.c:409
    	__asan_report_load1_noabort+0x19/0x20 mm/kasan/report.c:427
    	usbhid_parse+0x9b1/0xa20 drivers/hid/usbhid/hid-core.c:1004
    	hid_add_device+0x16b/0xb30 drivers/hid/hid-core.c:2944
    	usbhid_probe+0xc28/0x1100 drivers/hid/usbhid/hid-core.c:1369
    	usb_probe_interface+0x35d/0x8e0 drivers/usb/core/driver.c:361
    	really_probe drivers/base/dd.c:413
    	driver_probe_device+0x610/0xa00 drivers/base/dd.c:557
    	__device_attach_driver+0x230/0x290 drivers/base/dd.c:653
    	bus_for_each_drv+0x161/0x210 drivers/base/bus.c:463
    	__device_attach+0x26e/0x3d0 drivers/base/dd.c:710
    	device_initial_probe+0x1f/0x30 drivers/base/dd.c:757
    	bus_probe_device+0x1eb/0x290 drivers/base/bus.c:523
    	device_add+0xd0b/0x1660 drivers/base/core.c:1835
    	usb_set_configuration+0x104e/0x1870 drivers/usb/core/message.c:1932
    	generic_probe+0x73/0xe0 drivers/usb/core/generic.c:174
    	usb_probe_device+0xaf/0xe0 drivers/usb/core/driver.c:266
    	really_probe drivers/base/dd.c:413
    	driver_probe_device+0x610/0xa00 drivers/base/dd.c:557
    	__device_attach_driver+0x230/0x290 drivers/base/dd.c:653
    	bus_for_each_drv+0x161/0x210 drivers/base/bus.c:463
    	__device_attach+0x26e/0x3d0 drivers/base/dd.c:710
    	device_initial_probe+0x1f/0x30 drivers/base/dd.c:757
    	bus_probe_device+0x1eb/0x290 drivers/base/bus.c:523
    	device_add+0xd0b/0x1660 drivers/base/core.c:1835
    	usb_new_device+0x7b8/0x1020 drivers/usb/core/hub.c:2457
    	hub_port_connect drivers/usb/core/hub.c:4903
    	hub_port_connect_change drivers/usb/core/hub.c:5009
    	port_event drivers/usb/core/hub.c:5115
    	hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
    	process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
    	worker_thread+0x221/0x1850 kernel/workqueue.c:2253
    	kthread+0x3a1/0x470 kernel/kthread.c:231
    	ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    
    Cc: stable@vger.kernel.org
    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: Jaejoong Kim <climbbb.kim@gmail.com>
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 089bad8..045b5da 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -975,6 +975,8 @@ static int usbhid_parse(struct hid_device *hid)
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
+	int num_descriptors;
+	size_t offset = offsetof(struct hid_descriptor, desc);
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),
 			le16_to_cpu(dev->descriptor.idProduct));
@@ -997,10 +999,18 @@ static int usbhid_parse(struct hid_device *hid)
 		return -ENODEV;
 	}
 
+	if (hdesc->bLength < sizeof(struct hid_descriptor)) {
+		dbg_hid("hid descriptor is too short\n");
+		return -EINVAL;
+	}
+
 	hid->version = le16_to_cpu(hdesc->bcdHID);
 	hid->country = hdesc->bCountryCode;
 
-	for (n = 0; n < hdesc->bNumDescriptors; n++)
+	num_descriptors = min_t(int, hdesc->bNumDescriptors,
+	       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));
+
+	for (n = 0; n < num_descriptors; n++)
 		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
 
