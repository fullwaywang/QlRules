commit cd4c1f165c16c6d8161b5372ef7f61c715e01a42	cd4c1f165c16c6d8161b5372ef7f61c715e01a42
Author: Ken Rockot <rockot@google.com>
Date:   Wed Nov 8 23:22:16 2023 +0000

    Reland: Fix IPC Channel pipe teardown
    
    This is a reland with the new test temporarily disabled on Android
    until it can run without disrupting other tests.
    
    Fixed: 1494461
    Change-Id: If1d83c2dce62020f78dd50abc460973759002a1a
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5015115
    Commit-Queue: Ken Rockot <rockot@google.com>
    Reviewed-by: Robert Sesek <rsesek@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1221953}

diff --git a/ipc/ipc_channel_mojo_unittest.cc b/ipc/ipc_channel_mojo_unittest.cc
index 0074d4a7a024d..26a8f4e71d58d 100644
--- a/ipc/ipc_channel_mojo_unittest.cc
+++ b/ipc/ipc_channel_mojo_unittest.cc
@@ -28,6 +28,7 @@
 #include "base/message_loop/message_pump_type.h"
 #include "base/path_service.h"
 #include "base/pickle.h"
+#include "base/process/process.h"
 #include "base/run_loop.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/single_thread_task_runner.h"
@@ -53,6 +54,7 @@
 #include "mojo/public/cpp/bindings/associated_remote.h"
 #include "mojo/public/cpp/bindings/lib/validation_errors.h"
 #include "mojo/public/cpp/bindings/pending_associated_receiver.h"
+#include "mojo/public/cpp/bindings/self_owned_associated_receiver.h"
 #include "mojo/public/cpp/bindings/urgent_message_scope.h"
 #include "mojo/public/cpp/system/functions.h"
 #include "mojo/public/cpp/system/wait.h"
@@ -1252,7 +1254,9 @@ class SimpleTestClientImpl : public IPC::mojom::SimpleTestClient,
   void set_driver(IPC::mojom::SimpleTestDriver* driver) { driver_ = driver; }
   void set_sync_sender(IPC::Sender* sync_sender) { sync_sender_ = sync_sender; }
 
-  void WaitForValueRequest() {
+  void WaitForValueRequest() { Run(); }
+
+  void Run() {
     run_loop_ = std::make_unique<base::RunLoop>();
     run_loop_->Run();
   }
@@ -1281,6 +1285,32 @@ class SimpleTestClientImpl : public IPC::mojom::SimpleTestClient,
     run_loop_->Quit();
   }
 
+  // No implementation needed. Only called on an endpoint which never binds its
+  // receiver.
+  void BindSync(
+      mojo::PendingAssociatedReceiver<IPC::mojom::SimpleTestClient> receiver,
+      BindSyncCallback callback) override {
+    NOTREACHED();
+  }
+
+  void GetReceiverWithQueuedSyncMessage(
+      GetReceiverWithQueuedSyncMessageCallback callback) override {
+    // Immediately send back a sync IPC over the new pipe and expect the call to
+    // be interrupted without a reply. Note that we also reply *before* issuing
+    // the sync call to allow the main test process to make progress.
+    mojo::AssociatedRemote<IPC::mojom::SimpleTestClient> remote;
+    mojo::PendingAssociatedReceiver<IPC::mojom::SimpleTestClient>
+        queued_receiver;
+    {
+      // The nested receiver we send will already know its peer is closed when
+      // it arrives.
+      mojo::AssociatedRemote<IPC::mojom::SimpleTestClient> unused;
+      queued_receiver = unused.BindNewEndpointAndPassReceiver();
+    }
+    std::move(callback).Run(remote.BindNewEndpointAndPassReceiver());
+    EXPECT_FALSE(remote->BindSync(std::move(queued_receiver)));
+  }
+
   // IPC::Listener:
   bool OnMessageReceived(const IPC::Message& message) override {
     int32_t response;
@@ -1351,6 +1381,99 @@ DEFINE_IPC_CHANNEL_MOJO_TEST_CLIENT_WITH_CUSTOM_FIXTURE(SyncAssociatedInterface,
   DestroyProxy();
 }
 
+// https://crbug.com/1500485: This test causes problems on Android.
+#if BUILDFLAG(IS_ANDROID)
+#define MAYBE_SyncAssociatedInterfacePipeError \
+  DISABLED_SyncAssociatedInterfacePipeError
+#else
+#define MAYBE_SyncAssociatedInterfacePipeError SyncAssociatedInterfacePipeError
+#endif
+TEST_F(IPCChannelProxyMojoTest, MAYBE_SyncAssociatedInterfacePipeError) {
+  // Regression test for https://crbug.com/1494461.
+
+  Init("SyncAssociatedInterfacePipeError");
+
+  ListenerWithSyncAssociatedInterface listener;
+  CreateProxy(&listener);
+  listener.set_sync_sender(proxy());
+  RunProxy();
+
+  mojo::AssociatedRemote<IPC::mojom::SimpleTestClient> client;
+  proxy()->GetRemoteAssociatedInterface(
+      client.BindNewEndpointAndPassReceiver());
+
+  mojo::AssociatedRemote<IPC::mojom::Terminator> terminator;
+  proxy()->GetRemoteAssociatedInterface(
+      terminator.BindNewEndpointAndPassReceiver());
+
+  // The setup here is to have the client process add a new associated endpoint
+  // with a sync message queued on it, towards us. As soon as we receive the
+  // endpoint we close it, but its state (including its inbound sync message
+  // queue) isn't actually destroyed until the peer is closed too.
+  //
+  // Note that the client creates the endpoint rather than us, because client
+  // endpoints are assigned lower interface IDs and will thus elicit the
+  // necessary endpoint ordering to trigger https://crbug.com/1494461 below.
+  {
+    base::RunLoop loop;
+    client->GetReceiverWithQueuedSyncMessage(base::BindLambdaForTesting(
+        [&loop](mojo::PendingAssociatedReceiver<IPC::mojom::SimpleTestClient>
+                    receiver) { loop.Quit(); }));
+    loop.Run();
+  }
+
+  // If https://crbug.com/1494461 is present, it should be hit within this call,
+  // as soon as client termination signals a local pipe error and marks the
+  // above endpoint's peer as closed.
+  EXPECT_FALSE(terminator->Terminate());
+
+#if BUILDFLAG(IS_ANDROID)
+  // NOTE: On Android, the client's forced termination will look like an error,
+  // but it is not.
+  WaitForClientShutdown();
+#else
+  EXPECT_TRUE(WaitForClientShutdown());
+#endif
+
+  DestroyProxy();
+}
+
+class TerminatorImpl : public IPC::mojom::Terminator {
+ public:
+  TerminatorImpl() = default;
+  ~TerminatorImpl() override = default;
+
+  static void Create(
+      mojo::PendingAssociatedReceiver<IPC::mojom::Terminator> receiver) {
+    mojo::MakeSelfOwnedAssociatedReceiver(std::make_unique<TerminatorImpl>(),
+                                          std::move(receiver));
+  }
+
+  // IPC::mojom::Terminator:
+  void Terminate(TerminateCallback callback) override {
+    base::Process::TerminateCurrentProcessImmediately(0);
+  }
+};
+
+DEFINE_IPC_CHANNEL_MOJO_TEST_CLIENT_WITH_CUSTOM_FIXTURE(
+    SyncAssociatedInterfacePipeError,
+    ChannelProxyClient) {
+  SimpleTestClientImpl client_impl;
+  CreateProxy(&client_impl);
+
+  // Let the IO thread receive a message to self-terminate this process. This
+  // is used to forcibly shut down the client on the test's request. Without
+  // doing this (and doing a clean shutdown instead) the client will clean up
+  // interfaces and make it impossible to trigger the regression path for
+  // https://crbug.com/1494461.
+  proxy()->AddAssociatedInterfaceForIOThread(
+      base::BindRepeating(&TerminatorImpl::Create));
+
+  RunProxy();
+  client_impl.Run();
+  DestroyProxy();
+}
+
 TEST_F(IPCChannelProxyMojoTest, Pause) {
   // Ensures that pausing a channel elicits the expected behavior when sending
   // messages, unpausing, sending more messages, and then manually flushing.
diff --git a/ipc/ipc_mojo_bootstrap.cc b/ipc/ipc_mojo_bootstrap.cc
index 558f2ea3d3adb..360901a664769 100644
--- a/ipc/ipc_mojo_bootstrap.cc
+++ b/ipc/ipc_mojo_bootstrap.cc
@@ -827,13 +827,12 @@ class ChannelAssociatedGroupController
         // handle.
         DCHECK(!endpoint->client());
         DCHECK(endpoint->peer_closed());
-        MarkClosedAndMaybeRemove(endpoint);
+        MarkClosed(endpoint);
       } else {
-        MarkPeerClosedAndMaybeRemove(endpoint);
+        MarkPeerClosed(endpoint);
       }
     }
-
-    DCHECK(endpoints_.empty());
+    endpoints_.clear();
 
     GetMemoryDumpProvider().RemoveController(this);
   }
@@ -878,15 +877,19 @@ class ChannelAssociatedGroupController
     base::AutoLock locker(lock_);
     encountered_error_ = true;
 
+    std::vector<uint32_t> endpoints_to_remove;
     std::vector<scoped_refptr<Endpoint>> endpoints_to_notify;
     for (auto iter = endpoints_.begin(); iter != endpoints_.end();) {
       Endpoint* endpoint = iter->second.get();
       ++iter;
 
-      if (endpoint->client())
+      if (endpoint->client()) {
         endpoints_to_notify.push_back(endpoint);
+      }
 
-      MarkPeerClosedAndMaybeRemove(endpoint);
+      if (MarkPeerClosed(endpoint)) {
+        endpoints_to_remove.push_back(endpoint->id());
+      }
     }
 
     for (auto& endpoint : endpoints_to_notify) {
@@ -895,6 +898,10 @@ class ChannelAssociatedGroupController
       if (endpoint->client())
         NotifyEndpointOfError(endpoint.get(), false /* force_async */);
     }
+
+    for (uint32_t id : endpoints_to_remove) {
+      endpoints_.erase(id);
+    }
   }
 
   void NotifyEndpointOfError(Endpoint* endpoint, bool force_async) {
@@ -933,19 +940,33 @@ class ChannelAssociatedGroupController
     NotifyEndpointOfError(endpoint, false /* force_async */);
   }
 
-  void MarkClosedAndMaybeRemove(Endpoint* endpoint) {
+  // Marks `endpoint` as closed and returns true if and only if its peer was
+  // also already closed.
+  bool MarkClosed(Endpoint* endpoint) {
     lock_.AssertAcquired();
     endpoint->set_closed();
-    if (endpoint->closed() && endpoint->peer_closed())
-      endpoints_.erase(endpoint->id());
+    return endpoint->peer_closed();
   }
 
-  void MarkPeerClosedAndMaybeRemove(Endpoint* endpoint) {
+  // Marks `endpoint` as having a closed peer and returns true if and only if
+  // `endpoint` itself was also already closed.
+  bool MarkPeerClosed(Endpoint* endpoint) {
     lock_.AssertAcquired();
     endpoint->set_peer_closed();
     endpoint->SignalSyncMessageEvent();
-    if (endpoint->closed() && endpoint->peer_closed())
+    return endpoint->closed();
+  }
+
+  void MarkClosedAndMaybeRemove(Endpoint* endpoint) {
+    if (MarkClosed(endpoint)) {
       endpoints_.erase(endpoint->id());
+    }
+  }
+
+  void MarkPeerClosedAndMaybeRemove(Endpoint* endpoint) {
+    if (MarkPeerClosed(endpoint)) {
+      endpoints_.erase(endpoint->id());
+    }
   }
 
   Endpoint* FindOrInsertEndpoint(mojo::InterfaceId id, bool* inserted) {
diff --git a/ipc/ipc_test.mojom b/ipc/ipc_test.mojom
index 3d22218351fa8..f20aaea631a45 100644
--- a/ipc/ipc_test.mojom
+++ b/ipc/ipc_test.mojom
@@ -16,9 +16,19 @@ interface SimpleTestDriver {
   RequestQuit() => ();
 };
 
+interface Terminator {
+  [Sync] Terminate() => ();
+};
+
 interface SimpleTestClient {
   [Sync]
   RequestValue() => (int32 value);
+
+  [Sync]
+  BindSync(pending_associated_receiver<SimpleTestClient> receiver) => ();
+
+  GetReceiverWithQueuedSyncMessage() =>
+      (pending_associated_receiver<SimpleTestClient> receiver);
 };
 
 interface PingReceiver {
