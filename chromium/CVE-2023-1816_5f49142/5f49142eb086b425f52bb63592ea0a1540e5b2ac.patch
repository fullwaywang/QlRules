commit 5f49142eb086b425f52bb63592ea0a1540e5b2ac	5f49142eb086b425f52bb63592ea0a1540e5b2ac
Author: Tommy Steimel <steimel@chromium.org>
Date:   Tue Feb 21 12:51:37 2023 +0000

    PiP 2.0: Ensure subsequent about:blank loads close the PiP window
    
    Document PiP windows should always close if navigated from the initial
    about:blank document. However, the logic allowed for about:blank
    navigations to allow the initial navigation to succeed. This opens up a
    couple of issues:
    
    1) Refreshing the PiP document breaks but does not close the document
    
    2) Setting the location of the PiP window to about:blank in JS would
    disconnect the PiP document from the original window and render it
    unusable.
    
    This CL changes that logic to only allow the initial synchronous about:blank navigation to succeed. However, this is insufficient for the
    second issue, since there was a race where if the navigation succeeded
    before the page closed, then the RenderFrameHostImpl would cancel the
    closing action. In order to fix this (and other issues with navigations
    canceling the close action), this CL also makes close requests from the
    browser side always close the page regardless of navigations.
    
    Bug: 1413919, 1406023, 1414124, 1414975
    Change-Id: Ib52875be2ad107ce3f33e2682b0b87f2c7bc6cbf
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4242019
    Reviewed-by: Charlie Reis <creis@chromium.org>
    Commit-Queue: Tommy Steimel <steimel@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#1107695}

diff --git a/chrome/browser/picture_in_picture/document_picture_in_picture_window_controller_browsertest.cc b/chrome/browser/picture_in_picture/document_picture_in_picture_window_controller_browsertest.cc
index 3b2b87422b207..61b94c28017dd 100644
--- a/chrome/browser/picture_in_picture/document_picture_in_picture_window_controller_browsertest.cc
+++ b/chrome/browser/picture_in_picture/document_picture_in_picture_window_controller_browsertest.cc
@@ -267,6 +267,46 @@ IN_PROC_BROWSER_TEST_F(DocumentPictureInPictureWindowControllerBrowserTest,
   EXPECT_TRUE(window_controller()->GetChildWebContents());
 }
 
+// Refreshing the pip window's document should close the pip window.
+IN_PROC_BROWSER_TEST_F(DocumentPictureInPictureWindowControllerBrowserTest,
+                       CloseOnPictureInPictureRefresh) {
+  LoadTabAndEnterPictureInPicture(browser());
+
+  content::WebContents* active_web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_EQ(true, EvalJs(active_web_contents, "refreshInDocumentPipWindow();"));
+  base::RunLoop().RunUntilIdle();
+  EXPECT_FALSE(window_controller()->GetChildWebContents());
+}
+
+// Explicitly navigating to about:blank should close the pip window.
+// Regression test for https://crbug.com/1413919.
+IN_PROC_BROWSER_TEST_F(DocumentPictureInPictureWindowControllerBrowserTest,
+                       CloseOnPictureInPictureNavigatedToAboutBlank) {
+  LoadTabAndEnterPictureInPicture(browser());
+
+  content::WebContents* active_web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_EQ(true, EvalJs(active_web_contents,
+                         "navigateInDocumentPipWindow('about:blank');"));
+  base::RunLoop().RunUntilIdle();
+  EXPECT_FALSE(window_controller()->GetChildWebContents());
+}
+
+// Explicitly navigating to the empty string should close the pip window.
+// Regression test for https://crbug.com/1413919.
+IN_PROC_BROWSER_TEST_F(DocumentPictureInPictureWindowControllerBrowserTest,
+                       CloseOnPictureInPictureNavigatedToEmptyString) {
+  LoadTabAndEnterPictureInPicture(browser());
+
+  content::WebContents* active_web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_EQ(true,
+            EvalJs(active_web_contents, "navigateInDocumentPipWindow('');"));
+  base::RunLoop().RunUntilIdle();
+  EXPECT_FALSE(window_controller()->GetChildWebContents());
+}
+
 // Adding a script to the popup window should not crash.
 IN_PROC_BROWSER_TEST_F(DocumentPictureInPictureWindowControllerBrowserTest,
                        AddScriptToPictureInPictureWindow) {
diff --git a/chrome/test/data/media/picture-in-picture/document-pip.html b/chrome/test/data/media/picture-in-picture/document-pip.html
index aad2f43106ec0..bc7bf71ed9232 100644
--- a/chrome/test/data/media/picture-in-picture/document-pip.html
+++ b/chrome/test/data/media/picture-in-picture/document-pip.html
@@ -16,4 +16,9 @@ function addScriptToPictureInPictureWindow() {
     return pipWindow.document.testvalue == 123;
 }
 
+function refreshInDocumentPipWindow() {
+    pipWindow.location.reload();
+    return true;
+}
+
 </script>
diff --git a/content/browser/picture_in_picture/document_picture_in_picture_window_controller_impl.cc b/content/browser/picture_in_picture/document_picture_in_picture_window_controller_impl.cc
index 632fcbab14ce8..e86494ba0246a 100644
--- a/content/browser/picture_in_picture/document_picture_in_picture_window_controller_impl.cc
+++ b/content/browser/picture_in_picture/document_picture_in_picture_window_controller_impl.cc
@@ -11,6 +11,7 @@
 #include "content/browser/media/media_web_contents_observer.h"
 #include "content/browser/media/session/media_session_impl.h"
 #include "content/browser/picture_in_picture/picture_in_picture_session.h"
+#include "content/browser/renderer_host/navigation_request.h"
 #include "content/browser/web_contents/web_contents_impl.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/navigation_handle.h"
@@ -205,20 +206,30 @@ DocumentPictureInPictureWindowControllerImpl::ChildContentsObserver::
 void DocumentPictureInPictureWindowControllerImpl::ChildContentsObserver::
     DidStartNavigation(NavigationHandle* navigation_handle) {
   // If we've already tried to close the window, then there's nothing to do.
-  if (!force_close_cb_)
+  if (!force_close_cb_) {
     return;
+  }
 
   // Only care if it's the root of the pip window.
-  if (!navigation_handle->IsInPrimaryMainFrame())
+  if (!navigation_handle->IsInPrimaryMainFrame()) {
     return;
+  }
 
   // History / etc. navigations are okay.
-  if (navigation_handle->IsSameDocument())
+  if (navigation_handle->IsSameDocument()) {
     return;
-
-  // about::blank is okay, since that's what it starts with.
-  if (navigation_handle->GetURL().IsAboutBlank())
+  }
+
+  // We allow the synchronous about:blank commit to succeed, since that is part
+  // of most initial navigations. Subsequent navigations to about:blank are
+  // treated like other navigations and close the window.
+  // `is_synchronous_renderer_commit()` will only be true for the initial
+  // about:blank navigation.
+  if (navigation_handle->GetURL().IsAboutBlank() &&
+      NavigationRequest::From(navigation_handle)
+          ->is_synchronous_renderer_commit()) {
     return;
+  }
 
   // Don't run `force_close_cb` from within the observer, since closing
   // `web_contents` is not allowed during an observer callback.
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 856b55b295b2e..978ffd44bf948 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -1614,14 +1614,6 @@ RenderFrameHostImpl::RenderFrameHostImpl(
       base::BindRepeating(&RenderFrameHostImpl::BeforeUnloadTimeout,
                           weak_ptr_factory_.GetWeakPtr()));
 
-  // Only main frames have the ability to close the whole page, so we don't
-  // need this timer for subframes.
-  if (is_main_frame()) {
-    close_timeout_ = std::make_unique<TimeoutMonitor>(
-        base::BindRepeating(&RenderFrameHostImpl::ClosePageTimeout,
-                            weak_ptr_factory_.GetWeakPtr()));
-  }
-
   // Local roots are:
   // - main frames; or
   // - subframes that use a proxy to talk to their parent.
@@ -5467,7 +5459,7 @@ void RenderFrameHostImpl::RequestClose() {
 
   // If the renderer is telling us to close, it has already run the unload
   // events, and we can take the fast path.
-  ClosePageIgnoringUnloadEvents();
+  ClosePageIgnoringUnloadEvents(ClosePageSource::kRenderer);
 }
 
 bool RenderFrameHostImpl::HasStickyUserActivation() const {
@@ -5501,7 +5493,7 @@ void RenderFrameHostImpl::ConsumeHistoryUserActivation() {
   history_user_activation_state_.Consume();
 }
 
-void RenderFrameHostImpl::ClosePage() {
+void RenderFrameHostImpl::ClosePage(ClosePageSource source) {
   // This path is taken when tab/window close is initiated by either the
   // browser process or via a window.close() call through a proxy. In both
   // cases, we need to tell the main frame's renderer process to run unload
@@ -5509,40 +5501,51 @@ void RenderFrameHostImpl::ClosePage() {
   //
   // This should only be called on outermost main frames. If this
   // RenderFrameHost is no longer a primary main frame (e.g., if it was placed
-  // into back-forward cache just before getting here), we should
-  // not close the active tab, so return early in that case.
+  // into back-forward cache or became pending deletion just before getting
+  // here), we should not close the active tab if the request to close came from
+  // the renderer, so return early in that case. We proceed with closing
+  // regardless if the request came from the browser so that renderers can't
+  // avoid closing via navigation.
   DCHECK(is_main_frame());
   // TODO(crbug.com/1254770): Orphaned portals use this code path. Revisit how
   // portals handle unload when migrating off of inner WebContents.
   DCHECK(IsOutermostMainFrame() || frame_tree()->delegate()->IsPortal());
-  if (!IsInPrimaryMainFrame()) {
+  if (!IsInPrimaryMainFrame() && source == ClosePageSource::kRenderer) {
     return;
   }
 
   page_close_state_ = PageCloseState::kRunningUnloadHandlers;
 
   if (IsRenderFrameLive() && !IsPageReadyToBeClosed()) {
+    close_timeout_ = std::make_unique<TimeoutMonitor>(
+        base::BindRepeating(&RenderFrameHostImpl::ClosePageTimeout,
+                            weak_ptr_factory_.GetWeakPtr(), source));
     close_timeout_->Start(kUnloadTimeout);
 
     GetAssociatedLocalMainFrame()->ClosePage(
         base::BindOnce(&RenderFrameHostImpl::ClosePageIgnoringUnloadEvents,
-                       weak_ptr_factory_.GetWeakPtr()));
+                       weak_ptr_factory_.GetWeakPtr(), source));
   } else {
     // This RenderFrameHost doesn't have a live renderer (or has already run
     // unload handlers), so just skip the close event and close the page.
-    ClosePageIgnoringUnloadEvents();
+    ClosePageIgnoringUnloadEvents(source);
   }
 }
 
-void RenderFrameHostImpl::ClosePageIgnoringUnloadEvents() {
-  close_timeout_->Stop();
+void RenderFrameHostImpl::ClosePageIgnoringUnloadEvents(
+    ClosePageSource source) {
+  if (close_timeout_) {
+    close_timeout_->Stop();
+    close_timeout_.reset();
+  }
 
   // If this RenderFrameHost is no longer the primary main frame (e.g., if it
   // was replaced by another frame while waiting for the ClosePage ACK or
-  // timeout), there's no need to close the active tab.
-  //
-  // TODO(crbug.com/1406023): This behavior may need to change.
-  if (!IsInPrimaryMainFrame()) {
+  // timeout), there's no need to close the active tab if the request to close
+  // came from the renderer, so return early in that case. We proceed with
+  // closing regardless if the request came from the browser so that renderers
+  // can't avoid closing via navigation.
+  if (!IsInPrimaryMainFrame() && source == ClosePageSource::kRenderer) {
     page_close_state_ = PageCloseState::kNotClosing;
     return;
   }
@@ -5560,12 +5563,12 @@ bool RenderFrameHostImpl::IsPageReadyToBeClosed() {
          delegate_->IsJavaScriptDialogShowing() || BeforeUnloadTimedOut();
 }
 
-void RenderFrameHostImpl::ClosePageTimeout() {
+void RenderFrameHostImpl::ClosePageTimeout(ClosePageSource source) {
   if (delegate_->ShouldIgnoreUnresponsiveRenderer()) {
     return;
   }
 
-  ClosePageIgnoringUnloadEvents();
+  ClosePageIgnoringUnloadEvents(source);
 }
 
 void RenderFrameHostImpl::ShowCreatedWindow(
diff --git a/content/browser/renderer_host/render_frame_host_impl.h b/content/browser/renderer_host/render_frame_host_impl.h
index 1351752d6122b..555225f08d9de 100644
--- a/content/browser/renderer_host/render_frame_host_impl.h
+++ b/content/browser/renderer_host/render_frame_host_impl.h
@@ -2766,10 +2766,18 @@ class CONTENT_EXPORT RenderFrameHostImpl
   bool IsHistoryUserActivationActive() const;
   void ConsumeHistoryUserActivation();
 
+  // Parameter for `ClosePage()` that indicates whether the request comes from
+  // the browser or the renderer. This is used to determine whether navigation
+  // should prevent the page from closing, since navigations should not prevent
+  // the page from closing if the browser is trying to close the page.
+  enum class ClosePageSource { kRenderer, kBrowser };
+
   // Tells the renderer process to run the page's unload handler.
   // A completion callback is invoked by the renderer when the handler
-  // execution completes.
-  void ClosePage();
+  // execution completes. The `source` parameter indicates whether this request
+  // comes from the browser or the renderer. If the request comes from the
+  // renderer, then it may be ignored if a different document commits first.
+  void ClosePage(ClosePageSource source);
 
   // When true, indicates that the unload handlers have already executed (e.g.,
   // after receiving a ClosePage ACK) or that they should be ignored. This is
@@ -2959,6 +2967,11 @@ class CONTENT_EXPORT RenderFrameHostImpl
   FRIEND_TEST_ALL_PREFIXES(SitePerProcessSSLBrowserTest,
                            UnloadHandlersArePowerfulGrandChild);
   FRIEND_TEST_ALL_PREFIXES(RenderFrameHostImplTest, ExpectedMainWorldOrigin);
+  FRIEND_TEST_ALL_PREFIXES(RenderFrameHostImplTest,
+                           RendererInitiatedCloseIsCancelledIfPageIsntPrimary);
+  FRIEND_TEST_ALL_PREFIXES(
+      RenderFrameHostImplTest,
+      BrowserInitiatedCloseIsNotCancelledIfPageIsntPrimary);
   FRIEND_TEST_ALL_PREFIXES(DocumentUserDataTest, CheckInPendingDeletionState);
   FRIEND_TEST_ALL_PREFIXES(WebContentsImplBrowserTest, FrozenAndUnfrozenIPC);
   FRIEND_TEST_ALL_PREFIXES(RenderFrameHostImplBrowserTest,
@@ -3731,12 +3744,17 @@ class CONTENT_EXPORT RenderFrameHostImpl
   // Close the page ignoring whether it has unload events registered. This is
   // called either (1) when the unload events have already run in the renderer
   // and the ACK is received, or (2) when a timeout for running those events
-  // has expired.
-  void ClosePageIgnoringUnloadEvents();
+  // has expired. The `source` parameter indicates whether this request comes
+  // from the browser or the renderer. If the request comes from the renderer,
+  // then it may be ignored if a different document commits first.
+  void ClosePageIgnoringUnloadEvents(ClosePageSource source);
 
   // Called when this frame's page has started closing via ClosePage(), and the
-  // timer for running unload events has expired.
-  void ClosePageTimeout();
+  // timer for running unload events has expired. The `source` parameter
+  // indicates whether this request comes from the browser or the renderer. If
+  // the request comes from the renderer, then it may be ignored if a different
+  // document commits first.
+  void ClosePageTimeout(ClosePageSource source);
 
   // Send an automatic `reserved.top_navigation` beacon if one was registered
   // with the NavigationRequest's initiator frame using the
diff --git a/content/browser/renderer_host/render_frame_host_impl_unittest.cc b/content/browser/renderer_host/render_frame_host_impl_unittest.cc
index 440fa0cbd35e6..3f2fccace4de8 100644
--- a/content/browser/renderer_host/render_frame_host_impl_unittest.cc
+++ b/content/browser/renderer_host/render_frame_host_impl_unittest.cc
@@ -8,6 +8,7 @@
 #include "base/memory/raw_ptr.h"
 #include "base/test/scoped_feature_list.h"
 #include "build/buildflag.h"
+#include "content/browser/renderer_host/input/timeout_monitor.h"
 #include "content/browser/renderer_host/navigation_controller_impl.h"
 #include "content/browser/renderer_host/render_frame_host_impl.h"
 #include "content/public/browser/cors_origin_pattern_setter.h"
@@ -1065,4 +1066,72 @@ TEST_F(RenderFrameHostImplTest, GetVirtualAuthenticatorManagerWhenInactiveRFH) {
 }
 #endif
 
+namespace {
+
+class MockWebContentsDelegate : public WebContentsDelegate {
+ public:
+  MOCK_METHOD(void, CloseContents, (WebContents*));
+};
+
+}  // namespace
+
+// Ensure that a close request from the renderer process is ignored if a
+// navigation causes a different RenderFrameHost to commit first. See
+// https://crbug.com/1406023.
+TEST_F(RenderFrameHostImplTest,
+       RendererInitiatedCloseIsCancelledIfPageIsntPrimary) {
+  MockWebContentsDelegate delegate;
+  contents()->SetDelegate(&delegate);
+
+  RenderFrameHostImpl* rfh = main_test_rfh();
+  EXPECT_CALL(delegate, CloseContents(contents())).Times(0);
+
+  // Have the renderer request to close the page.
+  rfh->ClosePage(RenderFrameHostImpl::ClosePageSource::kRenderer);
+
+  // The close timeout should be running.
+  EXPECT_TRUE(rfh->close_timeout_ && rfh->close_timeout_->IsRunning());
+
+  // Simulate the rfh going into the back-forward cache before the close timeout
+  // fires.
+  rfh->lifecycle_state_ =
+      RenderFrameHostImpl::LifecycleStateImpl::kInBackForwardCache;
+
+  // Simulate the close timer firing.
+  rfh->ClosePageTimeout(RenderFrameHostImpl::ClosePageSource::kRenderer);
+
+  // The page should not close since it's no longer the primary page.
+  testing::Mock::VerifyAndClearExpectations(&delegate);
+}
+
+// Ensure that a close request from the browser process cannot be ignored even
+// if a navigation causes a different RenderFrameHost to commit first. See
+// https://crbug.com/1406023.
+TEST_F(RenderFrameHostImplTest,
+       BrowserInitiatedCloseIsNotCancelledIfPageIsntPrimary) {
+  MockWebContentsDelegate delegate;
+  contents()->SetDelegate(&delegate);
+
+  RenderFrameHostImpl* rfh = main_test_rfh();
+  EXPECT_CALL(delegate, CloseContents(contents()));
+
+  // Have the browser request to close the page.
+  rfh->ClosePage(RenderFrameHostImpl::ClosePageSource::kBrowser);
+
+  // The close timeout should be running.
+  EXPECT_TRUE(rfh->close_timeout_ && rfh->close_timeout_->IsRunning());
+
+  // Simulate the rfh going into the back-forward cache before the close timeout
+  // fires.
+  rfh->lifecycle_state_ =
+      RenderFrameHostImpl::LifecycleStateImpl::kInBackForwardCache;
+
+  // Simulate the close timer firing.
+  rfh->ClosePageTimeout(RenderFrameHostImpl::ClosePageSource::kBrowser);
+
+  // The page should close regardless of it not being primary since the browser
+  // requested it.
+  testing::Mock::VerifyAndClearExpectations(&delegate);
+}
+
 }  // namespace content
diff --git a/content/browser/renderer_host/render_frame_host_manager.cc b/content/browser/renderer_host/render_frame_host_manager.cc
index 4629ed75c72cc..ddc0a83489ce5 100644
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -571,11 +571,16 @@ void RenderFrameHostManager::BeforeUnloadCompleted(bool proceed) {
     // If we're about to close the tab and there's a speculative RFH, cancel it.
     // Otherwise, if the navigation in the speculative RFH completes before the
     // close in the current RFH, we'll lose the tab close.
+    // TODO(https://crbug.com/1406023): This condition may no longer be needed.
     if (speculative_render_frame_host_) {
       DiscardSpeculativeRFH(NavigationDiscardReason::kWillRemoveFrame);
     }
 
-    render_frame_host_->ClosePage();
+    // TODO(https://crbug.com/1406023): This is not always browser-initiated, so
+    // we should track whether the close is browser or renderer-initiated and
+    // use that here.
+    render_frame_host_->ClosePage(
+        RenderFrameHostImpl::ClosePageSource::kBrowser);
   }
 }
 
diff --git a/content/browser/renderer_host/render_frame_host_manager_unittest.cc b/content/browser/renderer_host/render_frame_host_manager_unittest.cc
index 9d54f59fb9d21..1d9367bae64dc 100644
--- a/content/browser/renderer_host/render_frame_host_manager_unittest.cc
+++ b/content/browser/renderer_host/render_frame_host_manager_unittest.cc
@@ -1662,7 +1662,7 @@ TEST_P(RenderFrameHostManagerTest, CloseWithPendingWhileUnresponsive) {
   TestRenderFrameHost* rfh1 = contents()->GetPrimaryMainFrame();
 
   // Start to close the tab, but assume it's unresponsive.
-  rfh1->ClosePage();
+  rfh1->ClosePage(RenderFrameHostImpl::ClosePageSource::kBrowser);
   EXPECT_EQ(rfh1->page_close_state_,
             RenderFrameHostImpl::PageCloseState::kRunningUnloadHandlers);
 
@@ -1673,7 +1673,7 @@ TEST_P(RenderFrameHostManagerTest, CloseWithPendingWhileUnresponsive) {
   EXPECT_TRUE(contents()->CrossProcessNavigationPending());
 
   // Simulate the unresponsiveness timer.  The tab should close.
-  rfh1->ClosePageTimeout();
+  rfh1->ClosePageTimeout(RenderFrameHostImpl::ClosePageSource::kBrowser);
   EXPECT_TRUE(close_delegate.is_closed());
 }
 
diff --git a/content/browser/renderer_host/render_frame_proxy_host.cc b/content/browser/renderer_host/render_frame_proxy_host.cc
index 1975370065025..b9ddf05085397 100644
--- a/content/browser/renderer_host/render_frame_proxy_host.cc
+++ b/content/browser/renderer_host/render_frame_proxy_host.cc
@@ -631,7 +631,7 @@ void RenderFrameProxyHost::RouteCloseEvent() {
   // the window containing the active RenderFrameHost.
   if (site_instance_group()->IsRelatedSiteInstanceGroup(
           rfh->GetSiteInstance()->group())) {
-    rfh->ClosePage();
+    rfh->ClosePage(RenderFrameHostImpl::ClosePageSource::kRenderer);
   }
 }
 
diff --git a/content/browser/site_per_process_browsertest.cc b/content/browser/site_per_process_browsertest.cc
index d655ab14dbd0a..478e8db5006da 100644
--- a/content/browser/site_per_process_browsertest.cc
+++ b/content/browser/site_per_process_browsertest.cc
@@ -10968,7 +10968,8 @@ class ClosePageBeforeCommitHelper : public DidCommitNavigationInterceptor {
     RenderFrameHostImpl* rfh =
         static_cast<RenderFrameHostImpl*>(render_frame_host);
     EXPECT_TRUE(rfh->render_view_host()->is_active());
-    rfh->GetMainFrame()->ClosePage();
+    rfh->GetMainFrame()->ClosePage(
+        RenderFrameHostImpl::ClosePageSource::kBrowser);
     if (run_loop_)
       run_loop_->Quit();
     return true;
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index f3815af38015c..c63d2821d4c58 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -1635,7 +1635,8 @@ void WebContentsImpl::CancelActiveAndPendingDialogs() {
 
 void WebContentsImpl::ClosePage() {
   OPTIONAL_TRACE_EVENT0("content", "WebContentsImpl::ClosePage");
-  GetPrimaryMainFrame()->ClosePage();
+  GetPrimaryMainFrame()->ClosePage(
+      RenderFrameHostImpl::ClosePageSource::kBrowser);
 }
 
 RenderWidgetHostView* WebContentsImpl::GetRenderWidgetHostView() {
